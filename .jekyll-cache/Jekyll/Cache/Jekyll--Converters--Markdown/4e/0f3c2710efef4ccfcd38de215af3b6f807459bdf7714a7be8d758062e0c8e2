I"òe<p>Decentraland scenes rely on <em>systems</em> to update the information stored in each entityâ€™s <a href="https://en.wikipedia.org/wiki/Entity%E2%80%93component%E2%80%93system">components</a> as the scene changes.</p>

<p><img src="/images/media/ecs-big-picture.png" alt="" /></p>

<p><em>systems</em> are what make scenes dynamic, theyâ€™re able to execute functions periodically on every frame of the sceneâ€™s game loop, changing what will be rendered.</p>

<p>The following example shows a basic system declaration:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Define the system</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">MoveSystem</span> <span class="k">implements</span> <span class="nx">ISystem</span> <span class="p">{</span>
  <span class="c1">//Executed ths function on every frame</span>
  <span class="nx">update</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Iterate over the entities in an component group</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">entity</span> <span class="k">of</span> <span class="nx">myEntityGroup</span><span class="p">.</span><span class="nx">entities</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">transform</span> <span class="o">=</span> <span class="nx">entity</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">Transform</span><span class="p">)</span>
      <span class="nx">transform</span><span class="p">.</span><span class="nx">translate</span><span class="p">(</span><span class="nx">Vector3</span><span class="p">.</span><span class="nx">Forward</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Add system to engine</span>
<span class="nx">engine</span><span class="p">.</span><span class="nx">addSystem</span><span class="p">(</span><span class="k">new</span> <span class="nx">MoveSystem</span><span class="p">())</span>
</code></pre></div></div>

<p>In the example above, the system <code class="language-plaintext highlighter-rouge">MoveSystem</code> executes the <code class="language-plaintext highlighter-rouge">update()</code> function of each frame of the game loop, changing position of every entity in the scene.</p>

<blockquote>
  <p>Note: You must add a <em>System</em> to the engine before its functions can be called.</p>
</blockquote>

<p>All systems act upon entities, changing the values stored in the entityâ€™s components.</p>

<p><img src="/images/media/ecs-system.png" alt="" /></p>

<blockquote>
  <p>Tip: As a simpler alternative to create custom systems, you can use the helpers in the <a href="https://www.npmjs.com/package/decentraland-ecs-utils">utils library</a>. The library creates systems in the background that handle common tasks like moving or rotating entities. In most cases, this library only requires a single line of code to apply these behaviors.</p>
</blockquote>

<p>You can have multiple systems in your scene to decouple different behaviors, making your code cleaner and easier to scale. For example, one system might handle physics, another might make an entity move back and forth continuously, another could handle the AI of characters.</p>

<p>Multiple systems can act on a single entity, for example a non-player character might move on its own based on its AI but also be affected by gravity when trying to walk from off a cliff.</p>

<h2 id="the-update-method">The update method</h2>

<p>The <code class="language-plaintext highlighter-rouge">update()</code> method is a boilerplate function you can extend to define the functionality of a system. Itâ€™s meant to be overwritten and interfaces with the engine in pre-established ways.</p>

<p>The <code class="language-plaintext highlighter-rouge">update()</code> method of a system is executed periodically, once per every frame of the game loop. This happens automatically, you donâ€™t need to explicitly call this function from anywhere in your code.</p>

<p>Typically, the <code class="language-plaintext highlighter-rouge">update()</code> method is where you add most of the logic implemented by the system.</p>

<p>In a Decentraland scene, you can think of the game loop as the aggregation of all the <code class="language-plaintext highlighter-rouge">update()</code> functions in your sceneâ€™s systems.</p>

<h2 id="loop-over-a-component-group">Loop over a component group</h2>

<p>Most of the time, you wonâ€™t want a systemâ€™s update function to iterate over the entire set of entities in the scene, as this could be very costly in terms of processing power. To avoid this, you can create a <a href="/development-guide/component-groups/">component group</a> to keep track of which are the relevant entities, and then have your system iterate over that list.</p>

<p>For example, your scene can have a <code class="language-plaintext highlighter-rouge">PhysicsSystem</code> that calculates the effect of gravity over the entities of your scene. Some entities in your scene, such as trees, are fixed, so it would make sense to avoid wasting energy in calculating the effects of gravity on these. You can then define a component group that keeps track of entities that arenâ€™t fixed and then have <code class="language-plaintext highlighter-rouge">PhysicsSystem</code> only deal with the entities in this group.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create component group</span>
<span class="kd">const</span> <span class="nx">movableEntities</span> <span class="o">=</span> <span class="nx">engine</span><span class="p">.</span><span class="nx">getComponentGroup</span><span class="p">(</span><span class="nx">Physics</span><span class="p">)</span>

<span class="c1">// Create system</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">PhysicsSystem</span> <span class="k">implements</span> <span class="nx">ISystem</span> <span class="p">{</span>
  <span class="nx">update</span><span class="p">(</span><span class="nx">dt</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Iterate over component group</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">entity</span> <span class="k">of</span> <span class="nx">movableEntities</span><span class="p">.</span><span class="nx">entities</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Calculate effect of physics</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="handle-a-single-entity">Handle a single entity</h2>

<p>Some components and systems are meant for using only on one entity in the scene. For example, on an entity that stores a gameâ€™s score or perhaps on a gate of which thereâ€™s only one in the scene. To access one of those entities from a system, you donâ€™t want to create a component group that holds just one single entity.</p>

<p>If you create the entity in the same file as you define the system, then you can simply refer to the entity or its components by name in the systemâ€™s functions.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">class</span> <span class="nx">UpdateScore</span> <span class="k">implements</span> <span class="nx">ISystem</span> <span class="p">{</span>
  <span class="nx">update</span><span class="p">(</span><span class="nx">dt</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">(</span><span class="nx">score</span><span class="p">.</span><span class="nx">points</span><span class="p">)</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">game</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Entity</span><span class="p">()</span>
<span class="kd">const</span> <span class="nx">score</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Score</span><span class="p">()</span>
<span class="nx">game</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span><span class="nx">score</span><span class="p">)</span>
<span class="nx">engine</span><span class="p">.</span><span class="nx">addSystem</span><span class="p">(</span><span class="k">new</span> <span class="nx">UpdateScore</span><span class="p">(</span><span class="nx">game</span><span class="p">))</span>
</code></pre></div></div>

<p>For larger projects, we recommend that you keep system definitions on separate files from the instancing of entities. If you do that, then referring to the entity from the system is tougher, because you canâ€™t just import the entity from <code class="language-plaintext highlighter-rouge">game.ts</code> to the module with the system.</p>

<p>Since systems are also objects, you are free to add variables to them, and also to define a constructor function to pass values to these variables.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">class</span> <span class="nx">UpdateScore</span> <span class="k">implements</span> <span class="nx">ISystem</span> <span class="p">{</span>
  <span class="nl">score</span><span class="p">:</span> <span class="nx">GameScore</span> <span class="c1">// the type is a custom component</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">scoreComponent</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">score</span> <span class="o">=</span> <span class="nx">scoreComponent</span>
  <span class="p">}</span>
  <span class="nx">update</span><span class="p">(</span><span class="nx">dt</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">score</span><span class="p">.</span><span class="nx">points</span><span class="p">)</span>
    <span class="c1">// update values the score object</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When instancing the system in the <code class="language-plaintext highlighter-rouge">game.ts</code> file, you must pass it a reference to the component:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">game</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Entity</span><span class="p">()</span>
<span class="kd">const</span> <span class="nx">score</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Score</span><span class="p">()</span>
<span class="nx">game</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span><span class="nx">score</span><span class="p">)</span>
<span class="nx">engine</span><span class="p">.</span><span class="nx">addSystem</span><span class="p">(</span><span class="k">new</span> <span class="nx">UpdateScore</span><span class="p">(</span><span class="nx">game</span><span class="p">))</span>

<span class="nx">engine</span><span class="p">.</span><span class="nx">addSystem</span><span class="p">(</span><span class="k">new</span> <span class="nx">UpdateScore</span><span class="p">(</span><span class="nx">score</span><span class="p">))</span>
</code></pre></div></div>

<blockquote>
  <p>Note: You could store this data in a custom object instead of an custom component, for more simplicity.</p>
</blockquote>

<h2 id="execute-when-an-entity-is-added">Execute when an entity is added</h2>

<p><code class="language-plaintext highlighter-rouge">onAddEntity()</code> is another boilerplate function of every system that you can overwrite with your own code.</p>

<p>Each time a new entity is added to the engine, this function is called once, passing the new entity as an argument.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">class</span> <span class="nx">mySystem</span> <span class="k">implements</span> <span class="nx">ISystem</span> <span class="p">{</span>
  <span class="nx">onAddEntity</span><span class="p">(</span><span class="nx">entity</span><span class="p">:</span> <span class="nx">Entity</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Code to run once</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="execute-when-an-entity-is-removed">Execute when an entity is removed</h2>

<p><code class="language-plaintext highlighter-rouge">onRemoveEntity()</code> is another boilerplate function of every system that you can overwrite with your own code.</p>

<p>Each time an entity is removed from the engine, this function is called once, passing the removed entity as an argument.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">class</span> <span class="nx">mySystem</span> <span class="k">implements</span> <span class="nx">ISystem</span> <span class="p">{</span>
  <span class="nx">onRemoveEntity</span><span class="p">(</span><span class="nx">entity</span><span class="p">:</span> <span class="nx">Entity</span><span class="p">){}</span>
    <span class="c1">// Code to run once</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="execute-when-a-system-is-activated">Execute when a system is activated</h2>

<p>The <code class="language-plaintext highlighter-rouge">activate()</code> function is another boilerplate function that is executed once when the system is activated.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">class</span> <span class="nx">mySystem</span> <span class="k">implements</span> <span class="nx">ISystem</span> <span class="p">{</span>
  <span class="nx">activate</span><span class="p">(){}</span>
    <span class="c1">// Code to run once</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This can be useful when you have a system that must first carry out some initial steps, for example creating a set of materials of different colors that the update function of the system then switches between. The advantage of using the <code class="language-plaintext highlighter-rouge">activate</code> function instead of just executing these steps as soon as the scene starts, is that if your scene never uses the system, these steps wonâ€™t be executed.</p>

<h2 id="delta-time-between-frames">Delta time between frames</h2>

<p>The <code class="language-plaintext highlighter-rouge">update()</code> method always receives an argument called <code class="language-plaintext highlighter-rouge">dt</code> of type <code class="language-plaintext highlighter-rouge">number</code> (representing <em>delta time</em>), even when this argument isnâ€™t explicitly declared.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">class</span> <span class="nx">mySystem</span> <span class="k">implements</span> <span class="nx">ISystem</span> <span class="p">{</span>
  <span class="nx">update</span><span class="p">(</span><span class="nx">dt</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Update scene</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><em>delta time</em> represents time that it took for the last frame to be processed, in seconds.</p>

<p>Decentraland scenes are updated by default at 30 frames per second. This means that the <code class="language-plaintext highlighter-rouge">dt</code> argument passed to all <code class="language-plaintext highlighter-rouge">update()</code> methods is generally equal to <em>30/1000</em>.</p>

<p>If the processing of a frame takes less time than this interval, then the engine will wait the remaining time to keep updates regularly paced and <code class="language-plaintext highlighter-rouge">dt</code> will remain equal to <em>30/1000</em>.</p>

<p><img src="/images/media/ecs-framerate.png" alt="" /></p>

<p>If the processing of a frame takes longer than <em>30/1000</em> seconds, the drawing of that frame is delayed. The engine then tries to finish that frame and show it as soon as possible. It then proceeds to the next frame and tries to show it <em>30/1000</em> seconds after the last frame. It doesnâ€™t compensate for the previous delay.</p>

<p><img src="/images/media/ecs-framerate-heavy.png" alt="" /></p>

<p>Ideally, you should try to avoid having your scene reach this situation, as it causes a drop in framerate.</p>

<p>The <code class="language-plaintext highlighter-rouge">dt</code> variable becomes useful when frame processing exceeds the default time. Assuming that the current frame will take as much time as the previous, this information may be used to calculate how much to adjust change so that it remains steady and in proportion to the lag between frames.</p>

<p>See <a href="/development-guide/entity-positioning/">entity positioning</a> for examples of how to use <code class="language-plaintext highlighter-rouge">dt</code> to make movement smoother.</p>

<h2 id="loop-at-a-timed-interval">Loop at a timed interval</h2>

<p>If you want a system to execute something at a regular time interval, you can do this by combining the <code class="language-plaintext highlighter-rouge">dt</code> argument with a timer.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">timer</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">10</span>

<span class="k">export</span> <span class="kd">class</span> <span class="nx">LoopSystem</span> <span class="p">{</span>
  <span class="nx">update</span><span class="p">(</span><span class="nx">dt</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">timer</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">timer</span> <span class="o">-=</span> <span class="nx">dt</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">timer</span> <span class="o">=</span> <span class="mi">10</span>
      <span class="c1">// DO SOMETHING</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For more complex use cases, where there may be multiple loops being created dynamically, itâ€™s worth creating a component to store the timer.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// define custom component</span>
<span class="p">@</span><span class="nd">Component</span><span class="p">(</span><span class="dl">"</span><span class="s2">timer</span><span class="dl">"</span><span class="p">)</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">Timer</span> <span class="p">{</span>
  <span class="nl">totalTime</span><span class="p">:</span> <span class="kr">number</span>
  <span class="nx">timeLeft</span><span class="p">:</span> <span class="kr">number</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">time</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">totalTime</span> <span class="o">=</span> <span class="nx">time</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">timeLeft</span> <span class="o">=</span> <span class="nx">time</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// component group to list all entities with a Timer component</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">timers</span> <span class="o">=</span> <span class="nx">engine</span><span class="p">.</span><span class="nx">getComponentGroup</span><span class="p">(</span><span class="nx">Timer</span><span class="p">)</span>

<span class="c1">// system to update all timers</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">LoopSystem</span> <span class="p">{</span>
  <span class="nx">update</span><span class="p">(</span><span class="nx">dt</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">timerEntity</span> <span class="k">of</span> <span class="nx">timers</span><span class="p">.</span><span class="nx">entities</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">timer</span> <span class="o">=</span> <span class="nx">ent</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">Timer</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">timer</span><span class="p">.</span><span class="nx">timeLeft</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">timer</span><span class="p">.</span><span class="nx">timeLeft</span> <span class="o">-=</span> <span class="nx">dt</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">timer</span><span class="p">.</span><span class="nx">timeLeft</span> <span class="o">=</span> <span class="nx">timer</span><span class="p">.</span><span class="nx">totalTime</span>
        <span class="c1">// DO SOMETHING</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="system-execution-order">System execution order</h2>

<p>In some cases, when you have multiple systems running <code class="language-plaintext highlighter-rouge">update()</code> functions, you might care about what system is executed first by your scene.</p>

<p>For example, you might have a <em>physics</em> system that updates the position of entities in the scene, and another <em>boundaries</em> system that ensures that none of the entities are positioned outside the scene boundaries. In this case, you want to make sure that the <em>boundaries</em> system is executed last. Otherwise, the <em>physics</em> system could move entities outside the bounds of the scene but the <em>boundaries</em> system wonâ€™t find out till itâ€™s executed again in the next frame.</p>

<p>When adding a system to the engine, set an optional <code class="language-plaintext highlighter-rouge">priority</code> field to determine when the system is executed in relation to other systems.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">engine</span><span class="p">.</span><span class="nx">addSystem</span><span class="p">(</span><span class="k">new</span> <span class="nx">PhysicsSystem</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
<span class="nx">engine</span><span class="p">.</span><span class="nx">addSystem</span><span class="p">(</span><span class="k">new</span> <span class="nx">BoundariesSystem</span><span class="p">(),</span> <span class="mi">5</span><span class="p">)</span>
</code></pre></div></div>

<p>Systems with a lower priority number are executed first, so a system with a priority of <em>1</em> is executed before one of priority <em>5</em>.</p>

<p>Systems that arenâ€™t given an explicit priority have a default priority of <em>0</em>, so these are executed first.</p>

<p>If two systems have the same priority number, thereâ€™s no way to know for certain which of them will be executed first.</p>

<h2 id="remove-a-system">Remove a system</h2>

<p>An instance of a system can be added or removed from the engine to turn it on or off.</p>

<p>If a system isnâ€™t added to the engine, its functions arenâ€™t called by the engine.</p>

<p>To remove a system, you must first create a pointer to it when instancing it, so that you can refer to the system later.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// add system</span>
<span class="kd">let</span> <span class="nx">mySystemInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">mySystem</span><span class="p">()</span>
<span class="nx">engine</span><span class="p">.</span><span class="nx">addSystemmySystemInstance</span>

<span class="c1">// remove system</span>
<span class="nx">engine</span><span class="p">.</span><span class="nx">removeSystem</span><span class="p">(</span><span class="nx">mySystemInstance</span><span class="p">)</span>
</code></pre></div></div>
:ET