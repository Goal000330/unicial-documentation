I"´Â<p>To move, rotate or resize an entity in your scene, change the <em>position</em>, <em>rotation</em> and <em>scale</em> values stored in an entityâ€™s <code class="language-plaintext highlighter-rouge">Transform</code> component incrementally, frame by frame. This can be used on primitive shapes (cubes, spheres, planes, etc) as well as on 3D models (glTF).</p>

<p>You can easily perform these incremental changes by moving entities a small amount each time the <code class="language-plaintext highlighter-rouge">update()</code> function of a <a href="/development-guide/systems/">system</a> is called.</p>

<blockquote>
  <p>Tip: You can use the helper functions in the <a href="https://www.npmjs.com/package/decentraland-ecs-utils">utils library</a> to achieve most of the tasks described in this doc. The code shown in these examples is handled in the background by the library, so in most cases it only takes a single line of code to use them.</p>
</blockquote>

<h2 id="move">Move</h2>

<p>The easiest way to move an entity is to use the <code class="language-plaintext highlighter-rouge">translate()</code> function to change the <em>position</em> value stored in the <code class="language-plaintext highlighter-rouge">Transform</code> component.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">class</span> <span class="nx">SimpleMove</span> <span class="k">implements</span> <span class="nx">ISystem</span> <span class="p">{</span>
  <span class="nx">update</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">transform</span> <span class="o">=</span> <span class="nx">myEntity</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">Transform</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">distance</span> <span class="o">=</span> <span class="nx">Vector3</span><span class="p">.</span><span class="nx">Forward</span><span class="p">().</span><span class="nx">scale</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="nx">transform</span><span class="p">.</span><span class="nx">translate</span><span class="p">(</span><span class="nx">distance</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">engine</span><span class="p">.</span><span class="nx">addSystem</span><span class="p">(</span><span class="k">new</span> <span class="nx">SimpleMove</span><span class="p">())</span>

<span class="kd">const</span> <span class="nx">myEntity</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Entity</span><span class="p">()</span>
<span class="nx">myEntity</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span><span class="k">new</span> <span class="nx">Transform</span><span class="p">())</span>
<span class="nx">myEntity</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span><span class="k">new</span> <span class="nx">BoxShape</span><span class="p">())</span>

<span class="nx">engine</span><span class="p">.</span><span class="nx">addEntity</span><span class="p">(</span><span class="nx">myEntity</span><span class="p">)</span>
</code></pre></div></div>

<p>In this example weâ€™re moving an entity by 0.1 meters per frame.</p>

<p><code class="language-plaintext highlighter-rouge">Vector3.Forward()</code> returns a vector that faces forward and measures 1 meter in length. In this example weâ€™re then scaling this vector down to 1/10 of its length with <code class="language-plaintext highlighter-rouge">scale()</code>. If our scene has 30 frames per second, the entity is moving at 3 meters per second in speed.</p>

<p><img src="/images/media/gifs/move.gif" alt="Move entity" width="300" /></p>

<h2 id="rotate">Rotate</h2>

<p>The easiest way to rotate an entity is to use the <code class="language-plaintext highlighter-rouge">rotate()</code> function to change the values in the Transform component incrementally, and run this as part of the <code class="language-plaintext highlighter-rouge">update()</code> function of a system.</p>

<p>The <code class="language-plaintext highlighter-rouge">rotate()</code> function takes two arguments:</p>

<ul>
  <li>The direction in which to rotate (as a <em>Vector3</em>)</li>
  <li>The amount to rotate, in <a href="https://en.wikipedia.org/wiki/Euler_angles">euler</a> degrees (from 0 to 360)</li>
</ul>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">class</span> <span class="nx">SimpleRotate</span> <span class="k">implements</span> <span class="nx">ISystem</span> <span class="p">{</span>
  <span class="nx">update</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">transform</span> <span class="o">=</span> <span class="nx">myEntity</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">Transform</span><span class="p">)</span>
    <span class="nx">transform</span><span class="p">.</span><span class="nx">rotate</span><span class="p">(</span><span class="nx">Vector3</span><span class="p">.</span><span class="nx">Left</span><span class="p">(),</span> <span class="mi">3</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">engine</span><span class="p">.</span><span class="nx">addSystem</span><span class="p">(</span><span class="k">new</span> <span class="nx">SimpleRotate</span><span class="p">())</span>

<span class="kd">const</span> <span class="nx">myEntity</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Entity</span><span class="p">()</span>
<span class="nx">myEntity</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span><span class="k">new</span> <span class="nx">Transform</span><span class="p">())</span>
<span class="nx">myEntity</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span><span class="k">new</span> <span class="nx">BoxShape</span><span class="p">())</span>

<span class="nx">engine</span><span class="p">.</span><span class="nx">addEntity</span><span class="p">(</span><span class="nx">myEntity</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p>Tip: To make an entity always rotate to face the player, you can add a <a href="/development-guide/entity-positioning/#face-the-user"><code class="language-plaintext highlighter-rouge">Billboard</code> component</a>.</p>
</blockquote>

<p><img src="/images/media/gifs/rotate.gif" alt="Move entity" width="300" /></p>

<h2 id="rotate-over-a-pivot-point">Rotate over a pivot point</h2>

<p>When rotating an entity, the rotation is always in reference to the entityâ€™s center coordinate. To rotate an entity using another set of coordinates as a pivot point, create a second (invisible) entity with the pivot point as its position and make it a parent of the entity you want to rotate.</p>

<p>When rotating the parent entity, its children will be all rotated using the parentâ€™s position as a pivot point. Note that the <code class="language-plaintext highlighter-rouge">position</code> of the child entity is in reference to that of the parent entity.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create entity you wish to rotate</span>
<span class="kd">const</span> <span class="nx">myEntity</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Entity</span><span class="p">()</span>
<span class="nx">myEntity</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span><span class="k">new</span> <span class="nx">BoxShape</span><span class="p">())</span>

<span class="c1">// Create the pivot entity</span>
<span class="kd">const</span> <span class="nx">pivot</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Entity</span><span class="p">()</span>

<span class="c1">// Position the pivot entity on the pivot point of the rotation</span>
<span class="nx">pivot</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span>
  <span class="k">new</span> <span class="nx">Transform</span><span class="p">({</span>
    <span class="na">position</span><span class="p">:</span> <span class="k">new</span> <span class="nx">Vector3</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
  <span class="p">})</span>
<span class="p">)</span>

<span class="c1">// add pivot entity</span>
<span class="nx">engine</span><span class="p">.</span><span class="nx">addEntity</span><span class="p">(</span><span class="nx">pivot</span><span class="p">)</span>

<span class="c1">// Set pivot as the parent</span>
<span class="nx">myEntity</span><span class="p">.</span><span class="nx">setParent</span><span class="p">(</span><span class="nx">pivot</span><span class="p">)</span>

<span class="c1">// Position child in reference to parent</span>
<span class="nx">myEntity</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span>
  <span class="k">new</span> <span class="nx">Transform</span><span class="p">({</span>
    <span class="na">position</span><span class="p">:</span> <span class="k">new</span> <span class="nx">Vector3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span>
  <span class="p">})</span>
<span class="p">)</span>

<span class="c1">// Define a system that updates the rotation on every frame</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">PivotRotate</span> <span class="k">implements</span> <span class="nx">ISystem</span> <span class="p">{</span>
  <span class="nx">update</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">transform</span> <span class="o">=</span> <span class="nx">pivot</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">Transform</span><span class="p">)</span>
    <span class="nx">transform</span><span class="p">.</span><span class="nx">rotate</span><span class="p">(</span><span class="nx">Vector3</span><span class="p">.</span><span class="nx">Left</span><span class="p">(),</span> <span class="mi">3</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Add the system</span>
<span class="nx">engine</span><span class="p">.</span><span class="nx">addSystem</span><span class="p">(</span><span class="k">new</span> <span class="nx">PivotRotate</span><span class="p">())</span>
</code></pre></div></div>

<p>Note that in this example, the system is rotating the <code class="language-plaintext highlighter-rouge">pivot</code> entity, thatâ€™s a parent of the <code class="language-plaintext highlighter-rouge">door</code> entity.</p>

<p><img src="/images/media/gifs/pivot-rotate.gif" alt="Move entity" width="300" /></p>

<blockquote>
  <p>Note: Child entities should not be explicitly added to the engine, as they are already added via their parent entity.</p>
</blockquote>

<h2 id="adjust-movement-to-delay-time">Adjust movement to delay time</h2>

<p>Suppose that the player visiting your scene is struggling to keep up with the pace of the frame rate. That could result in the movement appearing jumpy, as not all frames are evenly timed but each moves the entity in the same amount.</p>

<p>You can compensate for this uneven timing by using the <code class="language-plaintext highlighter-rouge">dt</code> parameter to adjust the scale the movement.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">class</span> <span class="nx">SimpleMove</span> <span class="k">implements</span> <span class="nx">ISystem</span> <span class="p">{</span>
  <span class="nx">update</span><span class="p">(</span><span class="nx">dt</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">transform</span> <span class="o">=</span> <span class="nx">myEntity</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">Transform</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">distance</span> <span class="o">=</span> <span class="nx">Vector3</span><span class="p">.</span><span class="nx">Forward</span><span class="p">.</span><span class="nx">scale</span><span class="p">(</span><span class="nx">dt</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
    <span class="nx">transform</span><span class="p">.</span><span class="nx">translate</span><span class="p">(</span><span class="nx">distance</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// (...)</span>
</code></pre></div></div>

<p>The example above keeps movement at approximately the same speed as the movement example above, even if the frame rate drops. When running at 30 frames per second, the value of <code class="language-plaintext highlighter-rouge">dt</code> is 1/30.</p>

<p>You can also smoothen rotations in the same way by multiplying the rotation amount by <code class="language-plaintext highlighter-rouge">dt</code>.</p>

<h2 id="move-between-two-points">Move between two points</h2>

<p>If you want an entity to move smoothly between two points, use the <em>lerp</em> (linear interpolation) algorithm. This algorithm is very well known in game development, as itâ€™s really useful.</p>

<p>The <code class="language-plaintext highlighter-rouge">lerp()</code> function takes three parameters:</p>

<ul>
  <li>The vector for the origin position</li>
  <li>The vector for the target position</li>
  <li>The amount, a value from 0 to 1 that represents what fraction of the translation to do.</li>
</ul>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">originVector</span> <span class="o">=</span> <span class="nx">Vector3</span><span class="p">.</span><span class="nx">Zero</span><span class="p">()</span>
<span class="kd">const</span> <span class="nx">targetVector</span> <span class="o">=</span> <span class="nx">Vector3</span><span class="p">.</span><span class="nx">Forward</span><span class="p">()</span>

<span class="kd">let</span> <span class="nx">newPos</span> <span class="o">=</span> <span class="nx">Vector3</span><span class="p">.</span><span class="nx">Lerp</span><span class="p">(</span><span class="nx">originVector</span><span class="p">,</span> <span class="nx">targetVector</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">)</span>
</code></pre></div></div>

<p>The linear interpolation algorithm finds an intermediate point in the path between both vectors that matches the provided amount.</p>

<p>For example, if the origin vector is <em>(0, 0, 0)</em> and the target vector is <em>(10, 0, 10)</em>:</p>

<ul>
  <li>Using an amount of 0 would return <em>(0, 0, 0)</em></li>
  <li>Using an amount of 0.3 would return <em>(3, 0, 3)</em></li>
  <li>Using an amount of 1 would return <em>(10, 0, 10)</em></li>
</ul>

<p>To implement this <code class="language-plaintext highlighter-rouge">lerp()</code> in your scene, we recommend creating a custom component to store the necessary information. You also need to define a system that implements the gradual movement in each frame.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Component</span><span class="p">(</span><span class="dl">"</span><span class="s2">lerpData</span><span class="dl">"</span><span class="p">)</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">LerpData</span> <span class="p">{</span>
  <span class="nl">origin</span><span class="p">:</span> <span class="nx">Vector3</span> <span class="o">=</span> <span class="nx">Vector3</span><span class="p">.</span><span class="nx">Zero</span><span class="p">()</span>
  <span class="nx">target</span><span class="p">:</span> <span class="nx">Vector3</span> <span class="o">=</span> <span class="nx">Vector3</span><span class="p">.</span><span class="nx">Zero</span><span class="p">()</span>
  <span class="nx">fraction</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="c1">// a system to carry out the movement</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">LerpMove</span> <span class="k">implements</span> <span class="nx">ISystem</span> <span class="p">{</span>
  <span class="nx">update</span><span class="p">(</span><span class="nx">dt</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">transform</span> <span class="o">=</span> <span class="nx">myEntity</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">Transform</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">lerp</span> <span class="o">=</span> <span class="nx">myEntity</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">LerpData</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">lerp</span><span class="p">.</span><span class="nx">fraction</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">transform</span><span class="p">.</span><span class="nx">position</span> <span class="o">=</span> <span class="nx">Vector3</span><span class="p">.</span><span class="nx">Lerp</span><span class="p">(</span><span class="nx">lerp</span><span class="p">.</span><span class="nx">origin</span><span class="p">,</span> <span class="nx">lerp</span><span class="p">.</span><span class="nx">target</span><span class="p">,</span> <span class="nx">lerp</span><span class="p">.</span><span class="nx">fraction</span><span class="p">)</span>
      <span class="nx">lerp</span><span class="p">.</span><span class="nx">fraction</span> <span class="o">+=</span> <span class="nx">dt</span> <span class="o">/</span> <span class="mi">6</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Add system to engine</span>
<span class="nx">engine</span><span class="p">.</span><span class="nx">addSystem</span><span class="p">(</span><span class="k">new</span> <span class="nx">LerpMove</span><span class="p">())</span>

<span class="kd">const</span> <span class="nx">myEntity</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Entity</span><span class="p">()</span>
<span class="nx">myEntity</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span><span class="k">new</span> <span class="nx">Transform</span><span class="p">())</span>
<span class="nx">myEntity</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span><span class="k">new</span> <span class="nx">BoxShape</span><span class="p">())</span>

<span class="nx">myEntity</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span><span class="k">new</span> <span class="nx">LerpData</span><span class="p">())</span>
<span class="nx">myEntity</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">LerpData</span><span class="p">).</span><span class="nx">origin</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vector3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="nx">myEntity</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">LerpData</span><span class="p">).</span><span class="nx">target</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vector3</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="nx">engine</span><span class="p">.</span><span class="nx">addEntity</span><span class="p">(</span><span class="nx">myEntity</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/images/media/gifs/lerp-move.gif" alt="Move entity" width="300" /></p>

<h2 id="rotate-between-two-angles">Rotate between two angles</h2>

<p>To rotate smoothly between two angles, use the <em>slerp</em> (<em>spherical</em> linear interpolation) algorithm. This algorithm is very similar to a <em>lerp</em>, but it handles quaternion rotations.</p>

<p>The <code class="language-plaintext highlighter-rouge">slerp()</code> function takes three parameters:</p>

<ul>
  <li>The <a href="https://en.wikipedia.org/wiki/Quaternion">quaternion</a> angle for the origin rotation</li>
  <li>The <a href="https://en.wikipedia.org/wiki/Quaternion">quaternion</a> angle for the target rotation</li>
  <li>The amount, a value from 0 to 1 that represents what fraction of the translation to do.</li>
</ul>

<blockquote>
  <p>Tip: You can pass rotation values in <a href="https://en.wikipedia.org/wiki/Euler_angles">euler</a> degrees (from 0 to 360) by using <code class="language-plaintext highlighter-rouge">Quaternion.Euler()</code>.</p>
</blockquote>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">originRotation</span> <span class="o">=</span> <span class="nx">Quaternion</span><span class="p">.</span><span class="nx">Euler</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="kd">const</span> <span class="nx">targetRotation</span> <span class="o">=</span> <span class="nx">Quaternion</span><span class="p">.</span><span class="nx">Euler</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="kd">let</span> <span class="nx">newRotation</span> <span class="o">=</span> <span class="nx">Quaternion</span><span class="p">.</span><span class="nx">Slerp</span><span class="p">(</span><span class="nx">originRotation</span><span class="p">,</span> <span class="nx">targetRotation</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">)</span>
</code></pre></div></div>

<p>To implement this in your scene, we recommend storing the data that goes into the <code class="language-plaintext highlighter-rouge">Slerp()</code> function in a custom component. You also need to define a system that implements the gradual rotation in each frame.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Component</span><span class="p">(</span><span class="dl">"</span><span class="s2">slerpData</span><span class="dl">"</span><span class="p">)</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">SlerpData</span> <span class="p">{</span>
  <span class="nl">originRot</span><span class="p">:</span> <span class="nx">Quaternion</span> <span class="o">=</span> <span class="nx">Quaternion</span><span class="p">.</span><span class="nx">Euler</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="nx">targetRot</span><span class="p">:</span> <span class="nx">Quaternion</span> <span class="o">=</span> <span class="nx">Quaternion</span><span class="p">.</span><span class="nx">Euler</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="nx">fraction</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="c1">// a system to carry out the rotation</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">SlerpRotate</span> <span class="k">implements</span> <span class="nx">ISystem</span> <span class="p">{</span>
  <span class="nx">update</span><span class="p">(</span><span class="nx">dt</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">slerp</span> <span class="o">=</span> <span class="nx">myEntity</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">SlerpData</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">transform</span> <span class="o">=</span> <span class="nx">myEntity</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">Transform</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">slerp</span><span class="p">.</span><span class="nx">fraction</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">rot</span> <span class="o">=</span> <span class="nx">Quaternion</span><span class="p">.</span><span class="nx">Slerp</span><span class="p">(</span>
        <span class="nx">slerp</span><span class="p">.</span><span class="nx">originRot</span><span class="p">,</span>
        <span class="nx">slerp</span><span class="p">.</span><span class="nx">targetRot</span><span class="p">,</span>
        <span class="nx">slerp</span><span class="p">.</span><span class="nx">fraction</span>
      <span class="p">)</span>
      <span class="nx">transform</span><span class="p">.</span><span class="nx">rotation</span> <span class="o">=</span> <span class="nx">rot</span>
      <span class="nx">slerp</span><span class="p">.</span><span class="nx">fraction</span> <span class="o">+=</span> <span class="nx">dt</span> <span class="o">/</span> <span class="mi">5</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Add system to engine</span>
<span class="nx">engine</span><span class="p">.</span><span class="nx">addSystem</span><span class="p">(</span><span class="k">new</span> <span class="nx">SlerpRotate</span><span class="p">())</span>

<span class="kd">const</span> <span class="nx">myEntity</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Entity</span><span class="p">()</span>
<span class="nx">myEntity</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span><span class="k">new</span> <span class="nx">Transform</span><span class="p">())</span>
<span class="nx">myEntity</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span><span class="k">new</span> <span class="nx">BoxShape</span><span class="p">())</span>

<span class="nx">myEntity</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span><span class="k">new</span> <span class="nx">SlerpData</span><span class="p">())</span>
<span class="nx">myEntity</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">SlerpData</span><span class="p">).</span><span class="nx">originRot</span> <span class="o">=</span> <span class="nx">Quaternion</span><span class="p">.</span><span class="nx">Euler</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="nx">myEntity</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">SlerpData</span><span class="p">).</span><span class="nx">targetRot</span> <span class="o">=</span> <span class="nx">Quaternion</span><span class="p">.</span><span class="nx">Euler</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="nx">engine</span><span class="p">.</span><span class="nx">addEntity</span><span class="p">(</span><span class="nx">myEntity</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p>Note: You could instead represent the rotation with <code class="language-plaintext highlighter-rouge">Vector3</code> values and use a <code class="language-plaintext highlighter-rouge">Lerp()</code> function, but that would imply a conversion from <code class="language-plaintext highlighter-rouge">Vector3</code> to <code class="language-plaintext highlighter-rouge">Quaternion</code> on each frame. Rotation values are internally stored as quaternions in the <code class="language-plaintext highlighter-rouge">Transform</code> component, so itâ€™s more efficient to work with quaternions.</p>
</blockquote>

<p><img src="/images/media/gifs/lerp-rotate.gif" alt="Move entity" width="300" /></p>

<h2 id="change-scale-between-two-sizes">Change scale between two sizes</h2>

<p>If you want an entity to change size smoothly and without changing its proportions, use the <em>lerp</em> (linear interpolation) algorithm of the <code class="language-plaintext highlighter-rouge">Scalar</code> object.</p>

<p>Otherwise, if you want to change the axis in different proportions, use <code class="language-plaintext highlighter-rouge">Vector3</code> to represent the origin scale and the target scale, and then use the <em>lerp</em> function of the <code class="language-plaintext highlighter-rouge">Vector3</code>.</p>

<p>The <code class="language-plaintext highlighter-rouge">lerp()</code> function of the <code class="language-plaintext highlighter-rouge">Scalar</code> object takes three parameters:</p>

<ul>
  <li>A number for the origin scale</li>
  <li>A number for the target scale</li>
  <li>The amount, a value from 0 to 1 that represents what fraction of the scaling to do.</li>
</ul>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">originScale</span> <span class="o">=</span> <span class="mi">1</span>
<span class="kd">const</span> <span class="nx">targetScale</span> <span class="o">=</span> <span class="mi">10</span>

<span class="kd">let</span> <span class="nx">newScale</span> <span class="o">=</span> <span class="nx">Scalar</span><span class="p">.</span><span class="nx">Lerp</span><span class="p">(</span><span class="nx">originScale</span><span class="p">,</span> <span class="nx">targetScale</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">)</span>
</code></pre></div></div>

<p>To implement this lerp in your scene, we recommend creating a custom component to store the necessary information. You also need to define a system that implements the gradual scaling in each frame.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Component</span><span class="p">(</span><span class="dl">"</span><span class="s2">lerpData</span><span class="dl">"</span><span class="p">)</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">LerpSizeData</span> <span class="p">{</span>
  <span class="nl">origin</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mf">0.1</span>
  <span class="nx">target</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="nx">fraction</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="c1">// a system to carry out the movement</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">LerpSize</span> <span class="k">implements</span> <span class="nx">ISystem</span> <span class="p">{</span>
  <span class="nx">update</span><span class="p">(</span><span class="nx">dt</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">transform</span> <span class="o">=</span> <span class="nx">myEntity</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">Transform</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">lerp</span> <span class="o">=</span> <span class="nx">myEntity</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">LerpSizeData</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">lerp</span><span class="p">.</span><span class="nx">fraction</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">newScale</span> <span class="o">=</span> <span class="nx">Scalar</span><span class="p">.</span><span class="nx">Lerp</span><span class="p">(</span><span class="nx">lerp</span><span class="p">.</span><span class="nx">origin</span><span class="p">,</span> <span class="nx">lerp</span><span class="p">.</span><span class="nx">target</span><span class="p">,</span> <span class="nx">lerp</span><span class="p">.</span><span class="nx">fraction</span><span class="p">)</span>
      <span class="nx">transform</span><span class="p">.</span><span class="nx">scale</span><span class="p">.</span><span class="nx">setAll</span><span class="p">(</span><span class="nx">newScale</span><span class="p">)</span>
      <span class="nx">lerp</span><span class="p">.</span><span class="nx">fraction</span> <span class="o">+=</span> <span class="nx">dt</span> <span class="o">/</span> <span class="mi">6</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Add system to engine</span>
<span class="nx">engine</span><span class="p">.</span><span class="nx">addSystem</span><span class="p">(</span><span class="k">new</span> <span class="nx">LerpSize</span><span class="p">())</span>

<span class="kd">const</span> <span class="nx">myEntity</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Entity</span><span class="p">()</span>
<span class="nx">myEntity</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span><span class="k">new</span> <span class="nx">Transform</span><span class="p">())</span>
<span class="nx">myEntity</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span><span class="k">new</span> <span class="nx">BoxShape</span><span class="p">())</span>

<span class="nx">myEntity</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span><span class="k">new</span> <span class="nx">LerpSizeData</span><span class="p">())</span>
<span class="nx">myEntity</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">LerpSizeData</span><span class="p">).</span><span class="nx">origin</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="nx">myEntity</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">LerpSizeData</span><span class="p">).</span><span class="nx">target</span> <span class="o">=</span> <span class="mi">2</span>

<span class="nx">engine</span><span class="p">.</span><span class="nx">addEntity</span><span class="p">(</span><span class="nx">myEntity</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/images/media/gifs/lerp-scale.gif" alt="Move entity" width="300" /></p>

<h2 id="move-at-irregular-speeds-between-two-points">Move at irregular speeds between two points</h2>

<p>While using the lerp method, you can make the movement speed non-linear. In the previous example we increment the lerp amount by a given amount each frame, but we could also use a mathematical function to increase the number exponentially or in other measures that give you a different movement pace.</p>

<p>You could also use a function that gives recurring results, like a sine function, to describe a movement that comes and goes.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Component</span><span class="p">(</span><span class="dl">"</span><span class="s2">lerpData</span><span class="dl">"</span><span class="p">)</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">LerpData</span> <span class="p">{</span>
  <span class="nl">origin</span><span class="p">:</span> <span class="nx">Vector3</span> <span class="o">=</span> <span class="nx">Vector3</span><span class="p">.</span><span class="nx">Zero</span><span class="p">()</span>
  <span class="nx">target</span><span class="p">:</span> <span class="nx">Vector3</span> <span class="o">=</span> <span class="nx">Vector3</span><span class="p">.</span><span class="nx">Zero</span><span class="p">()</span>
  <span class="nx">fraction</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="k">export</span> <span class="kd">class</span> <span class="nx">LerpMove</span> <span class="k">implements</span> <span class="nx">ISystem</span> <span class="p">{</span>
  <span class="nx">update</span><span class="p">(</span><span class="nx">dt</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">transform</span> <span class="o">=</span> <span class="nx">myEntity</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">Transform</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">lerp</span> <span class="o">=</span> <span class="nx">myEntity</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">LerpData</span><span class="p">)</span>
    <span class="nx">lerp</span><span class="p">.</span><span class="nx">fraction</span> <span class="o">+=</span> <span class="p">(</span><span class="nx">dt</span> <span class="o">+</span> <span class="nx">lerp</span><span class="p">.</span><span class="nx">fraction</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span>
    <span class="nx">transform</span><span class="p">.</span><span class="nx">position</span> <span class="o">=</span> <span class="nx">Vector3</span><span class="p">.</span><span class="nx">Lerp</span><span class="p">(</span><span class="nx">lerp</span><span class="p">.</span><span class="nx">origin</span><span class="p">,</span> <span class="nx">lerp</span><span class="p">.</span><span class="nx">target</span><span class="p">,</span> <span class="nx">lerp</span><span class="p">.</span><span class="nx">fraction</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Add system to engine</span>
<span class="nx">engine</span><span class="p">.</span><span class="nx">addSystem</span><span class="p">(</span><span class="k">new</span> <span class="nx">LerpMove</span><span class="p">())</span>
</code></pre></div></div>

<p>The example above is just like the linear lerp example weâ€™ve shown before, but the <code class="language-plaintext highlighter-rouge">fraction</code> field is increased in a non-linear way, resulting in a curve moves the entity by greater increments on each frame.</p>

<p><img src="/images/media/gifs/lerp-speed-up.gif" alt="Move entity" width="300" /></p>

<h2 id="follow-a-path">Follow a path</h2>

<p>A <code class="language-plaintext highlighter-rouge">Path3</code> object stores a series of vectors that describe a path. You can have an entity loop over the list of vectors, performing a lerp movement between each.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">point1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vector3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="kd">const</span> <span class="nx">point2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vector3</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kd">const</span> <span class="nx">point3</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vector3</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="kd">const</span> <span class="nx">point4</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vector3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>

<span class="kd">const</span> <span class="nx">myPath</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Path3D</span><span class="p">([</span><span class="nx">point1</span><span class="p">,</span> <span class="nx">point2</span><span class="p">,</span> <span class="nx">point3</span><span class="p">,</span> <span class="nx">point4</span><span class="p">])</span>

<span class="p">@</span><span class="nd">Component</span><span class="p">(</span><span class="dl">"</span><span class="s2">pathData</span><span class="dl">"</span><span class="p">)</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">PathData</span> <span class="p">{</span>
  <span class="nl">origin</span><span class="p">:</span> <span class="nx">Vector3</span> <span class="o">=</span> <span class="nx">myPath</span><span class="p">.</span><span class="nx">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="nx">target</span><span class="p">:</span> <span class="nx">Vector3</span> <span class="o">=</span> <span class="nx">myPath</span><span class="p">.</span><span class="nx">path</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="nx">fraction</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="nx">nextPathIndex</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="k">export</span> <span class="kd">class</span> <span class="nx">PatrolPath</span> <span class="k">implements</span> <span class="nx">ISystem</span> <span class="p">{</span>
  <span class="nx">update</span><span class="p">(</span><span class="nx">dt</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">transform</span> <span class="o">=</span> <span class="nx">myEntity</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">Transform</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">path</span> <span class="o">=</span> <span class="nx">myEntity</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">PathData</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nx">fraction</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">transform</span><span class="p">.</span><span class="nx">position</span> <span class="o">=</span> <span class="nx">Vector3</span><span class="p">.</span><span class="nx">Lerp</span><span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nx">origin</span><span class="p">,</span> <span class="nx">path</span><span class="p">.</span><span class="nx">target</span><span class="p">,</span> <span class="nx">path</span><span class="p">.</span><span class="nx">fraction</span><span class="p">)</span>
      <span class="nx">path</span><span class="p">.</span><span class="nx">fraction</span> <span class="o">+=</span> <span class="nx">dt</span> <span class="o">/</span> <span class="mi">6</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">path</span><span class="p">.</span><span class="nx">nextPathIndex</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nx">nextPathIndex</span> <span class="o">&gt;=</span> <span class="nx">myPath</span><span class="p">.</span><span class="nx">path</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">path</span><span class="p">.</span><span class="nx">nextPathIndex</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="p">}</span>
      <span class="nx">path</span><span class="p">.</span><span class="nx">origin</span> <span class="o">=</span> <span class="nx">path</span><span class="p">.</span><span class="nx">target</span>
      <span class="nx">path</span><span class="p">.</span><span class="nx">target</span> <span class="o">=</span> <span class="nx">myPath</span><span class="p">.</span><span class="nx">path</span><span class="p">[</span><span class="nx">path</span><span class="p">.</span><span class="nx">nextPathIndex</span><span class="p">]</span>
      <span class="nx">path</span><span class="p">.</span><span class="nx">fraction</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">engine</span><span class="p">.</span><span class="nx">addSystem</span><span class="p">(</span><span class="k">new</span> <span class="nx">PatrolPath</span><span class="p">())</span>

<span class="kd">const</span> <span class="nx">myEntity</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Entity</span><span class="p">()</span>
<span class="nx">myEntity</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span><span class="k">new</span> <span class="nx">Transform</span><span class="p">())</span>
<span class="nx">myEntity</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span><span class="k">new</span> <span class="nx">BoxShape</span><span class="p">())</span>
<span class="nx">myEntity</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span><span class="k">new</span> <span class="nx">PathData</span><span class="p">())</span>

<span class="nx">engine</span><span class="p">.</span><span class="nx">addEntity</span><span class="p">(</span><span class="nx">myEntity</span><span class="p">)</span>
</code></pre></div></div>

<p>The example above defines a 3D path thatâ€™s made up of four 3D vectors. We also define a custom <code class="language-plaintext highlighter-rouge">PathData</code> component, that includes the same data used by the custom component in the <em>lerp</em> example above, but adds a <code class="language-plaintext highlighter-rouge">nextPathIndex</code> field to keep track of what vector to use next from the path.</p>

<p>The system is very similar to the system in the <em>lerp</em> example, but when a lerp action is completed, it sets the <code class="language-plaintext highlighter-rouge">target</code> and <code class="language-plaintext highlighter-rouge">origin</code> fields to new values. If we reach the end of the path, we return to the first value in the path.</p>

<p><img src="/images/media/gifs/lerp-path.gif" alt="Move entity" width="300" /></p>

<!--

## Move along curves

... investigate

-->
:ET