I"ss<p>Decentraland scenes are built around <a href="https://en.wikipedia.org/wiki/Entity%E2%80%93component%E2%80%93system"><em>entities</em>, <em>components</em> and <em>systems</em></a>. This is a common pattern used in the architecture of several game engines, that allows for easy composability and scalability.</p>

<p><img src="/images/media/ecs-big-picture.png" alt="" /></p>

<h2 id="overview">Overview</h2>

<p><em>Entities</em> are the basic unit for building everything in Decentraland scenes. All visible and invisible 3D objects and audio players in your scene will each be an entity. An entity is nothing more than a container that holds components. The entity itself has no properties or methods of its own, it simply groups several components together.</p>

<p><em>Components</em> define the traits of an entity. For example, a <code class="language-plaintext highlighter-rouge">transform</code> component stores the entity’s coordinates, rotation and scale. A <code class="language-plaintext highlighter-rouge">BoxShape</code> component gives the entity a box shape when rendered in the scene, a <code class="language-plaintext highlighter-rouge">Material</code> component gives the entity a color or texture. You could also create a custom <code class="language-plaintext highlighter-rouge">health</code> component to store an entity’s remaining health value, and add it to entities that represent non-player enemies in a game.</p>

<p>If you’re familiar with web development, think of entities as the equivalent of <em>Elements</em> in a <em>DOM</em> tree, and of components as <em>attributes</em> of those elements.</p>

<blockquote>
  <p>Note: In previous versions of the SDK, the <em>scene state</em> was stored in an object that was separate from the entities themselves. As of version 5.0, the <em>scene state</em> is directly embodied by the components that are used by the entities in the scene.</p>
</blockquote>

<p><img src="/images/media/ecs-components.png" alt="Armature" width="400" /></p>

<p>Components like <code class="language-plaintext highlighter-rouge">Transform</code>, <code class="language-plaintext highlighter-rouge">Material</code> or any of the <em>shape</em> components are closely tied in with the rendering of the scene. If the values in these components change, that alone is enough to change how the scene is rendered in the next frame.</p>

<p>Components are meant to store data about their parent entity. They only store this data, they shouldn’t modify it themselves. All changes to the values in the components are carried out by <a href="/development-guide/systems/">Systems</a>. Systems are completely decoupled from the components and entities themselves. Entities and components are agnostic to what <em>systems</em> are acting upon them.</p>

<p>See <a href="https://github.com/decentraland/ecs-reference">Component Reference</a> for a reference of all the available constructors for predefined components.</p>

<h2 id="syntax-for-entities-and-components">Syntax for entities and components</h2>

<p>Entities and components are declared as TypeScript objects. The example below shows some basic operations of declaring, configuring and assigning these.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create an entity</span>
<span class="kd">const</span> <span class="nx">box</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Entity</span><span class="p">()</span>

<span class="c1">// Create and add a `Transform` component to that entity</span>
<span class="nx">box</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span><span class="k">new</span> <span class="nx">Transform</span><span class="p">())</span>

<span class="c1">// Set the fields in the component</span>
<span class="nx">box</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">Transform</span><span class="p">).</span><span class="nx">position</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="c1">// Create and apply a `BoxShape` component to give the entity a visible form</span>
<span class="nx">box</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span><span class="k">new</span> <span class="nx">BoxShape</span><span class="p">())</span>

<span class="c1">// Add the entity to the engine</span>
<span class="nx">engine</span><span class="p">.</span><span class="nx">addEntity</span><span class="p">(</span><span class="nx">box</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="add-entities-to-the-engine">Add entities to the engine</h2>

<p>When you create a new entity, you’re instancing an object and storing it in memory. A newly created entity isn’t <em>rendered</em> and it won’t be possible for a player to interact with it until it’s added to the <em>engine</em>.</p>

<p>The engine is the part of the scene that sits in the middle and manages all of the other parts. It determines what entities are rendered and how players interact with them. It also coordinates what functions from <a href="/development-guide/systems/">systems</a> are executed and when.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create an entity</span>
<span class="kd">const</span> <span class="nx">box</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Entity</span><span class="p">()</span>

<span class="c1">// Give the entity a shape</span>
<span class="nx">box</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span><span class="k">new</span> <span class="nx">BoxShape</span><span class="p">())</span>

<span class="c1">// Add the entity to the engine</span>
<span class="nx">engine</span><span class="p">.</span><span class="nx">addEntity</span><span class="p">(</span><span class="nx">box</span><span class="p">)</span>
</code></pre></div></div>

<p>In the example above, the newly created entity isn’t viewable by players on your scene until it’s added to the engine.</p>

<blockquote>
  <p>Note: Entities aren’t added to <a href="/development-guide/component-groups/">Component groups</a> either until they are added to the engine.</p>
</blockquote>

<p>It’s sometimes useful to preemptively create entities and not add them to the engine until they are needed. This is especially true for entities that have elaborate geometries that might otherwise take long to load.</p>

<p>When an entity is added to the engine, its <code class="language-plaintext highlighter-rouge">alive</code> property is implicitly set to <em>true</em>. You can check if an entity is currently added to the engine via this property.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="nx">myEntity</span><span class="p">.</span><span class="nx">alive</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">the entity is added to the engine</span><span class="dl">"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>Note: It’s always recommended to add a <code class="language-plaintext highlighter-rouge">Transform</code> component to an entity before adding it to the engine. Entities that don’t have a Transform component are rendered in the <em>(0, 0, 0)</em> position of the scene, so if the entity is added before it has a <code class="language-plaintext highlighter-rouge">Transform</code>, it will be momentarily rendered in that position, and with its original size and rotation.</p>
</blockquote>

<h2 id="remove-entities-from-the-engine">Remove entities from the engine</h2>

<p>Entities that have been added to the engine can also be removed from it. When an entity is removed, it stops being rendered by the scene and players can no longer interact with it.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Remove an entity from the engine</span>
<span class="nx">engine</span><span class="p">.</span><span class="nx">removeEntity</span><span class="p">(</span><span class="nx">box</span><span class="p">)</span>
</code></pre></div></div>

<p>Note: Removed entities are also removed from all <a href="/development-guide/component-groups/">Component groups</a>.</p>

<p>If your scene has a pointer referencing a removed entity, it will remain in memory, allowing you to still access and change its component’s values and add it back.</p>

<p>If a removed entity has child entities, all children of that entity are removed too.</p>

<h2 id="nested-entities">Nested entities</h2>

<p>An entity can have other entities as children. Thanks to this, we can arrange entities into trees, just like the HTML of a webpage.</p>

<p><img src="/images/media/ecs-nested-entities.png" alt="nested entities" width="400" /></p>

<p>To set an entity as the parent of another, simply use <code class="language-plaintext highlighter-rouge">.setParent()</code>:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create entities</span>
<span class="kd">const</span> <span class="nx">parentEntity</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Entity</span><span class="p">()</span>
<span class="nx">engine</span><span class="p">.</span><span class="nx">addEntity</span><span class="p">(</span><span class="nx">parentEntity</span><span class="p">)</span>

<span class="kd">const</span> <span class="nx">childEntity</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Entity</span><span class="p">()</span>

<span class="c1">// Set parent</span>
<span class="nx">childEntity</span><span class="p">.</span><span class="nx">setParent</span><span class="p">(</span><span class="nx">parentEntity</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p>Note: Child entities should not be explicitly added to the engine, as they are already added via their parent entity.</p>
</blockquote>

<p>Once a parent is assigned, it can be read off the child entity with <code class="language-plaintext highlighter-rouge">.getParent()</code>.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Get parent from an entity</span>
<span class="kd">const</span> <span class="nx">parent</span> <span class="o">=</span> <span class="nx">childEntity</span><span class="p">.</span><span class="nx">getParent</span><span class="p">()</span>
</code></pre></div></div>

<!--
You can also iterate over an entity's children in the following way.

```ts
// Get the first child listed in the library
for(let id in parent.children){
  const child = parent.children[id]
  // do something with the child entity
}
```

> Note: `.children` returns a library that lists all the child entities.
-->

<p>If a parent entity has a <code class="language-plaintext highlighter-rouge">transform</code> component that affects its position, scale or rotation, its children entities are also affected.</p>

<ul>
  <li>For <strong>position</strong>, the parent’s center is <em>0, 0, 0</em></li>
  <li>For <strong>rotation</strong> the parent’s rotation is the quaternion <em>0, 0, 0, 1</em> (equivalent to the Euler angles <em>0, 0, 0</em>)</li>
  <li>For <strong>scale</strong>, the parent is considered to have a size of <em>1</em>. Any resizing of the parent affects scale and position in proportion.</li>
</ul>

<p>Entities with no shape component are invisible in the scene. These can be used as wrappers to handle and position multiple entities as a group.</p>

<p>To remove an entity’s parent, you can assign the entity’s parent to <code class="language-plaintext highlighter-rouge">null</code>.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">childEntity</span><span class="p">.</span><span class="nx">setParent</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span>
</code></pre></div></div>

<p>If you set a new parent to an entity that already had a parent, the new parent will overwrite the old one.</p>

<h2 id="get-an-entity-by-id">Get an entity by ID</h2>

<p>Every entity in your scene has a unique autogenrated <em>id</em> property. You can retrieve a specific entity from the engine based on this ID, by referring to the <code class="language-plaintext highlighter-rouge">engine.entities[]</code> array.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">engine</span><span class="p">.</span><span class="nx">entities</span><span class="p">[</span><span class="nx">entityId</span><span class="p">]</span>
</code></pre></div></div>

<p>For example, if a player’s click or a raycast hits an entity, this will return the id of the hit entity, and you can use the command above to fetch the entity that matches that id.</p>

<h2 id="add-a-component-to-an-entity">Add a component to an entity</h2>

<p>When a component is added to an entity, the component’s values affect the entity.</p>

<p>One way of doing this is to first create the component instance, and then add it to an entity in a separate expression:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create entity</span>
<span class="kd">const</span> <span class="nx">box</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Entity</span><span class="p">()</span>
<span class="nx">engine</span><span class="p">.</span><span class="nx">addEntity</span><span class="p">(</span><span class="nx">box</span><span class="p">)</span>

<span class="c1">// Create component</span>
<span class="kd">const</span> <span class="nx">myMaterial</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Material</span><span class="p">()</span>

<span class="c1">// Configure component</span>
<span class="nx">myMaterial</span><span class="p">.</span><span class="nx">albedoColor</span> <span class="o">=</span> <span class="nx">Color3</span><span class="p">.</span><span class="nx">Red</span><span class="p">()</span>

<span class="c1">// Add component</span>
<span class="nx">box</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span><span class="nx">myMaterial</span><span class="p">)</span>
</code></pre></div></div>

<p>You can otherwise use a single expression to both create a new instance of a component and add it to an entity:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create entity</span>
<span class="kd">const</span> <span class="nx">box</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Entity</span><span class="p">()</span>
<span class="nx">engine</span><span class="p">.</span><span class="nx">addEntity</span><span class="p">(</span><span class="nx">box</span><span class="p">)</span>

<span class="c1">// Create and add component</span>
<span class="nx">box</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span><span class="k">new</span> <span class="nx">Material</span><span class="p">())</span>

<span class="c1">// Configure component</span>
<span class="nx">box</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">Material</span><span class="p">).</span><span class="nx">albedoColor</span> <span class="o">=</span> <span class="nx">Color3</span><span class="p">.</span><span class="nx">Red</span><span class="p">()</span>
</code></pre></div></div>

<blockquote>
  <p>Note: In the example above, as you never define a pointer to the entity’s material component, you need to refer to it through its parent entity using <code class="language-plaintext highlighter-rouge">.getComponent()</code>.</p>
</blockquote>

<h4 id="add-or-replace-a-component">Add or replace a component</h4>

<p>By using <code class="language-plaintext highlighter-rouge">.addComponentOrReplace()</code> instead of <code class="language-plaintext highlighter-rouge">.addComponent()</code> you overwrite any existing components of the same kind on a specific entity.</p>

<h2 id="remove-a-component-from-an-entity">Remove a component from an entity</h2>

<p>To remove a component from an entity, simply use the entity’s <code class="language-plaintext highlighter-rouge">removeComponent()</code> method.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">myEntity</span><span class="p">.</span><span class="nx">removeComponent</span><span class="p">(</span><span class="nx">Material</span><span class="p">)</span>
</code></pre></div></div>

<p>If you attempt to remove a component that doesn’t exist in the entity, this action won’t raise any errors.</p>

<p>A removed component might still remain in memory even after removed. If your scene adds new components and removes them regularly, these removed components will add up and cause memory problems. It’s advisable to instead use an <a href="#pooling-entities-and-components">object pool</a> when possible to handle these components.</p>

<h2 id="access-a-component-from-an-entity">Access a component from an entity</h2>

<p>You can reach components through their parent entity by using the entity’s <code class="language-plaintext highlighter-rouge">.getComponent()</code> function.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create entity and component</span>
<span class="kd">const</span> <span class="nx">box</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Entity</span><span class="p">()</span>

<span class="c1">// Create and add component</span>
<span class="nx">box</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span><span class="k">new</span> <span class="nx">Transform</span><span class="p">())</span>

<span class="c1">// Using get</span>
<span class="kd">let</span> <span class="nx">transform</span> <span class="o">=</span> <span class="nx">box</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">Transform</span><span class="p">)</span>

<span class="c1">// Edit values in the component</span>
<span class="nx">transform</span><span class="p">.</span><span class="nx">position</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vector3</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">getComponent()</code> function fetches a reference to the component object. If you change the values of what’s returned by this function, you’re changing the component itself. For example, in the example above, we’re setting the <code class="language-plaintext highlighter-rouge">position</code> stored in the component to <em>(5, 0, 5)</em>.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">box</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">Transform</span><span class="p">).</span><span class="nx">scale</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">10</span>
</code></pre></div></div>

<p>The example above directly modifies the value of the <em>x</em> scale on the Transform component.</p>

<p>If you’re not entirely sure if the entity does have the component you’re trying to retrieve, use <code class="language-plaintext highlighter-rouge">getComponentOrNull()</code> or <code class="language-plaintext highlighter-rouge">getComponentOrCreate()</code></p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//  getComponentOrNull</span>
<span class="kd">let</span> <span class="nx">scale</span> <span class="o">=</span> <span class="nx">box</span><span class="p">.</span><span class="nx">getComponentOrNull</span><span class="p">(</span><span class="nx">Transform</span><span class="p">)</span>

<span class="c1">// getComponentOrCreate</span>
<span class="kd">let</span> <span class="nx">scale</span> <span class="o">=</span> <span class="nx">box</span><span class="p">.</span><span class="nx">getComponentOrCreate</span><span class="p">(</span><span class="nx">Transform</span><span class="p">)</span>
</code></pre></div></div>

<p>If the component you’re trying to retrieve doesn’t exist in the entity:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">getComponent()</code> returns an error.</li>
  <li><code class="language-plaintext highlighter-rouge">getComponentOrNull()</code> returns <code class="language-plaintext highlighter-rouge">Null</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">getComponentOrCreate()</code> instances a new component in its place and retrieves it.</li>
</ul>

<p>When you’re dealing with <a href="#interchangeable-components">Interchangeable component</a>, you can also get a component by <em>space name</em> instead of by type. For example, both <code class="language-plaintext highlighter-rouge">BoxShape</code> and <code class="language-plaintext highlighter-rouge">SphereShape</code> occupy the <code class="language-plaintext highlighter-rouge">shape</code> space of an entity. If you don’t know which of these an entity has, you can fetch the <code class="language-plaintext highlighter-rouge">shape</code> of the entity, and it will return whichever component is occupying the <code class="language-plaintext highlighter-rouge">shape</code> space.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">entityShape</span> <span class="o">=</span> <span class="nx">myEntity</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">shape</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="pooling-entities-and-components">Pooling entities and components</h2>

<p>If you plan to spawn and despawn similar entities from your scene, it’s often a good practice to keep a fixed set of entities in memory. Instead of creating new entities and deleting them, you could add and remove existing entities from the engine. This is an efficient way to deal with the player’s memory.</p>

<p>Entities that are not added to the engine aren’t rendered as part of the scene, but they are kept in memory, making them quick to load if needed. Their geometry doesn’t add up to the maximum triangle count four your scene while they aren’t being rendered.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Define spawner singleton object</span>
<span class="kd">const</span> <span class="nx">spawner</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">MAX_POOL_SIZE</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
  <span class="na">pool</span><span class="p">:</span> <span class="p">[]</span> <span class="k">as</span> <span class="nx">Entity</span><span class="p">[],</span>

  <span class="nx">spawnEntity</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Get an entity from the pool</span>
    <span class="kd">const</span> <span class="nx">ent</span> <span class="o">=</span> <span class="nx">spawner</span><span class="p">.</span><span class="nx">getEntityFromPool</span><span class="p">()</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">ent</span><span class="p">)</span> <span class="k">return</span>

    <span class="c1">// Add a transform component to the entity</span>
    <span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">ent</span><span class="p">.</span><span class="nx">getComponentOrCreate</span><span class="p">(</span><span class="nx">Transform</span><span class="p">)</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">scale</span><span class="p">.</span><span class="nx">setAll</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">position</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

    <span class="c1">//add entity to engine</span>
    <span class="nx">engine</span><span class="p">.</span><span class="nx">addEntity</span><span class="p">(</span><span class="nx">ent</span><span class="p">)</span>
  <span class="p">},</span>

  <span class="nx">getEntityFromPool</span><span class="p">():</span> <span class="nx">Entity</span> <span class="o">|</span> <span class="kc">null</span> <span class="p">{</span>
    <span class="c1">// Check if an existing entity can be used</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">spawner</span><span class="p">.</span><span class="nx">pool</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">spawner</span><span class="p">.</span><span class="nx">pool</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">alive</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">spawner</span><span class="p">.</span><span class="nx">pool</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// If none of the existing are available, create a new one, unless the maximum pool size is reached</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">spawner</span><span class="p">.</span><span class="nx">pool</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="nx">spawner</span><span class="p">.</span><span class="nx">MAX_POOL_SIZE</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Entity</span><span class="p">()</span>
      <span class="nx">spawner</span><span class="p">.</span><span class="nx">pool</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">instance</span><span class="p">)</span>
      <span class="k">return</span> <span class="nx">instance</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">null</span>
  <span class="p">},</span>
<span class="p">}</span>

<span class="nx">spawner</span><span class="p">.</span><span class="nx">spawnEntity</span><span class="p">()</span>
</code></pre></div></div>

<p>When adding an entity to the engine, its <code class="language-plaintext highlighter-rouge">alive</code> field is implicitly set to <code class="language-plaintext highlighter-rouge">true</code>, when removing it, this field is set to <code class="language-plaintext highlighter-rouge">false</code>.</p>

<p>Using an object pool has the following benefits:</p>

<ul>
  <li>If your entity uses a complex 3D model or texture, it might take the scene some time to load it from the content server. If the entity is already in memory when it’s needed, then that delay won’t happen.</li>
  <li>This is a solution to avoid a common problem, where each entity that’s removed could remain lingering in memory after being removed, and these unused entities could add up till they become too many to handle. By recycling the same entities, you ensure this won’t happen.</li>
</ul>

<!--
Similarly, if you plan to set and remove certain components from your entities, it's recommendable to create a pool of fixed components to add and remove rather than create new component instances each time.

```ts
```
-->
:ET