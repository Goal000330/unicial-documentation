I"d&<h2 id="overview">Overview</h2>

<p>Most of the code in your scene runs synchronously using a single thread. That means that commands are executed sequentially line by line. Each command must first wait for the previous command to finish executing before it can start.</p>

<p>Even the <code class="language-plaintext highlighter-rouge">update()</code> functions in your scene’s systems are executed one by one, following a <a href="/development-guide/systems/#system-execution-order">priority order</a>.</p>

<p>Running code synchronously ensures consistency, as you can always be sure you’ll know the order in which the commands in your code run.</p>

<p>On the other hand, your scene needs to be updated many times per second, building the next frame. If a part of your code takes too long to respond, then the whole main thread is stuck and this results in lagging frame rates.</p>

<p>That’s why, in some cases you want some commands to run asynchronously. This means that you can start off a task in a new thread, and meanwhile the main thread can keep running over the the next lines of code.</p>

<p>This is especially useful for tasks that rely on external services that could take time to respond, as you don’t want that idle time waiting for that response to block other tasks.</p>

<p>For example:</p>

<ul>
  <li>When playing a sound file</li>
  <li>When retrieving data from a REST API</li>
  <li>When performing a transaction on the blockchain</li>
</ul>

<blockquote>
  <p>Note: Keep in mind that several frames of your scene might be rendered before the task finishes executing. Make sure your scene’s code is flexible enough to handle the in-between scenarios while the asynchronous task is being completed.</p>
</blockquote>

<h2 id="run-an-async-function">Run an async function</h2>

<p>Mark any function as <code class="language-plaintext highlighter-rouge">async</code> so that it runs on a separate thread from the scene’s main thread every time that it’s called.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// declare function</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nx">myAsyncTask</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// run async steps</span>
<span class="p">}</span>

<span class="c1">// call function</span>
<span class="nx">myAsyncTask</span><span class="p">()</span>

<span class="c1">// rest of the code keeps being executed</span>
</code></pre></div></div>

<h2 id="the-executetask-function">The executeTask function</h2>

<p>The <code class="language-plaintext highlighter-rouge">executeTask</code> function executes a lambda function asynchronously, in a separate thread from the scene’s main thread.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">executeTask</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">myAsyncTask</span><span class="p">()</span>
  <span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
<span class="p">})</span>

<span class="c1">// rest of the code keeps being executed</span>
</code></pre></div></div>

<h2 id="the-then-function">The then function</h2>

<p>The <code class="language-plaintext highlighter-rouge">then</code> function takes in a lambda function as an argument, that only gets executed once the prior statement is finished. This lambda function can optionally have inputs that are mapped from whatever the prior statement returns.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">myAsyncTask</span><span class="p">().</span><span class="nx">then</span><span class="p">((</span><span class="nx">data</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></div></div>

<blockquote>
  <p>Note: It’s generally better to use the <code class="language-plaintext highlighter-rouge">executeTask</code> approach rather than the <code class="language-plaintext highlighter-rouge">then</code> function. In this example, the scene won’t be considered fully loaded by the explorer till the <code class="language-plaintext highlighter-rouge">myAsyncTask()</code> function is completed, which may affect load times. Also, if relying too much on the <code class="language-plaintext highlighter-rouge">then</code> function at multiple nested levels, you can end up with what’s known as “callback hell”, where the code can become very hard to read and maintain.</p>
</blockquote>

<h2 id="onpointerdown-functions">OnPointerDown functions</h2>

<p>You can add an <code class="language-plaintext highlighter-rouge">OnPointerDown</code> component to any entity to trigger an asynchronous lambda function every time that entity is clicked.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">myEntity</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span>
  <span class="k">new</span> <span class="nx">OnPointerDown</span><span class="p">((</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">clicked on the entity</span><span class="dl">"</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">)</span>
</code></pre></div></div>

<h2 id="subscribe-a-listener">Subscribe a listener</h2>

<p>Another way to run asynchronous code is to instance an event listener. Event listeners trigger the running of an asynchronous lambda function every time that a given event occurs.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Input</span><span class="p">.</span><span class="nx">instance</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="dl">"</span><span class="s2">BUTTON_DOWN</span><span class="dl">"</span><span class="p">,</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">pointerUp works</span><span class="dl">"</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></div></div>

<p>The example above runs a function every time that the button <em>A</em> is pressed down.</p>

<h2 id="the-await-statement">The await statement</h2>

<p>An <code class="language-plaintext highlighter-rouge">await</code> statement forces the execution to wait for a response before moving over to the next line of code. <code class="language-plaintext highlighter-rouge">await</code> statements can only be used inside an async block of code.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// declare function</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nx">myAsyncTask</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">callUrl</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">json</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">()</span>
    <span class="nx">log</span><span class="p">(</span><span class="nx">json</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">failed to reach the URL</span><span class="dl">"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// call function</span>
<span class="nx">myAsyncTask</span><span class="p">()</span>

<span class="c1">// Rest of the code keeps being executed</span>
</code></pre></div></div>

<p>The example above executes a function that includes a <code class="language-plaintext highlighter-rouge">fetch()</code> operation to retrieve data from an external API. The <code class="language-plaintext highlighter-rouge">fetch()</code> operation is asynchronous, as we can’t predict how long the server will take to respond. However, the next line needs the output of this operation to be ready before we can parse it as a json. The <code class="language-plaintext highlighter-rouge">await</code> statement here ensures that the next line will only run once that operation has returned a value. Similarly, the <code class="language-plaintext highlighter-rouge">response.json()</code> function is also asynchronous, but the next line needs the json to be parsed before it can log it. The second <code class="language-plaintext highlighter-rouge">await</code> statement forces the next line to only be called once the parsing of the json is finished, however long it takes.</p>
:ET