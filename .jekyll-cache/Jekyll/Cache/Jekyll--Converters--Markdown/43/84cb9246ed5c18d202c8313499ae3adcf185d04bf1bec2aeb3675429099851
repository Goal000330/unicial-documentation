I"z9<p>Your scene can leverage external services that expose APIs, you can use this to obtain updated price data, weather data or any other kind of information exposed by an API.</p>

<p>You can also set up your own external server to aid your scene and serve to synchronize data between your players. This can either be done with a server that exposes a REST API, or with a server that uses WebSockets.</p>

<h2 id="call-a-rest-api">Call a REST API</h2>

<p>Your scene’s code can send calls to a REST API to fetch data.</p>

<p>Since the server might take time to send its response, you must execute this command as an <a href="/development-guide/async-functions/">asynchronous function</a>, using <code class="language-plaintext highlighter-rouge">executeTask()</code>.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">executeTask</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">callUrl</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">json</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">()</span>
    <span class="nx">log</span><span class="p">(</span><span class="nx">json</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">failed to reach URL</span><span class="dl">"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">})</span>
</code></pre></div></div>

<p>The fetch command can also include a second optional argument that bundles headers, HTTP method and HTTP body into a single object.</p>

<ul>
  <li><strong>url</strong>: Address to send the request</li>
  <li><strong>init</strong>: A <code class="language-plaintext highlighter-rouge">FlatFetchInit</code> object that may contain:
    <ul>
      <li><strong>method</strong> : HTTP method to use (GET, POST, DELETE, etc)</li>
      <li><strong>body</strong>: Contents of the request body. It must be sent as a stringified JSON object.</li>
      <li><strong>headers</strong>: Additional headers to include in the request. Headers related to the signature are added automatically.</li>
      <li>
        <table>
          <tbody>
            <tr>
              <td><strong>redirect</strong>: Redirect strategy (‘follow’</td>
              <td>‘error’</td>
              <td>‘manual’)</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li><strong>responseBodyType</strong>: Specify if the body of the response is ‘text’ or ‘json’</li>
    </ul>
  </li>
</ul>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">executeTask</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">callUrl</span><span class="p">,</span> <span class="p">{</span>
      <span class="na">headers</span><span class="p">:</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">Content-Type</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">application/json</span><span class="dl">"</span> <span class="p">},</span>
      <span class="na">method</span><span class="p">:</span> <span class="dl">"</span><span class="s2">POST</span><span class="dl">"</span><span class="p">,</span>
      <span class="na">body</span><span class="p">:</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">myBody</span><span class="p">),</span>
    <span class="p">})</span>
    <span class="kd">let</span> <span class="nx">json</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">()</span>
    <span class="nx">log</span><span class="p">(</span><span class="nx">json</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">failed to reach URL</span><span class="dl">"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">})</span>
</code></pre></div></div>

<p>The fetch command returns a <code class="language-plaintext highlighter-rouge">response</code> object with the following data:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">headers</code>: A <code class="language-plaintext highlighter-rouge">ReadOnlyHeaders</code> object. Call the <code class="language-plaintext highlighter-rouge">get()</code> method to obtain a specific header, or the <code class="language-plaintext highlighter-rouge">has()</code> method to check if a header is present.</li>
  <li><code class="language-plaintext highlighter-rouge">ok</code>: Boolean</li>
  <li><code class="language-plaintext highlighter-rouge">redirected</code>: Boolean</li>
  <li><code class="language-plaintext highlighter-rouge">status</code>: Status code number</li>
  <li><code class="language-plaintext highlighter-rouge">statusText</code>: Text for the status code</li>
  <li><code class="language-plaintext highlighter-rouge">type</code>: Will have one of the following values: <em>basic</em>, <em>cors</em>, <em>default</em>, <em>error</em>, <em>opaque</em>, <em>opaqueredirect</em></li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">url</code>: URL that was sent</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">json()</code>: Obtain the body in JSON format.</li>
  <li><code class="language-plaintext highlighter-rouge">text()</code>: Obtain the body as text.</li>
</ul>

<blockquote>
  <p>Note: <code class="language-plaintext highlighter-rouge">json()</code> and <code class="language-plaintext highlighter-rouge">text()</code> are mutually exclusive. If you obtain the body of the response in one of the two formats, you can no longer obtain the other from the <code class="language-plaintext highlighter-rouge">response</code> object.</p>
</blockquote>

<blockquote>
  <p>Note: Each Decentraland scene is only permitted to perform one <code class="language-plaintext highlighter-rouge">fetch</code> command at a time. This has no effect on how the scene code must be structured, as requests are queued internally. If your scene requires sending multiple requests to different endpoints, keep in mind that each request is only sent when the previous one has been responded.</p>
</blockquote>

<h2 id="signed-requests">Signed requests</h2>

<p>You can employ an extra security measure to certify that a request is originating from a player session inside Decentraland. You can send your requests with an additional signature, that is signed using an ephemeral key that the Decentraland session generates for each player based on the player’s address. The server receiving the request can then verify that the signed message indeed matches an address that is currently active in-world.</p>

<p>These kinds of security measures are especially valuable when there may be an incentive for a player to abuse the system, to farm tokens or points in a game.</p>

<p>To send a signed request, all you need to do is use the <code class="language-plaintext highlighter-rouge">signedFetch()</code> function, in exactly the same way as you would use the <code class="language-plaintext highlighter-rouge">fetch()</code> function.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">executeTask</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">signedFetch</span><span class="p">(</span><span class="nx">callUrl</span><span class="p">,</span> <span class="p">{</span>
      <span class="na">headers</span><span class="p">:</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">Content-Type</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">application/json</span><span class="dl">"</span> <span class="p">},</span>
      <span class="na">method</span><span class="p">:</span> <span class="dl">"</span><span class="s2">POST</span><span class="dl">"</span><span class="p">,</span>
      <span class="na">body</span><span class="p">:</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">myBody</span><span class="p">),</span>
    <span class="p">})</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">response</span><span class="p">.</span><span class="nx">text</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">Invalid response</span><span class="dl">"</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">let</span> <span class="nx">json</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">text</span><span class="p">)</span>

    <span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Response received: </span><span class="dl">"</span><span class="p">,</span> <span class="nx">json</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">failed to reach URL</span><span class="dl">"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">})</span>
</code></pre></div></div>

<p>The request will include an additional series of headers, containing a signed message and a set of metadata to interpret that. The signed message consists of all the contents of the request encrypted using the player’s ephemeral key.</p>

<p>The <code class="language-plaintext highlighter-rouge">signedFetch()</code> differs from the <code class="language-plaintext highlighter-rouge">fetch()</code> function in that the response is a promise of a full http message, expressed as a <code class="language-plaintext highlighter-rouge">FlatFetchInit</code> object. This includes the properties <code class="language-plaintext highlighter-rouge">text</code>, <code class="language-plaintext highlighter-rouge">ok</code>, <code class="language-plaintext highlighter-rouge">status</code>, <code class="language-plaintext highlighter-rouge">headers</code>, among others. By default, the To access the <strong>body</strong> of the response, parse the <code class="language-plaintext highlighter-rouge">text</code> property of the response as in the example above. If the response body is in json format, you can specify that in the <code class="language-plaintext highlighter-rouge">responseBodyType</code> and then access that from the <code class="language-plaintext highlighter-rouge">json</code> property in the response.</p>

<h4 id="validating-a-signed-request">Validating a signed request</h4>

<p>To make make use of signed requests, the server receiving these should to validate that the signatures match the rest of the request, and that the timestamp that’s encoded within the signed message is current.</p>

<p>You can find a simple example of a server performing this task in the following example scene:</p>

<p><a href="https://github.com/decentraland-scenes/validate-player-authenticity">Validate player authenticity</a></p>

<h2 id="use-websockets">Use WebSockets</h2>

<p>You can also send and obtain data from a WebSocket server, as long as this server uses a secured connection with <em>wss</em>.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">socket</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WebSocket</span><span class="p">(</span><span class="dl">"</span><span class="s2">url</span><span class="dl">"</span><span class="p">)</span>

<span class="nx">socket</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">WebSocket message received:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">event</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The syntax to use WebSockets is no different from that implemented natively by JavaScript. See the documentation from <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">Mozilla Web API</a> for details on how to catch and send messages over WebSockets.</p>

<blockquote>
  <p>TIP: One library that simplifies the use of websocket connections and has been proven to work very well with Decentraland is <a href="https://colyseus.io/">Colyseus</a>. It builds a layer of abstraction on top of the websocket connections that makes reacting to changes and storing a consistent game state remotely in the server super easy. You can see it in action in <a href="https://github.com/decentraland-scenes/Awesome-Repository#colyseus">these examples</a>. Several other websocket libraries aren’t compatible with the Decentraland SDK.</p>
</blockquote>
:ET