I"@_<p>Raycasting is a fundamental tool in game development. With raycasting, you can trace an imaginary line in space, and query if any entities are intersected by the line. This is useful for calculating lines of sight, trajectories of bullets, pathfinding algorithms and many other applications.</p>

<p>When a player clicks or pushes the primary or secondary button, a ray is traced from the player’s position in the direction they are looking, see <a href="/development-guide/click-events/">button events</a> for more details about this. This document covers how to trace an invisible ray from any arbitrary position and direction, independent of player actions, which you can use in many other scenarios.</p>

<h2 id="physicscast">PhysicsCast</h2>

<p>The <code class="language-plaintext highlighter-rouge">PhysicsCast</code> object is a static class that serves as the main raycasting interface. You can refer to it in your scene as <code class="language-plaintext highlighter-rouge">PhysicsCast.instance</code>. You’ll see it has several methods that are all specific to raycasting.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">physicsCast</span> <span class="o">=</span> <span class="nx">PhysicsCast</span><span class="p">.</span><span class="nx">instance</span>
</code></pre></div></div>

<h2 id="create-a-ray">Create a ray</h2>

<p>A ray object describes the invisible ray that will be used to query for entities. Rays are defined using three bits of information:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">origin</code>: <em>Vector3</em> with the coordinates in scene space to start the ray from.</li>
  <li><code class="language-plaintext highlighter-rouge">direction</code>: <em>Vector3</em> describing the direction (as if the ray started from <em>0,0,0</em>).</li>
  <li><code class="language-plaintext highlighter-rouge">distance</code>: <em>number</em> to set the length with which this ray will be traced.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">originPos</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vector3</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="kd">let</span> <span class="nx">direction</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vector3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="kd">let</span> <span class="nx">ray</span><span class="p">:</span> <span class="nx">Ray</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">origin</span><span class="p">:</span> <span class="nx">originPos</span><span class="p">,</span>
  <span class="na">direction</span><span class="p">:</span> <span class="nx">direction</span><span class="p">,</span>
  <span class="na">distance</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As an alternative, you can also generate a ray from providing two points in space. Both the direction and distance will be implicit in this information. To do this, use the <code class="language-plaintext highlighter-rouge">getRayFromPositions()</code> method of the <code class="language-plaintext highlighter-rouge">PhysicsCast</code> object.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">physicsCast</span> <span class="o">=</span> <span class="nx">PhysicsCast</span><span class="p">.</span><span class="nx">instance</span>

<span class="kd">let</span> <span class="nx">originPos</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vector3</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="kd">let</span> <span class="nx">targetPos</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vector3</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="kd">let</span> <span class="nx">rayFromPoints</span> <span class="o">=</span> <span class="nx">physicsCast</span><span class="p">.</span><span class="nx">getRayFromPositions</span><span class="p">(</span><span class="nx">originPos</span><span class="p">,</span> <span class="nx">targetPos</span><span class="p">)</span>
</code></pre></div></div>

<p>You can also get generate a ray from the player’s current position and rotation. The only piece of information you need to pass in this case is the distance. To do this, use the <code class="language-plaintext highlighter-rouge">getRayFromCamera()</code> method of the <code class="language-plaintext highlighter-rouge">PhysicsCast</code> object.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">physicsCast</span> <span class="o">=</span> <span class="nx">PhysicsCast</span><span class="p">.</span><span class="nx">instance</span>

<span class="kd">let</span> <span class="nx">rayFromCamera</span> <span class="o">=</span> <span class="nx">physicsCast</span><span class="p">.</span><span class="nx">getRayFromCamera</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="run-a-raycast-query">Run a raycast query</h2>

<p>Raycast queries are run by the <code class="language-plaintext highlighter-rouge">PhysicsCast</code> class. there are two methods available for doing this:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">hitFirst()</code>: this method only returns the first hit entity, starting from the origin point.</li>
  <li><code class="language-plaintext highlighter-rouge">hitAll()</code>: this method returns all hit entities, from the origin through to the length of the ray.</li>
</ul>

<p>Both these methods need to be passed the following:</p>

<ul>
  <li>a Ray object</li>
  <li>a callback function to execute after the query</li>
  <li>an optional raycast id, to handle separate lossy queues</li>
</ul>

<!--
![](/images/media/raycast.png)
-->

<p>Note that the callback function is always executed, even if no entities were hit by the ray.</p>

<p>This sample queries only for the first entity hit by the ray:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">physicsCast</span> <span class="o">=</span> <span class="nx">PhysicsCast</span><span class="p">.</span><span class="nx">instance</span>

<span class="kd">let</span> <span class="nx">originPos</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vector3</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="kd">let</span> <span class="nx">direction</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vector3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="kd">let</span> <span class="nx">ray</span><span class="p">:</span> <span class="nx">Ray</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">origin</span><span class="p">:</span> <span class="nx">originPos</span><span class="p">,</span>
  <span class="na">direction</span><span class="p">:</span> <span class="nx">direction</span><span class="p">,</span>
  <span class="na">distance</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
<span class="p">}</span>

<span class="nx">physicsCast</span><span class="p">.</span><span class="nx">hitFirst</span><span class="p">(</span>
  <span class="nx">ray</span><span class="p">,</span>
  <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">entity</span><span class="p">.</span><span class="nx">entityId</span><span class="p">)</span>
  <span class="p">},</span>
  <span class="mi">0</span>
<span class="p">)</span>
</code></pre></div></div>

<p>This sample queries for all entities hit by the ray:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">physicsCast</span> <span class="o">=</span> <span class="nx">PhysicsCast</span><span class="p">.</span><span class="nx">instance</span>

<span class="kd">let</span> <span class="nx">originPos</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vector3</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="kd">let</span> <span class="nx">direction</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vector3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="kd">let</span> <span class="nx">ray</span><span class="p">:</span> <span class="nx">Ray</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">origin</span><span class="p">:</span> <span class="nx">originPos</span><span class="p">,</span>
  <span class="na">direction</span><span class="p">:</span> <span class="nx">direction</span><span class="p">,</span>
  <span class="na">distance</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
<span class="p">}</span>

<span class="nx">physicsCast</span><span class="p">.</span><span class="nx">hitAll</span><span class="p">(</span>
  <span class="nx">ray</span><span class="p">,</span>
  <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">entityHit</span> <span class="k">of</span> <span class="nx">e</span><span class="p">.</span><span class="nx">entities</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">log</span><span class="p">(</span><span class="nx">entityHit</span><span class="p">.</span><span class="nx">entity</span><span class="p">.</span><span class="nx">entityId</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="mi">0</span>
<span class="p">)</span>
</code></pre></div></div>

<h2 id="results-from-raycast-query">Results from raycast query</h2>

<p>After running a raycast query, the callback function will be able to use the following information from the event object:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">didHit</code>: <em>boolean</em> that is <em>true</em> if at least one entity was hit, <em>false</em> if there were none.</li>
  <li><code class="language-plaintext highlighter-rouge">ray</code>: <em>Ray</em> that has been used in the query</li>
  <li><code class="language-plaintext highlighter-rouge">hitPoint</code>: <em>Vector3</em> for the point in scene space where the hit occurred. If multiple entities were hit, it returns the first point of ray collision.</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">hitNormal</code>: <em>Vector3</em> for the normal of the hit in world space. If multiple entities did hit, it returns the normal of the first point of ray collision.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">entity</code>: <em>Object</em> with info about the entity that was hit. This is returned when using <code class="language-plaintext highlighter-rouge">hitFirst()</code>, and it’s only returned if there were any entities hit.</li>
  <li><code class="language-plaintext highlighter-rouge">entities</code> : <em>Array of <code class="language-plaintext highlighter-rouge">entity</code> objects</em>, each with info about the entities that were hit. This is returned when using <code class="language-plaintext highlighter-rouge">hitAll()</code>, and it’s only returned if there were any entities hit.</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">entity</code> object, and the objects in the <code class="language-plaintext highlighter-rouge">entities</code> array contain the following data:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">entityId</code>: <em>String</em> with the id for the hit entity</li>
  <li><code class="language-plaintext highlighter-rouge">meshName</code>: <em>String</em> with the internal name of the specific mesh in the 3D model that was hit. This is useful when a 3D model is composed of multiple meshes.</li>
</ul>

<p>The example below shows how you can access these properties from the event object in the callback function:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">physicsCast</span> <span class="o">=</span> <span class="nx">PhysicsCast</span><span class="p">.</span><span class="nx">instance</span>

<span class="kd">let</span> <span class="nx">originPos</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vector3</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="kd">let</span> <span class="nx">direction</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vector3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="kd">let</span> <span class="nx">ray</span><span class="p">:</span> <span class="nx">Ray</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">origin</span><span class="p">:</span> <span class="nx">originPos</span><span class="p">,</span>
  <span class="na">direction</span><span class="p">:</span> <span class="nx">direction</span><span class="p">,</span>
  <span class="na">distance</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
<span class="p">}</span>

<span class="nx">physicsCast</span><span class="p">.</span><span class="nx">hitFirst</span><span class="p">(</span>
  <span class="nx">ray</span><span class="p">,</span>
  <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">didHit</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">engine</span><span class="p">.</span><span class="nx">entities</span><span class="p">[</span><span class="nx">e</span><span class="p">.</span><span class="nx">entity</span><span class="p">.</span><span class="nx">entityId</span><span class="p">].</span><span class="nx">addComponentOrReplace</span><span class="p">(</span><span class="nx">hitMaterial</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="mi">0</span>
<span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p>Tip: To reference an entity based on its ID, use the engine’s <code class="language-plaintext highlighter-rouge">entities</code> array, like this: <code class="language-plaintext highlighter-rouge">engine.entities[e.entity.entityId]</code>.</p>
</blockquote>

<p>The example below does the same, but dealing with an array of entities returned from the <code class="language-plaintext highlighter-rouge">hitAll()</code> function:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">physicsCast</span> <span class="o">=</span> <span class="nx">PhysicsCast</span><span class="p">.</span><span class="nx">instance</span>

<span class="kd">let</span> <span class="nx">originPos</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vector3</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="kd">let</span> <span class="nx">direction</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vector3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="kd">let</span> <span class="nx">ray</span><span class="p">:</span> <span class="nx">Ray</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">origin</span><span class="p">:</span> <span class="nx">originPos</span><span class="p">,</span>
  <span class="na">direction</span><span class="p">:</span> <span class="nx">direction</span><span class="p">,</span>
  <span class="na">distance</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
<span class="p">}</span>

<span class="nx">physicsCast</span><span class="p">.</span><span class="nx">hitAll</span><span class="p">(</span>
  <span class="nx">ray</span><span class="p">,</span>
  <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">didHit</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">entityHit</span> <span class="k">of</span> <span class="nx">e</span><span class="p">.</span><span class="nx">entities</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">engine</span><span class="p">.</span><span class="nx">entities</span><span class="p">[</span><span class="nx">entityHit</span><span class="p">.</span><span class="nx">entity</span><span class="p">.</span><span class="nx">entityId</span><span class="p">].</span><span class="nx">addComponentOrReplace</span><span class="p">(</span>
          <span class="nx">hitMaterial</span>
        <span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="mi">0</span>
<span class="p">)</span>
</code></pre></div></div>

<h2 id="recurrent-raycasting">Recurrent raycasting</h2>

<p>If your scene does raycasting on every frame via a <a href="/development-guide/systems/">system</a>, then you should be careful about how it affects your scene’s performance.</p>

<p>Both the <code class="language-plaintext highlighter-rouge">hitAll</code> and <code class="language-plaintext highlighter-rouge">hitFirst</code> methods have a third argument that takes a <em>raycast id</em>. All raycast queries that share a same id are handled in a lossy queue, so that if these requests pile up over time then only the latest one to arrive is processed. This can potentially save a lot of resources and makes your scene run a lot more smoothly.</p>

<p>In some cases you may want to have several separate raycast queries running at the same time, for example you might have a character that sends multiple rays in different directions to check for walls as it walks around. In these cases you should make sure that each raycast query has a separate id. Otherwise, if these different queries share a same id, the results of each might overwrite one another and valuable information will be lost on every frame.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Ray1</span> <span class="o">=</span> <span class="p">{</span> <span class="na">origin</span><span class="p">:</span> <span class="nx">Vector3</span><span class="p">.</span><span class="nx">zero</span><span class="p">,</span> <span class="na">direction</span><span class="p">:</span> <span class="nx">Vector3</span><span class="p">.</span><span class="nx">Left</span><span class="p">()</span> <span class="p">}</span>
<span class="kd">const</span> <span class="nx">Ray2</span> <span class="o">=</span> <span class="p">{</span> <span class="na">origin</span><span class="p">:</span> <span class="nx">Vector3</span><span class="p">.</span><span class="nx">zero</span><span class="p">,</span> <span class="na">direction</span><span class="p">:</span> <span class="nx">Vector3</span><span class="p">.</span><span class="nx">Right</span><span class="p">()</span> <span class="p">}</span>
<span class="kd">let</span> <span class="nx">id1</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">0</span>
<span class="kd">let</span> <span class="nx">id2</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">1</span>

<span class="kd">class</span> <span class="nx">RaycastSystem</span> <span class="k">implements</span> <span class="nx">ISystem</span> <span class="p">{</span>
  <span class="nx">update</span><span class="p">(</span><span class="nx">dt</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">PhysicsCast</span><span class="p">.</span><span class="nx">instance</span><span class="p">().</span><span class="nx">hitFirst</span><span class="p">(</span>
      <span class="nx">Ray1</span><span class="p">,</span>
      <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="c1">// Do stuff</span>
      <span class="p">},</span>
      <span class="nx">id1</span>
    <span class="p">)</span>

    <span class="nx">PhysicsCast</span><span class="p">.</span><span class="nx">instance</span><span class="p">().</span><span class="nx">hitFirst</span><span class="p">(</span>
      <span class="nx">Ray2</span><span class="p">,</span>
      <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="c1">// Do stuff</span>
      <span class="p">},</span>
      <span class="nx">id2</span>
    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">engine</span><span class="p">.</span><span class="nx">addSystem</span><span class="p">(</span><span class="nx">RaycastSystem</span><span class="p">)</span>
</code></pre></div></div>

<p>This example runs two raycast queries on every frame of the scene. Since they each have a different id, the requests from the first query and from the second query are handled on different queues that are independent from the other.</p>

<!--

## Collide with the player

You can't directly hit the player with a ray, but what you can do as a workaround is position an entity occupying the same space as the player

would the entity's colliders bother?
-->

<!--

## Hit avatars


PhysicsCast.hitFirstAvatar( query:RaycastQuery,
			    hitCallback:(e:RaycastHitAvatar) => {} )

PhysicsCast.hitAllAvatars( query:RaycastQuery,
			  hitCallback:(e:RaycastHitAvatars) => {} )


## Cast a sphere


-->
:ET