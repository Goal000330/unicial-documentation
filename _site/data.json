{
  
    
      
        
        
        "blockchain-integration-estates-marketplace-integrations": {
          "id": "blockchain-integration-estates-marketplace-integrations",
          "title": "Integrating Decentraland&apos;s Estate in your Marketplace",
          "categories": "blockchain-integration",
          "url": " /blockchain-integration/estates-marketplace-integrations/",
          "content": "Integrating Decentraland’s Estate in your Marketplace\n\nThe Decentraland’s Estate is an ERC721 compliant NFT and runs in Ethereum Mainnet. Therefore a lot of third party marketplaces can trade them. In order to do so, this marketplace must follow\ncertain rules in order to make keep trades secure for the users.\n\nAs you may know, each Estate is a group of LANDs and it have a bytes hash associated to the group that it call fingerprint. Everytime the Estate changes by adding or removing a LAND, its fingerprint changes too.\n\nFor marketplaces, especially the ones without an escrow system, it is 100% recommended to have a record of the Estate’s fingerprint when someone list it for sale or makes an offer. That way, when the order/offer is successfully executed, the current owner can’t change the estate by trying to front-run the order execution.\n\nExample\n\nNot using the Estate fingerprint\n\n\n  Bob has the Estate1 with LAND (1,1) and (1,2). Estate1 fingerprint: hash1\n  Bob adds the LAND (1,3) to Estate1. The Estate1 has the LANDs: (1,1), (1,2), and (1,3). Estate1 fingerprint: hash2 (Fingerprint changed)\n  Bob removes the LAND (1,1) from Estate1. The Estate1 has the LANDs: (1,2) and (1,3). Estate1 fingerprint: hash3 (Fingerprint changed)\n  Bob puts on sale the Estate1. The list is created onchain in the Ethereum mainnet with the Estate smart contract address, the Estate id, the price, and the expiration date.\n  Alice sends a transaction to buy the Estate specifying the estate id and the price expected to pay.\n  Bob detects that someone is trying to buy his Estate1 and sends a transaction with higher gas fees than Alice to remove the LANDs (1,2) and (1,3) from Estate1.\n  Bob’s transactions is mined first. Estate1 has 0 LANDs. Estate1 fingerprint: hash4 (Fingerprint changed)\n  Alice’s transaction is mined later. Alice bought the Estate1 with 0 LANDs on it. It means that Alice got front-runned (and stolen/scammed) by Bob.\n\n\nUsing the Estate fingerprint\n\n\n  Bob has the Estate1 with LAND (1,1) and (1,2). Estate1 fingerprint: hash1\n  Bob adds the LAND (1,3) to Estate1. The Estate1 has the LANDs: (1,1), (1,2), and (1,3). Estate1 fingerprint: hash2 (Fingerprint changed)\n  Bob removes the LAND (1,1) from Estate1. The Estate1 has the LANDs: (1,2) and (1,3). Estate1 fingerprint: hash3 (Fingerprint changed)\n  Bob puts on sale the Estate1. The list is created onchain in the Ethereum mainnet with the Estate smart contract address, the Estate id, the price, the expiration date.\n  Alice sends a transaction to buy the Estate specifying the estate id, the price expected to pay, and the fingerprint she saw (hash3).\n  Bob detects that someone is trying to buy his Estate1 and sends a transaction with higher gas fees than Alice to remove the LANDs (1,2) and (1,3) from Estate1.\n  Bob’s transactions is mined first. Estate1 has 0 LANDs. Estate1 fingerprint: hash4 (Fingerprint changed)\n  Alice’s transaction is reverted because the smart contract checked that the fingerprint in the param that Alice sent didn’t match with the current Estate1 fingerprint (hash3 != hash4). This check prevented Alice to buy a non desired Estate.\n\n\nEstate Smart Contract Interface\n\nThe Estate’s smart contract is compliant with a fingerprint interface. In order to check if an order/offer for an estate is still valid or not, you can call the verifyFingerprint(uint256 estateId, bytes fingerprint) function implemented in the Estate smart contract. You can check a working production example here"
        }
        
      
    
  
    
      
        ,
        
        "development-guide-workspaces": {
          "id": "development-guide-workspaces",
          "title": "Workspaces",
          "categories": "development-guide",
          "url": " /development-guide/workspaces/",
          "content": "Run multiple Decentraland projects in preview by grouping these into a workspace. Run multiple adjacent scenes to see how they fit, or also run multiple smart wearables together to see how they interact with each other and with different scenes.\n\nRunning multiple projects in a workspace provides a much more complete testing alternative, to ensure different content works well together.\n\nCreate a workspace\n\n\n  \n    Create a top-level folder to hold the workspace.\n  \n  \n    Inside this folder, add one folder at root level for each project you want to work with. You can drag in existing folders with scenes or smart wearables. For new folders, run dcl init inside each, to create a Decentraland project.\n\n    \n      Note: Make sure that the parcels on each of the scenes don’t overlap.\n    \n  \n  \n    Standing on the workspace folder, run the following, to create the necessary files:\n\n    dcl workspace init\n  \n\n\nYou can confirm that the projects are part of the workspace by running dcl workspace ls.\n\nRun a workspace\n\nRun dcl start on the root folder of the workspace. This runs all of the projects at the same time, viewable in a single preview window. This preview behaves just like when previewing a single scene.\n\nAny smart wearables in the workspace are available to try on by looking for them in the backpack.\n\nAdd projects\n\nOnce a workspace is created, you can add additional projects dcl workspace add, including the relative address of the folder you want to add. For example dcl workspace add my-other-example.\n\nYou can also add a project that is not inside the workspace folder, by using the absolute path.\n\n\n  Note: The folder must already contain a decentraland project initatied with dcl init. It can’t be an empty folder.\n\n\nYou can also edit the dcl-workspace.json file manually to add or remove projects. Modify the file to include the relative paths to each of the projects in the workspace in the folders array.\n\n{\n  \"folders\": [\n    {\n      \"path\": \"example-scene\"\n    },\n    {\n      \"path\": \"example-scene2\"\n    }\n  ]\n}"
        }
        
      
    
  
    
      
        ,
        
        "development-guide-smart-wearables": {
          "id": "development-guide-smart-wearables",
          "title": "Smart Wearables",
          "categories": "development-guide",
          "url": " /development-guide/smart-wearables/",
          "content": "Smart wearables are a type of portable experience. Portable experiences are parts of the gameplay that players take with them as they move through the metaverse. For example, a player could take a snowball from your scene, walk away to another scene, and throw the snowball to another player who’s also playing the same game.\n\nSmart wearables are portable experiences that are turned on when the player puts on a certain item of clothing. Smart wearables can grant players new abilities, like a jetpack that lets them fly, or add a new layer of content on top of the rest of the world, like randomly placing coins to be collected throughout the whole of genesis city.\n\nGetting started\n\nTo create a new smart wearable\n\n\n  Make sure you have the latest version of the CLI installed\n\n\nnpm i -g decentraland@latest\n\n\n  Open a command line in a new folder and run\n\n\ndcl init\n\nWhen prompted by the command, select smart wearable (beta)\n\nThis command creates the basic files and structure for a new smart wearable. This folder is very similar to that of a Decentraland scene, but you will notice the following differences:\n\n\n  asset.json includes all of the metadata for the portable experience\n  There’s a placeholder 3d model (glasses.glb) and thumbnail (glasses.png) for a pair of dark glasses. You should replace these with the actual wearable you want to use\n  scene.json is a lot shorter, it doesn’t include properties that are irrelevant to a wearable, like parcels or spawn points\n\n\nAbout Asset.json\n\nThe default asset.json file looks like this:\n\n{\n  \"id\": &lt;random-id&gt;,\n  \"assetType\": \"portable-experience\",\n  \"name\": \"Portable Experience Example\",\n  \"description\": \"My new Portable Experience\",\n  \"category\": \"eyewear\",\n  \"rarity\": \"mythic\",\n  \"thumbnail\": \"glasses.png\",\n  \"menuBarIcon\": \"glasses.png\",\n  \"model\": \"glasses.glb\",\n  \"bodyShape\": \"both\"\n}\n\n\nThe following fields are present in asset.json:\n\n\n  id: The dcl init command generates a random value for this ID.\n\n\n\n  NOTE: If you forked your project from an existing one, make sure the ID value is unique before publishing your wearable. Use uuidgenerator.net to generate a new random UUID\n\n\n\n  assetType: This field is required for the preview to identify this project as a portable experience.\n  name: The name for the wearable that users will see in the marketplace\n  description: The description of the wearable that users will see in the marketplace. Make sure you indicate what the smart wearable can do, as users of the marketplace will have no way to preview its functinality before buying it.\n  \n    category: What wearable category to use. Possible values are:\n\n    \n      \n        ‘eyebrows’\n      \n      \n        ‘eyes’\n      \n      \n        ‘facial_hair’\n      \n      \n        ‘hair’\n      \n      \n        ‘mouth’\n      \n      \n        ‘upper_body’\n      \n      \n        ‘lower_body’\n      \n      \n        ‘feet’\n      \n      \n        ‘earring’\n      \n      \n        ‘eyewear’\n      \n      \n        ‘hat’\n      \n      \n        ‘helmet’\n      \n      \n        ‘mask’\n      \n      \n        ‘tiara’\n      \n      \n        ‘top_head’\n      \n      \n        ‘skin’\n      \n    \n  \n  rarity: The rarity supply of the token. Possible values are:\n    \n      unique (1 copy)\n      mythic (10 copies)\n      legendary (100 copies)\n      epic (1000 copies)\n      uncommon (10.000 copies)\n      common (100.000 copies)\n    \n  \n  thumbnail: Image to use as thumbnail for the wearable, both in the backpack and the marketplace. This image should be at root level in your folder. The recommended image size is 256x256.\n  menuBarIcon: Image to use on the “experiences” menu, to represent this portable experience, to represent the portable experience. This image should be at root level in your folder. The recommended image size is 256x256.\n  model: The 3d model to use for the wearable. This file should be at root level in your folder.\n  bodyShape: The avatar body type that this wearable is compatible with. Possible values:\n    \n      male\n      female\n      both\n    \n  \n\n\nThe Preview\n\nRunning a preview of a portable experience is just like running that of a scene, simply run dcl start. If the asset.json file is properly configured and the project is recognized as a portable experience, you’ll notice that all the visible around you are the default empty parcels. In this preview mode, you are not restricted to any set of parcels, you can add 3d models or sounds anywhere in the world.\n\nTips\n\n\n  When positioning an entity, note that positions are global, relative to the 0,0 coordinates of Genesis Plaza.\n  To react to nearby players:\n    \n      use getConnectedPlayers() to know what players are already there, and onPlayerConnectedObservable / `onPlayerDisconnectedObservable to track other players coming and going.\n      Be mindful that the loading of the smart wearable, surrounding scenes and other players may occur in different orders depending on the situation. If the player enters Decentraland with the smart wearable already on, it’s likely that your portable experience will load before other players do. On the other hand, tf the player first loads into a scene and then puts on the wearable, it’s likely that other players will already be loaded by the time the portable experience starts running.\n      Wait till the player is connected to an island inside their realm. Fetch the realm data and check for the ‘room’ field. If the ‘room’ field is null, the player is not yet connected to an island and other players won’t be loaded yet. You can periodically check this every 1 second till the ‘room’ field is present, and only initialize your logic then.\n    \n  \n  To interact with surrounding scenes:\n    \n      You can’t directly send any instructions to nearby scenes or other portable experiences, the messageBus is currently sandboxed for each portable experience/scene.\n      You can use an intermediate server to send information between the portable experience and a scene.\n      If you do a raycast, you can detect hits against the colliders of entities from the surrounding scenes. This can tell you the exact hit location, normal direction, and even the entity name and mesh name of the 3d model.\n    \n  \n  Kill a portable experience: Run the kill() method to self-terminate a portable experience.\n\n\nPublish\n\nTo publish your smart wearable:\n\n\n  \n    Make sure the information in asset.json is accurate. If you used another project as a starting point, make sure the id is a unique identifier, not used by other wearables.\n  \n  \n    Run dcl pack on your project folder. This generates a portable-experience.zip file in your project folder.\n  \n\n\n\n  NOTE: The output of dcl pack will indicate the size of the uncompressed exported project, it must be under 2MB. If larger than that, it won’t be accepted by the builder.\n\n\n\n  \n    Open the Builder, open the Collections tab, click + to upload a new wearable.\n  \n  \n    Drag your compressed portable-expereince.zip file into the Builder, verify that all the information is accurate.\n  \n\n\n\n  Note: If your wearable is an upper_body or a lower_body and meant to be unisex, you need to do a workaround (even if both body shapes use the same model):\n\n\n- Select only Male and complete the process\n- Open the wearables in the editor, click the three dot options button, select “upload female representation”, and upload the 3d model for the female shape.\n\n\n\n  Open the editor and make sure the “hide” and “remove” categories are correctly set to disable other wearable categories when this wearable is on.\n  Create a new collection with this and perhaps other wearables.\n  Hit the 3 dots icon next to “Mint Items” and select “See in world”. This will open a tab with the explorer on ropsten, where you can try out all the wearables of your collection in Decentraland, and see how they behave in a more real scenario, for example running around Genesis Plaza.\n  At this point, your wearable is ready to be published. We still don’t encourage creators to publish any smart wearables, as we’re still in experimental stages, reviewers from the committee have been instructed to not approve any smart wearables that don’t come from the foundation.\n\n\n\n  Note: There will be a dcl deploy command in the future, to enable you to do this process without navigating the Builder UI.\n\n\n\n\nLimitations\n\n\n  IMPORTANT: The entire smart wearable needs to fit within 2 MB. This includes the 3d model, thumbnail, code, libraries, sound files, additional 3d models, UI images, etc. This limit is for the uncompressed folder. The builder will not let you upload larger wearables than this.\nTo check the size of your portable experience, run dcl pack, the project size is specified in the output text of the command. You can also verify this by uncompressing the generated portable-expereince.zip file.\n\n\nSmart wearables only run the portable experience for the player wearing the wearable. Other players don’t see the effects. For example, if the portable experience renders a pet that follows the player, other players around won’t see this pet.\n\nSmart wearables only work when players have them on. For this reason, players can only have a limited number of activated smart wearables, and depending on what part of the body they take up, some will be incompatible with others. For example, you can’t have two hats at the same time, or a helmet and hair at the same time.\n\nIf a wearable is “hidden” but not “removed” by other wearables being worn, then the portable experience can still be on, even if the corresponding wearable is not visible.\n\nExamples\n\nPortal-ble expoerence\n\nGraffiti\n\nRadio\n\nRaycast test\n\nRealms test\n\nRocket board\n\nScarvenger hunt\n\nXmas 2021:\n\nXmas airdrops\n\nSnowball fight\n\nSecret Santa"
        }
        
      
    
  
    
      
        ,
        
        "decentraland-requesting-grants": {
          "id": "decentraland-requesting-grants",
          "title": "Requesting Grants",
          "categories": "Decentraland",
          "url": " /decentraland/requesting-grants/",
          "content": "To request a grant from the Decentraland DAO, begin by navigating to governance.decentraland.org and signing in with your wallet.\n\nClick Submit a proposal and choose Grant request from the list of proposal categories. You will be presented with a form that you must complete before submitting your request.\n\nGrant proposal forms\n\nWhen you submit a grant request, you are expected to complete the proposal form to the best of your ability. Particular attention should be given to the abstract, description, specification, personnel, and roadmap sections. Failure to provide clear and relevant information may result in the rejection of your proposal by the community.\n\nFollowing is an overview of the proposal form:\n\nCategory\n\nSelect the category that best describes your project. Currency, DAO grants will fund projects within four categories:\n\n\n  Community\n  Content Creator\n  Platform Contributor\n  Gaming\n\n\nTier\n\nSelect the most appropriate tier for your grant request. Tiers enable the Decentraland Community to limit the size and scope of the grants that are funded by the DAO. The initial possible tiers are:\n\n\n  Tier 1: $500 - $1500 USD in MANA\n  Tier 2: $1500 - $3000 USD in MANA\n  Tier 3: $3000 - $5000 USD in MANA\n\n\nTiers 1 and 2 are paid via a direct transfer to the beneficiary address provided within 7 days of a grant receiving approval from the DAO.\n\nTier 3 is paid via a vesting contract with a one month cliff.\n\nTitle\n\nProvide a title that is concise and descriptive for your grant request. This title will appear as the header of your proposal’s detail page on governance.decentraland.org, the proposal in Snapshot, and the Forum thread generated for your proposal.\n\nAbstract\n\nUse this space to provide a quick and easy to understand overview of your project. Your abstract should explain what problems your grant might solve, or what value it might provide to the greater community.\n\nGrant size\n\nEnter the exact amount of funding you are requesting for your grant in USD. This amount should be within range for the Tier you’ve selected. If your grant is approved, it will be paid in MANA according to the current exchange rate between USD and MANA.\n\nBeneficiary address\n\nEnter an Ethereum address that you can use to receive the funds if your grant is approved.\n\nDescription\n\nThis is where you can provide a longer and more detailed description of your project.\n\nSpecification\n\nHere you can share a more detailed plan for what you would like to create or build. If there are any supporting assets or preliminary work, please share them here.\n\nPersonnel\n\nIf you are the only contributor to the project you would like to fund, enter some biographical information, making sure to include an overview of your skills and experience and why they are uniquely suited for your project. You are also strongly encouraged to provide links to a portfolio of previous work that is relevant to your proposed project.\n\nIf multiple people would contribute to your project, please share these details for each.\n\nRoadmap and milestones\n\nPlease share a realistic and achievable timeline for your project with discrete milestones. It is important that you publicly share progress toward each milestone in the Forum thread generated for your grant. Milestones should include concrete deliverables and dates, to make it easy for the community to compare your actual progress with your initial proposal.\n\nSubmitting your proposal\n\nAfter filling out every field in the proposal form to the best of your abilities, click Submit proposal.\n\nAfter submitting your proposal, a Forum thread will be generated automatically where the community can provide feedback on, or ask questions about, your project.\n\nGrant requests remain open on the DAO for 7 days, during which the community can review and vote on your proposal.\n\nMinimum acceptance thresholds\n\nAs has been voted in place by the DAO, grant requests cannot be approved by the DAO unless 1 million VP or more votes in For the request and the For votes have the majority.\n\nFailure to reach at least 1 million VP, even if the For votes are in the majority, results in the rejection of the proposal. Grant requests may be resubmitted, so if you fail to obtain approval, you may revise and resubmit your proposal at a later date."
        }
        
      
    
  
    
      
        ,
        
        "decentraland-receiving-grants": {
          "id": "decentraland-receiving-grants",
          "title": "Receiving Grants",
          "categories": "Decentraland",
          "url": " /decentraland/receiving-grants/",
          "content": "If your grant request was approved by the DAO, congratulations! Following is an overview of what happens when your grant is approved, the actions you need to take to receive your funding, and how you are expected to report your work to the community.\n\nReceiving your MANA\n\nThe process for receiving funds varies between the different grant tiers.\n\nTier 1 and Tier 2\n\nFunds for grants in Tiers 1 and 2 are paid directly to the beneficiary address provided in the proposal form.\n\nThese transfers are initiated by the DAO Committee within 7 days of the grant’s approval by the DAO.\n\nThe funds are transferred in MANA equaling the USD amount specified in the grant proposal, according to the exchange rate at the time the transfer is initiated.\n\nThe beneficiary address provided within the grant proposal must be an Ethereum address that can receive MANA. Failure to provide a valid address may result in the irretrievable loss of the grant funds.\n\nTier 3\n\nFunds for grants in Tier 3 are made available to the beneficiary address provided in the proposal form via a vesting contract. It is the responsibility of the beneficiary to withdraw any vested funds from the contract.\n\nMANA in vesting contracts vests each second.\n\nVesting contracts have a one month cliff. MANA will still vest during this cliff, but it will not be available to the beneficiary until the end of the cliff.\n\nAfter the cliff has been reached, the beneficiary may withdraw their vested funds as often as they wish, bearing in mind that they (the beneficiary) are responsible for paying the gas fee required for each withdrawal.\n\nReporting your progress\n\nYou are expected to provide public reports on your progress on a schedule matching the milestones and roadmap detailed in your original grant proposal.\n\nThese updates are to be shared on the Forum thread generated for your grant request. These progress reports should be clear and concise, while still giving the community an accurate sense of how your project is progressing. Sharing screenshots or demos of your work goes a long way toward maintaining the trust of the community.\n\nRevoked grants\n\nCurrently, only grants with vesting contracts may be revoked. Conditions or behaviors that might lead to a grant being revoked include:\n\n\n  Failure to provide progress reports according to the roadmap and milestones listed in your grant proposal\n  Providing progress reports showing work that does not meet the expectations set by your original grant proposal\n  Providing work that violates either the Content Policy, Terms of Use, or Code of Ethics\n\n\nWhat happens if your grant is revoked?\n\nIf your grant is revoked before the end of your vesting contract’s cliff, then you will not receive any of your grant funds.\n\nIf your grant is revoked after the end of your contract’s cliff, then you will still be able to withdraw any funds that have already vested."
        }
        
      
    
  
    
      
        ,
        
        "decentraland-community-grants": {
          "id": "decentraland-community-grants",
          "title": "Community Grants",
          "categories": "Decentraland",
          "url": " /decentraland/community-grants/",
          "content": "The Decentraland DAO possesses a MANA fund that has been set aside to help sponsor and facilitate the continual growth of the Decentraland platform. One avenue used by the DAO to achieve these goals is a grants program that was voted in place by the DAO.\n\nThis grants program allows any member of the community to request funding to help reimburse their efforts in community building and education, creating 3D content for the world, or implementing new features and improvements to the platform.\n\nGrants can be requested by completing a proposal form within the DAO. If approved by the community, then the DAO Committee will execute the transfer of funds to the grant beneficiary by means of a one-time transfer, or a vesting contract.\n\nGrant categories\n\nGrant requests can fall under one of four broad categories: Community, Content Creator, Platform Contributor, or Gaming. These four categories represent areas of Decentraland that benefit most from community contributions.\n\nCommunity\n\nGrowing, educating, moderating, and maintaining a healthy community of players, creators, and developers is important to Decentraland’s success. Grants under this category may fund activity such as:\n\n\n  Community education\n  Outreach and event organization\n  Moderation\n\n\nProjects might also include creating documentation, tutorials, videos, or other forms of content intended to educate and support the community.\n\nContent Creator\n\nFilling the metaverse with engaging and immersive content takes time and effort from skilled, independent technical artists. Grants in this category help to support artists to create scenes and models for Decentraland. Applicants to this category must provide portfolios of related work within their grant requests for the community to review.\n\nPlatform Contributor\n\nDecentraland is an open source platform with many moving parts. Grants within the Builder category should motivate and reward impactful contributions from developers and engineers in the form of:\n\n\n  New features\n  Bug or vulnerability fixes\n  Other improvements to existing code\n\n\nGaming\n\nEngaging experiences in Decentraland often take the form of games, especially multiplayer games. This category bridges the Creator and Platform Contributor categories by funding individuals and teams committed to building complete games for Decentraland.\n\nGrant tiers\n\nGrants may be requested for any amount within one of three possible tiers, regardless of the grant category. For example, you may request a Content Creator grant in either Tier 1, Tier 2, or Tier 3.\n\nThe specific tiers, and their ranges, are:\n\nTier 1\n\n\n  $500 - $1500 USD in MANA\n  One-time payment\n\n\nTier 2\n\n\n  $1500 - $3000 USD in MANA\n  One-time payment\n\n\nTier 3\n\n\n  $3000 - $5000 USD in MANA\n  Up to a 3 month vesting contract with a one month cliff\n\n\nWhen are payments made for each tier?\n\nTier 1 and Tier 2\n\nFunds for grants in Tiers 1 or 2 are transferred directly to the beneficiary address within a week of the grant’s approval from the DAO.\n\nTier 3\n\nFunds for grants in Tier 3 are made available to the beneficiary address via vesting contracts. These contracts vest every second, and have a one month cliff. After the cliff, the owner of the beneficiary address may withdraw the vested MANA. Past the cliff, the beneficiary may withdraw any newly vested MANA.\n\nGrant requirements\n\n\n  Any work funded by the DAO must comply with the Decentraland Content Policy, Terms of Use, and Code of Ethics.\n  Regardless of category, each grant proposal must include clearly defined and measurable outcomes.\n  Grant recipients must provide regular and thorough reports on their project’s progress for the community to review. These reports may be shared through the Decentraland Forum. Failure to provide these reports may result in the removal of grant funding.\n  Failure to provide the pre-established outcomes, as well as to provide clear reports on the advances and milestones will result in the removal of the grant funding.\n  Grants with one-time payments are to be transferred upon the DAO’s approval of the grant.\n  Grants with vesting contracts have a one month cliff beginning 7 days after the grant’s approval in the DAO."
        }
        
      
    
  
    
      
        ,
        
        "decentraland-wearables-overview": {
          "id": "decentraland-wearables-overview",
          "title": "Wearables Overview",
          "categories": "Decentraland",
          "url": " /decentraland/wearables-overview/",
          "content": "Wearables are the various items of clothing, accessories, and body features that can be used to customize the appearance of a Decentraland avatar. There is a selection of default wearables that are freely available to all avatars, but Decentraland also supports the creation and use of custom wearables that are represented by non-fungible tokens (or NFTs). This allows a finite amount of different wearables to be created, or minted, on the blockchain, similar to the LAND.\n\nBy default, Decentraland Wearables are minted on the Polygon/Matic sidechain so users can mint, buy, sell, or transfer items without having to pay gas fees.\n\nWearables are organized into different categories, depending on what part of an avatar they modify:\n\n\n  Body shape (the shape of the entire avatar)\n  Hat\n  Helmet\n  Hair\n  Facial hair\n  Head\n  Upper body (e.g. jacket or shirt)\n  Lower body (e.g. pants or shorts)\n  Feet\n  Skin\n\n\nWearables can also include accessories that are applied to different parts of an avatar’s body:\n\n\n  Mask\n  Eye wear\n  Earring\n  Tiara (a crown, or other accessory that sits on top of the head)\n  Top-head (e.g. a halo, or other effect applied to the head)\n\n\nFor a detailed description of each category, and how items within each category interact or replace one another, see Creating Wearables.\n\nCollections &amp; Items\n\nWearables exist as individual items that can be grouped into collections.\n\nItems\n\nRemember how wearables are represented by non-fungible tokens (NFTs)? Well, each wearable item can be minted to create multiple NFTs of that same item, to a limit according to the item’s rarity (the rarer the item, the fewer NFTs you can mint). Items are often referred to as the “representations” of the wearable.\n\nItems cannot be bought or sold, only the NFTs that have been minted from items. Also, individual items cannot be published on their own; they must be part of a collection.\n\nCollections\n\nCollections exist to help creators organize and manage their items before publication.\n\nFor example, let’s say we create a blue t-shirt and a red t-shirt. We can create a new collection called “Summer T-Shirts”, and then add our two shirts to that collection. After publishing our collection, we can then mint copies of the red and blue shirts to share, trade, or sell.\n\nThe following documentation only covers the Wearables Editor: the tool used to upload, add metadata to, and publish custom items and collections of items.\n\nFor documentation covering other aspects of wearables, see the following resources:\n\n\n  Creating Wearables\n  Publishing Wearables\n  Curation Committee\n  Editor User Guide\n\n\nThe following shared folder contains example wearables, base models, textures and other resources you can use:\n\n\n  Wearables Reference Models"
        }
        
      
    
  
    
      
        ,
        
        "decentraland-wearables-editor-user-guide": {
          "id": "decentraland-wearables-editor-user-guide",
          "title": "Wearables Editor User Guide",
          "categories": "Decentraland",
          "url": " /decentraland/wearables-editor-user-guide/",
          "content": "What is the Wearables Editor?\n\nThe Wearables Editor is a tool within Decentraland’s Builder that allows you to upload, add metadata to, and publish your own custom wearables.\n\n\n  Remember: these docs don’t explain how to create the models, meshes, and textures that make up wearables, they just explain how to use the Wearables Editor to upload and publish your wearables. For an intro on the actual wearable creation process, start here.\n\n\nLogging in\n\nTo start uploading and publishing your wearables, navigate to builder.decentraland.org.\n\nClick Sign in, and then Connect to log in with your Metamask or Fortmatic wallet. After signing in, click the Collections tab.\n\nUploading wearables\n\nIf you haven’t uploaded any items yet, click New Item or New Collection to get started. If you’ve already uploaded some wearables, you can either edit them by clicking on the item or collection and then clicking Edit, or you can upload new wearables by clicking the + icon next to the Open Editor button.\n\nCreating a collection\n\nWhen creating a collection, first enter the name you would like to give your collection and click Create. After creating your collection, you can begin adding items.\n\n\n  The name of your collection cannot be changed after publication!\n\n\nYou can add as many items as you want until you publish your collection. Always remember, you cannot add, remove, or change the rarity of items in published collections.\n\nTo add an item to your new collection, select the collection, click New Item, and select your wearable files.\n\nUploading an item\n\nWhen uploading an item you can either browse your computer to find the file you want, or you can click and drag your file right into the editor. For an overview of the 3D file types supported in Decentraland, see 3D Model Essentials.\n\n\n  Wearable items cannot currently exceed 2MB.\n\n\nAfter uploading your file, you will be prompted to enter some descriptive information:\n\nBody shape\nYou can select which body shape your wearable is modeled for. The shape can be either A, B, or both. Wearables that are set to Shape A can only be worn by wearables with Body Shape A, while wearables set to Shape B can only be worn by avatars with Body Shape B. If you set the shape to Both, then avatars of both shapes can wear your wearable.\n\nName\nThe name you would like to give your wearable.\n\n\n  The name of your collection cannot be changed after publication!\n\n\nRarity\nThe rarity of your wearable determines the total number of NFTs that may be minted based on your item. The rarities and the maximum number of NFTs that you may mint for each are:\n\n\n  \n    \n      Rarity\n      Limit\n    \n  \n  \n    \n      Unique\n      1\n    \n    \n      Mythic\n      10\n    \n    \n      Legendary\n      100\n    \n    \n      Epic\n      1000\n    \n    \n      Rare\n      5000\n    \n    \n      Uncommon\n      10000\n    \n    \n      Common\n      100000\n    \n  \n\n\n \n\nCategory\nWearables are organized into different categories, depending on what part of an avatar they modify. Select the appropriate category for your item:\n\n\n  Earring\n  Eyewear\n  Facial Hair\n  Feet\n  Hair\n  Hat\n  Helmet\n  Lower Body\n  Mask\n  Upper Body\n  Tiaras\n  Top Head (Top Head wearables can be either an item of effect that is applied to the top of the head, like an angel’s halo.)\n  Skin\n\n\nWhen you’re finished entering your descriptive metadata, click Create.\n\nEditing items\n\nTo edit your items, navigate to the Builder and select the Collections tab. Here, you’ll find all of your wearable collections and items. You can edit an individual item by clicking on the item, and then clicking Edit. To edit an item that is part of a collection, first select the collection, and then the item within the collection you’d like to edit.\n\nDetails\n\nThe item details list the number of triangles, materials, and textures that make up your wearable. It is recommended that you do not exceed the following limits when creating wearables:\n\n\n  1500 triangles per wearable (except skin category)\n  500 triangles per accessory\n  2 square textures of 512x512px (or lower)\n  5k triangles for skin category and 5 textures of 512x512px (or lower).\n\n\nIf the number of triangles and textures exceeds these guidelines, you can click the pencil icon to upload a new model, or “representation” of your wearable with lower triangle/texture counts. You can also change the preview image by clicking the camera icon when hovering over the preview thumbnail.\n\nBasics\n\nThis is the basic metadata you entered when you first uploaded your item. You can edit this information at any time leading up to the moment you publish your item within a collection.\n\n\n  Name - the name of your item, this will be displayed when distributing your wearable on the marketplace\n  Description - a brief statement describing your item, this is displayed when distributing your wearable on the marketplace\n  Category - the component of an avatar’s body that your wearable modifies\n  Rarity - the rarity determines the maximum number of NFTs you will be able to mint of your wearable after publication. This is the only property that cannot be modified after publishing a collection.\n\n\nOverrides\n\nOverrides determine what other wearable categories your item will either replace, or hide. When setting overrides, you simply select a wearable category from the dropdown menu to add it to the override. You can add multiple categories to each override.\n\nReplaces\nAny items within the categories added to this override will be unequipped from a users’ avatar when they equip your item. A user would have to re-equip any “replaced” items after unequipping your item. This does not delete items, it only unequips them.\n\nHides\nAny items within the categories added to this override will only be hidden (they won’t be rendered) when a user equips your item. When a user unequips your item, the hidden items will be rendered again automatically.\n\nTags\n\nTags are simply descriptive words that users can use when searching or filtering for items. These could be relevant to competitions or events!\n\nCustom thumbnails\n\nYou can upload your own custom thumbnails for wearables in your collections. To upload a custom thumbnail image, navigate to the Wearables Editor and open the item you want to add a thumbnail for. Click Edit and then click on the thumbnail image under details to upload an image from your computer (a camera icon will appear when you hover over the thumbnail).\n\n\n  Thumbnails must be 256px by 256px with transparent backgrounds. Collections containing thumbnails without transparent backgrounds will not be accepted by the Curation Committee.\n\n\nSetting the price for items\n\nItems that are included in a collection can include prices that you set for their primary sale.\n\nTo set the price of a wearable, navigate to the Builder and select the Collections tab. Then click on the collection containing your items you want to price.\n\nFor each item in the list, click Set Price.\n\nPrice\n\nThe price that a user will have to pay in a primary purchase (the first purchase after minting) for your item. Prices are set in MANA. Remember that when you mint wearables, they are minted directly on Matic/Polygon. When a user purchases your item, the transaction will be conducted in Matic/Polygon MANA.\n\nBeneficiary\n\nThe Ethereum address that will receive the MANA in a primary sale of your wearable. You can use any Ethereum address you like. To automatically fill in the address you’ve logged in with, click I’m the Beneficiary.\n\nYou can also click Make it Free, to set the price to 0 MANA and the beneficiary address to a null address. This means that your wearable will be free for the primary sale, but it could be sold for a price in any secondary sale.\n\nAfter setting the price and beneficiary address, click Submit.\n\nPublishing items\n\n\n  The DAO is currently voting on the addition of publication fees for wearables. Until the addition of a fee is decied on, and the size of that fee is determined, users will not be able to publish their wearables. For more information, and to participate in the discussion, visit governance.decentraland.org.\n\n\nAfter you’ve added all of the relevant metadata to the wearables in your collection, and you’ve set the price and beneficiary address (or made your items free!) you can begin the publication process.\n\nFirst, navigate to the Builder and select the Collections tab. Select the collection you’d like to publish and click Publish.\n\nYou might have to authorize the MANA contract to operate MANA on your behalf. By granting this authorization, you are permitting the MANA smart contract to withdraw MANA from your balance to pay the publication fee and to deposit MANA into your account from future sales of your items. Simply check MANA and click Proceed. You will have to sign a message from your wallet, but there is no gas fee.\n\nPublication fees\n\nThere is a required fee for publishing items. This fee exists to deter users from publishing an excessive number of wearables in an attempt to “spam” the wearables market.\n\nThe fee is a flat rate of 500 MANA per item (not NFT!) in your collection.\n\nFor example, if you publish a collection with two items, you will have to pay a fee of 1000 MANA (500 MANA for each item) regardless of the rarity (or how many NFTs can be minted) of those items.\n\nThese fees are transferred to the Decentraland DAO, where they are used to help fund the growth of the platform through grants and other initiatives voted on by the greater Decentraland community.\n\nCurrently, due to the time and resources required to review each collection submitted, the 500 MANA publication fee is non-refundable. If your collection is rejected, you will not receive your 500 MANA back.\n\nAfter reviewing your total fee, click Next.\n\n\n  Warning!\nYou will not be able to add or remove items in your collection after beginning the publication process. You will be able to see your items within the Decentraland Marketplace, but they will not be able to be bought, sold, or transferred until they have been approved.\n\n\nFor more detailed information on the publication and approval process, see Publishing Wearables.\n\nWhen you are ready, click Publish and sign the message when prompted by your wallet.\n\nAttributing collaborators\n\nIf you collaborated with other artists when creating your items, you can add attributions within the Wearables Editor. This can only be done after publishing a collection.\n\nFirst, navigate to the Builder and select the Collections tab. Select the collection containing the items you want to add attributions to, click the … icon next to the Mint Items button, and select Collaborators.\n\nTo add collaborators, simply enter their Ethereum address, and click Add. You can add as many collaborators as you want. To remove a collaborator, simply click Remove next to the collaborator’s address.\n\nSelling items\n\nAfter your items are published in a collection and approved by the Curation Committee, they can be sold to other users in the metaverse.\n\nItems can be sold in primary sales and secondary sales.\n\n\n  \n    Primary sales are performed by the Decentraland Store’s smart contract. During a primary sale, the item is minted automatically, and it is sold for the price set by you in the Wearable Editor.\n  \n  \n    Secondary sales are performed by the Decentraland Marketplace’s smart contract. These occur anytime a user sells an item in the Marketplace after it has been minted or purchased in a primary sale. Items can be sold for any price in a secondary sale.\n  \n\n\nTo view items available to purchase in a primary sale, head to the Decentraland store!\n\nTo view items available for secondary sales, visit the Decentraland Marketplace.\n\nPrimary sales\n\nPrimary sales occur when one of your items is purchased for the first time. These sales are only performed by the Decentraland Store’s smart contract.\n\nWhen a user makes a primary purchase of one of your items, the store mints the item automatically, transfers the item to the purchaser, and sends the MANA proceeds to the beneficiary address.\n\n\n  Remember! You do not need to mint your items in order to sell them in primary sales!\n\n\nTo sell your items via primary sales, begin by navigating to the Builder and selecting the Collections tab.\n\nSet the price and beneficiary address\n\nSelect the collection you would like to sell, and set the price and beneficiary for each item. The beneficiary address is the address that will receive the MANA resulting from a primary sale.\n\nIf the price you set for a primary sale is “Free”, users will be able to purchase your items at no cost in the store, but they can resell the item in a secondary sale at any price later on.\n\nYou can change the price and beneficiary address for any item in your collection at any time.\n\nEnable primary sales\n\nFinally, click the On Sale switch and click Turn On in the confirmation window that appears. When this switch is enabled, your collection will be available to purchase within the Decentraland store.\n\n\n\nAs long as this switch is turned on, the Decentraland store will automatically mint one of your items whenever a user makes a primary purchase.\n\nThis means that it is possible to mint and sell all of your available items until the maximum supply is reached. If you want to save one or more of your items before listing them for sale, you need to manually mint an item to one of your own wallet addresses.\n\nAnyone who purchases one of your items is able to resell it at any time, and at any price, in a secondary sale in Decentraland’s Marketplace.\n\nAll primary sales within the Decentraland in-world store are subject to a 2.5% fee. This fee is transferred to the DAO.\n\nIf I sell an item via a primary sale, will I receive my MANA on Polygon?\nYes, the proceeds of any items sold on Polygon will reside on the sidechain. You will have to pay a transaction fee if you want to transfer your MANA from the Polygon sidechain to the main Ethereum chain. You can do so from the Accounts page.\n\nIf you want to transfer MANA that you’ve earned from a wearable sale on the Polygon to the Ethereum main network, you will have to pay a gas fee at the bridge. For more information on the Polygon sidechain, please see this blog post.\n\nDisabling primary sales\n\nTo unlist your items, click the On Sale switch to toggle it off. This will only apply to primary sales for your items.\n\nSecondary sales\n\nItems can be sold in secondary sales at any time, and for any price, in the Decentraland Marketplace only after:\n\n\n  They have been minted, or\n  they have been purchased in a primary sale\n\n\nIn other words, anybody who owns an NFT for a wearable can sell it in the Decentraland Marketplace. There are no royalties for wearables sold in secondary sales in Decentraland.\n\nMinting wearables\n\nMinting is the process of creating the actual non-fungible tokens (NFTs) based on the items you’ve uploaded to the Wearables Editor.\n\nAs with selling items in primary sales, you will not be able to mint any items within a collection until the review process is complete. If your collection is still under review, you will see the tag “Under Review” appended to your collection. After it has been reviewed and approved, the tag will change to “Published”, and you can begin minting your items manually.\n\nItem rarities\n\nWhen you publish a collection, each item in that collection has a rarity. This rarity is set by you when you upload an item, and is recorded in a smart contract. Rarities limit the total supply, or stock, that you can mint of any particular item.\n\nThe available rarities, and the maximum supply provided by each, are:\n\n\n  \n    \n      Rarity\n      Limit\n    \n  \n  \n    \n      Unique\n      1\n    \n    \n      Mythic\n      10\n    \n    \n      Legendary\n      100\n    \n    \n      Epic\n      1000\n    \n    \n      Rare\n      5000\n    \n    \n      Uncommon\n      10000\n    \n    \n      Common\n      100000\n    \n  \n\n\n \n\nFor example, if you have a collection with one Epic item, then you can only mint up to 1000 NFTs of that item.\n\nThe Polygon sidechain\n\nAll wearables in Decentraland are minted on the Polygon sidechain. This allows users to mint and transfer items without paying any gas fees (so long as these transactions are conducted solely on the Polygon sidechain).\n\nHow to manually mint your items\n\nTo mint published items, open the collection containing the items you’d like to mint, and click Mint Items.\n\n\n\nYou will be shown a modal window containing a list of the items available along with the supply available for each. Remember, the supply is the total number of items you can mint. For example, if your supply reads 0/10, then you have used 0 out of your total supply of 10.\n\n\n\nWhen minting, you must set the address that will receive the minted items and you must set the number of items you want to mint to that address. You cannot mint more items than are available in the supply available.\n\nIf you enter your own address, then the items that are minted will be transferred to your account.\n\nYou can “gift” items to anyone you like by entering their address instead of your own under Address.\n\nRemember, these items are minted and transferred to the address entered for free. The price you set for items is only collected in primary sales.\n\n\n  Note: You can currently only mint 50 items per transaction.\n\n\nAre there any fees associated with minting items?\nNo, items are minted on the Matic sidechain, thus removing any fees traditionally associated with minting NFTs on the main Ethereum blockchain."
        }
        
      
    
  
    
      
        ,
        
        "decentraland-publishing-wearables": {
          "id": "decentraland-publishing-wearables",
          "title": "Publishing Wearables",
          "categories": "Decentraland",
          "url": " /decentraland/publishing-wearables/",
          "content": "For detailed instructions on how to submit your wearable collection for approval before publication, see the User Guide. This document explains how the approval process works when publishing wearables, and what criteria is used by the Curation Committee when reviewing wearables. For detailed information on the Curation Committee, start here.\n\nThe publication process\n\n\n  After clicking “Publish” on your completed proposal, it will be submitted to the Curation Committee for approval. Collections pending approval will be flagged as “Under Review”.\n  Any collections pending approval from the Curation Committee may not be minted until the approval process is completed.\n  Each time you publish a new collection, a post is automatically created on the Decentraland Forum, providing a list and overview of each item in the collection. This Forum post gives the community and the Curation Committee a space to share feedback or request any changes that you need to make before your collection can be approved.\n  If there are changes you need to make, the Curation Committee will notify you in the Forum thread for your collection.\n  After any needed changes have been made, you can resubmit your collection for approval. (Collections may be reviewed and rejected multiple times before final approval.)\n  Once your collection has final approval, you will be notified in the Forum. You will also see a visual indicator in the Wearable Editor next to the approved collection.\n  With a successful approval, you can begin minting items in your collection!\n\n\nPublication fees\n\nThere is a required fee for publishing items. This fee was voted in place by the Decentraland DAO This fee exists to deter users from publishing an excessive number of wearables in an attempt to “spam” the wearables market.\n\nThe fee is a flat rate of $500 value (paid in MANA) per item (not NFT!) in your collection.\n\n\n  Note: Previously it was 500 MANA, with MANA’s value increase, it was lowered to equal $500 in a recent DAO vote.\n\n\nThe calculation examples below use 500 MANA as fee. The actual fee of MANA will be set weekly by the DAO, in order to try and always align with $500 in valuation.\n\nFor example, if you publish a collection with two items, you will have to pay a fee of 1000 MANA (500 MANA for each item) regardless of the rarity (or how many NFTs can be minted) of those items.\n\nThese fees are transferred to the Decentraland DAO, where they are used to help fund the growth of the platform through grants and other initiatives voted on by the greater Decentraland community.\n\n\n  Note: Currently, due to the time and resources required to review each collection submitted, the 500 MANA publication fee is non-refundable. If your collection is rejected, you will not receive your 500 MANA back. If your collection is not immediatly approved, the Curation Committee will provide you with suggestions and feedback on how to improve it, but the final acceptance of your collection cannot be guaranteed.\n\n\nAcceptance criteria\n\nFollowing is an overview of the criteria used by the Curation Committee when determining a collection’s eligibility. Much of this criteria is based on Section 2 of Decentraland’s Content Policy.\n\nSpecifically, wearables may not:\n\n\n  Involve illegality, such as piracy, criminal activity, terrorism, or child pornography\n  Infringe third party intellectual property rights\n  Contain cruel or hateful imagery that could harm, harass, promote or condone violence against, or that is primarily intended to incite hatred of, animals, or individuals or groups based on race or ethnic origin, religion, nationality, disability, gender, age, veteran status, or sexual orientation/gender identity\n  Contain content that is libelous, false, inaccurate, misleading, or invades another person’s privacy\n  Breach the Privacy Policy\n  Contain any content that promotes or could be construed as primarily intending to evade the limitations described above\n\n\nPlease refer to the full Content Policy here for additional details and definitions. Any submissions that violate the above criteria will be rejected.\n\nIn addition to the Content Policy, the committee may reject wearable submissions on the following technical conditions:\n\n\n  It is important that wearables be “skin weighted” correctly so that the avatar animations can be rendered as expected. Wearables without correct skin weighting will be rejected.\n  Wearables must preserve avatar UV mapping to ensure that user-selected skin tones can be rendered as expected.\n  The dimensions of eyebrow, eye, and mouth textures should not exceed 256 by 256px, and these textures must include an alpha channel for transparency.\n  \n    Wearables with a disproportionate number of triangles and textures may be rejected. Wearables with too many triangles and textures can result in poor performance and a bad experience for users, so creators should avoid exceeding the following guidelines when creating wearables:\n\n    \n      No more than 1.5K triangles per wearable (except skin category)\n      No more than 500 triangles per accessories\n      No more than 2 textures (at a resolution of 512x512px or lower) per wearable. All textures must be square.\n      No more than 5k triangles for skin category and 5 textures (at a resolution of 512x512px or lower). All textures must be square.\n    \n  \n  Wearables may not contain duplicate items within a collection. (Each item within a collection must be unique.)\n  Wearables may not mimic or copy other wearables that have already been published.\n  Wearables with misleading categories may be rejected; for example, a hat that is categorized as a lower body item."
        }
        
      
    
  
    
      
        ,
        
        "decentraland-curation-committee": {
          "id": "decentraland-curation-committee",
          "title": "Curation Committee",
          "categories": "Decentraland",
          "url": " /decentraland/curation-committee/",
          "content": "The Wearables Curation Committee is a group of individuals elected by the DAO who are responsible for reviewing and approving wearables submitted by the Decentraland community. The current Curation Committee includes three members, but it can be expanded to include more. Each member holds a key in a multisig wallet that is used to vote on the approval or rejection of each item submitted via the Wearables Editor.\n\nThe approval criteria used by the committee when reviewing wearables is outlined in Publishing Wearables.\n\nThe current members of this committee are:\n\n\n  HirotoKai. Community Creator\n  Juan Pablo Colasso, 3D Visual Artist\n  KJ Walker, 3D Community Developer\n  Laura Uson Dolsac, Lead Artist, Polygonal Mind\n  Malloy, 3D Artist\n  Martin Shibuya, Art Director, Decentraland Foundation\n  Sebastian Valla, Art Lead, WonderZone\n\n\nWhy does Decentraland need a Curation Committee?\n\nWearables are a critical aspect of the avatar creation and customization experience. With the addition of the Wearables Editor, any member of the community can create their own wearables to share with other users.\n\nHowever, wearables in Decentraland still need to be moderated in order to prevent spam, abuse, duplicated content, and copyright infringements (as per Decentraland’s Content Policy, Terms of Use, and Code of Ethics).\n\nWearables within the Decentraland ecosystem must also meet several technical requirements, otherwise they may not render correctly or they may adversely affect other wearables equipped at the same time. Until this approval process can be more fully automated, it is necessary for several individuals to review each wearable manually."
        }
        
      
    
  
    
      
        ,
        
        "decentraland-creating-wearables": {
          "id": "decentraland-creating-wearables",
          "title": "Creating Wearables",
          "categories": "Decentraland",
          "url": " /decentraland/creating-wearables/",
          "content": "What are wearables?\n\nWearables are the different clothing items, accessories, and body features that can be used to customize the appearance of a Decentraland avatar. While there are some default wearables available to all users, Decentraland also supports the use of custom wearables. These custom wearables can be created by both brands and users, and are often distributed in competitions and giveaways. Decantraland’s growing marketplace for user-generated content also includes support for wearables, which can be bought, sold, or traded as NFTs (non-fungible tokens).\n\nThere’s a growing range of available wearables including cyberpunk themed sneakers, fashionable jackets, fun tophats, and more! All of these stylistic choices give users an exciting and meaningful way to invest in, and express, their own unique personalities. By allowing wearables to be minted, and then sold, as NFTs, Decentraland provides content creators with a fun way to monetize their creative work.\n\nThis guide introduces the basics of creating custom 3D models for Decentraland wearables. It explains how the Decentraland “avatar system” works, and it illustrates how to properly model your own wearables.\n\nNote: this guide assumes that you already have some basic to intermediate knowledge of 3D modeling. If you’re new to 3D modeling, start here.\n\nThe Decentraland Avatar System\n\nThe Decentraland “avatar system” is the broad collection of different body components and subcomponents that can be decorated with custom wearables. These components are:\n\n\n  Body shape\n  Head\n    \n      Head shape\n      Eyebrows\n      Eyes\n      Mouth\n    \n  \n  Upper body\n  Lower body\n  Feet\n\n\nBody shape\n\nThe basic form of an avatar. Wearables can be assigned to one, or both, body shapes. Currently, there are two body shapes: A or B.\n\n\n\nHead\n\nThe head includes several different meshes:\n\nHead Shape\nThis is the base mesh of the head on which all other head features attach to.\n\nEyebrow\nThe Eyebrow mesh functions as a transparency mask. It is used to create different eyebrow styles.\n\nEye Mesh\nThe Eye mesh functions as a transparency mask, and is used to create different eye styles.\n\nMouth\nThe mouth mesh functions as a transparency mask, and is used to create different mouth styles.\n\n\n\nUpper Body\n\nThe upper body, or torso, of an avatar includes the arms and hands. All upper body wearables are applied to the entire torso.\n\n\n\nLower Body\n\nThe lower body includes the pelvis, legs, and ankles of an avatar.\n\n\n\nFeet\n\nJust the feet! All boots, shoes, sandals, socks, etc. are applied to the feet, not the lower body.\n\n\n\nWearable Categories\n\nEach wearable has a specific category that determines which body part in the avatar system (e.g. head, upper body, etc.) the wearable will be applied to. Certain wearables will impact whether or not other wearables are rendered, depending on the specific category. Some wearables will entirely replace others with sometimes unexpected and surprising results. See the list below for details.\n\nThe different categories are:\n\n\n  Body_shape: Replaces the entire avatar’s body.\n  Skin: Replaces the entire avatar (head, upper body, lower body and feet except accesories)\n  Hat: Replaces the avatar’s hair. For hats that leave some hair exposed, it must be attached to the hair in the mesh to prevent the avatar from going bald whenever they put on their hat.\n  Helmet: Overrides the avatar’s entire head, replacing both hair and facial_hair.\n  Hair: Replaces an avatar’s hat.\n  Facial_hair: facial hair won’t replace or override any other wearables.\n  Head:\n    \n      Mouth\n      Eyes\n      Eyebrows\n    \n  \n  Upper_body\n  Lower_body\n  Feet\n\n\nThere are also accessories that can be applied to different areas of an avatar. Some of these accessories can impact other wearables. The accessories are:\n\n\n  Mask: Replaces helmet, tiara, eye_wear and it will override facial_hair.\n  Eye_wear: Replaces helmet and mask.\n  Earring: Replaces helmet.\n  Tiara: Replaces mask and helmet.\n  Top_head: This is rendered on the top of an avatar’s hard. For example, an angel’s halo.\n\n\nBuilding 3D models for wearables\n\nLet’s start to create some wearables!\n\nTo ensure that Decentrand runs smoothly for all users, it is important to create wearable models without using too many triangles. The goal is to keep models as simple as possible so that they can easily be rendered, without sacrificing too much detail.\n\nThe same goes for textures. It’s critical that we use as few textures as possible.\n\nThere are limits for the number of triangles and textures that can be used for each wearable or accessory:\n\n\n  No more than 1.5K triangles per wearable\n  No more than 500 triangles per accessories\n  No more than 2 textures (at a resolution of 512x512px or lower) per wearable. All textures must be square.\n  In the case of skin wearable, the amount of tris allowed are 5k and 5 textures.\n\n\nBefore you get started, download the example files for reference meshes and textures.\n\nUpper body, Lower body, and Feet\n\nAfter downloading the example files, load the models into your 3D editor, like Blender.\n\nYou’ll notice that each model contains 7 different meshes related to an armature. These meshes represent the head, eyebrows, eyes, mouth, upper body, lower body and feet. You can use these example models as a reference and starting point for your own custom wearable.\n\nImportant: Do not modify the “cuts” or the “stitches” between categories (unless you want to create an unusual “floating head” effect or something similar).\n\nYou’ll also notice that each category has caps, making them “water tight”. These caps exist to prevent unsightly glitches if there are any animation clipping problems due to bad skin weighting. It’s best to leave these caps on.\n\n\n\nThere are two basic materials for avatar models. One is the material used for the wearable itself and the other one is used for the skin.\n\n\n\nEach base mesh comes with its own skin texture.\n\n\nSkin for Avatar Shape A\n\n\nSkin for Avatar Shape B\n\nYou’ll notice that each skin texture is rendered grayscale in your editor. This allows us to tint the skin later in the avatar editor according to the user’s preference.\n\n\n\nImportant: always preserve the UV mapping for any body part left exposed by a wearable, like the bottom of the legs left exposed by shorts and skirts. We want to leave any skin material meshes unmodified so that the user’s skin tone is rendered correctly.\n\n\n\nWe want to leave the skin mesh alone and use the default AvatarWearable_MAT texture provided in the example files whenever possible to select colors for our wearables. This will guarantee that your wearables are performant. However, you can create custom textures for our wearables! It’s always best to use a single, very small, texture file for each wearable.\n\n\n\nEyebrows, Eyes and Mouth\n\nThese meshes work with a transparent shader so you don’t have to do anything aside from creating your own png texture for the new eyebrow, eye, or mouth style you want and placing it correctly into the UV map. These textures should be 256x256px and need to have, of course, an alpha channel (for transparency).\n\nHere are some example png textures:\n\n\nEyes\n\n\nEyebrows\n\n\nEyebrows\n\n\nMouth\n\n\nMouth\n\nNodes:\nTo visualize the final result you’ll need to use these nodes (in Blender):\n\n\n\n\n\nMasks:\nYou will notice that the Avatar Editor has different color options users can choose from when selecting different wearables.\n\n\n\nThese color choices are applied to a specific mask in the wearable.\n\n\nEyes Mask\n\n\nEyes Base\n\nThe black area in the image on the left (Eyes Mask) indicates the area of the texture on the right (Eyes Base) that will be colored. It’s important to remember that irises always have a grey band scale (if the iris is pure black, the tint isn’t going to work).\n\nHair and Facial Hair\n\nThere are two important things to remember when creating custom hair wearables.\n\nFirst, try to follow the shape of the head. You can always refer to the head mesh provided in the example files if you need a place to start.\n\n\n\nSecond, if you want users to be able to change the color of your custom hair or facial hair using the avatars editor, then you must paint the hair in grayscale. Lower shades of gray will appear darker and higher shades of gray will appear brighter, but always in the color selected by the user in the avatar editor.\n\nSkin Weighting\n\nSkin weighting is the process of determining which bones in the avatar’s rigging affect which wearables during an animation.\n\nWhen skin weighting our new wearables, there are several considerations we need to keep in mind.\n\nEach asset must be weighted to the full skeleton. For example, an upper body asset will look like this when applying skin weights:\n\n\n\nWearables that meet at intersections between body parts must be fully weighted to the same bone. For example, in these two green zones, the vertices in the neck need to be fully weighted to the “Neck” bone only.\n\n\n\nThe “key” bones to use when skin weighting are:\n\nHead Bone: for the hair, earrings, tiaras, eyes, eyebrows, mouth and any accessory that needs to follow the head’s movement.\n\nNeck Bone: for the main head and upper body’s intersecting vertices.\n\nHips Bone: for the upper body and lower body’s intersecting vertices.\n\nRight Leg and Left Leg Bones: for the lower body and feet intersecting vertices.\n\nIf you keep these guidelines in mind when skinning your avatar meshes, everything will work as with the native avatars.\n\nRemember, you can use any bone to influence any mesh’s vertices! For example, you could create a new foot mesh for a tall pair of boots, and skin weight the top of the boot to the “Leg Bones”. Or, you could create some long hair and use the “Shoulder” or “Spine” bones to influence the hair when the avatar moves around.\n\nResources\n\nIn this shared folder you can find base models, textures, and various other resources, including examples of fully-created wearables. Feel free to leverage these resources when creating your own.\n\nWearables Reference Models"
        }
        
      
    
  
    
      
        ,
        
        "decentraland-what-smart-contracts-does-the-dao-control": {
          "id": "decentraland-what-smart-contracts-does-the-dao-control",
          "title": "The DAO&apos;s Smart Contracts",
          "categories": "Decentraland",
          "url": " /decentraland/what-smart-contracts-does-the-dao-control/",
          "content": "The Decentraland DAO owns several of the most critical smart contracts of the Decentraland platform. They are listed below:\n\nThe LAND contract ⛰️\nThe DAO is the owner of the LAND smart contract. This means that any changes or modifications to that contract must be carried out by the DAO and the SAB.\n\nThe Estate contract 🏘️\nLike the LAND contract, the DAO owns the Estate contract which can only be modified by the SAB, after approval has been given by the DAO through a community vote.\n\nPOIs📍\nThe list of Points of Interest (notable locations in Decentraland that are advertised to users as good places to begin exploring the virtual world) is also owned by the DAO. This list is stored on a contract and can only be modified after passing a vote by the community that is then enacted on-chain by the DAO Committee.\n\nNames 🏷️\nThe contracts used to mint the NFTs for unique avatar names in Decentraland are owned and controlled by the DAO. Any changes to the names contract must be approved by the DAO.\n\nBanned names 🚫\nThe list of names that have been banned from the Decentraland client is stored in a contract owned by the DAO. This list can only be modified after passing a vote by the community that is then enacted on-chain by the DAO Committee.\n\nCatalyst nodes 🌐\nThe list of Catalyst nodes that serve content and establish the peer-to-peer connections needed to keep Decentraland’s virtual world running is also owned and controlled by the DAO. This list is stored on a contract and can only be modified after passing a vote by the community that is then enacted on-chain by the DAO Committee.\n\nWearable collections 👕\nIn Decentraland wearables can be grouped into collections before minting. The contracts used to manage wearables collections are owned and controlled by the DAO.\n\nMarketplace contracts 🛒\nThe Decentraland Marketplace dApp makes use of several smart contracts to manage the process of selling and bidding on LAND, Estates, and other NFTs. These contracts are also where the marketplace fees are defined, and can only be changed with the DAOs approval.\n\nGrants 💰\nThe vesting contracts used to make recurring payments as part of the DAO’s grant framework are also owned by the DAO. These contracts are created by the DAO Committee on behalf of the DAO, and are overseen by the SAB to prevent any risk of monetary loss due to vulnerabilities or mistakes made by the Committee."
        }
        
      
    
  
    
      
        ,
        
        "decentraland-what-is-the-dao": {
          "id": "decentraland-what-is-the-dao",
          "title": "What is the DAO?",
          "categories": "Decentraland",
          "url": " /decentraland/what-is-the-dao/",
          "content": "The Decentraland DAO is a decision-making tool for MANA and LAND holders in Decentraland’s virtual world. Through votes in the DAO, the community can issue grants and make changes to the lists of banned names, POIs, and catalyst nodes. The DAO also controls the LAND and Estate smart contracts.\n\nIssuing grants and making changes to the records and contracts owned by the DAO can only be done by using predefined proposals accessible in governance.decentraland.org.\n\nThese proposals, the votes submitted, and final results are all stored in IPFS via Snapshot, a gas-less voting client. Approved proposals with binding actions are enacted on the Ethereum blockchain by a committee by means of a multi-sig wallet. This committee is overseen by the Security Advisory Board (SAB), another multisig with trusted key holders. This Committee was voted into place by the community in the previous release of the DAO. The original proposal can be found here..\n\nThe remainder of this document explains in greater detail what the DAO is, how it works, and what it can be used for.\n\nFor a detailed tutorial on how to use the Decentraland DAO, visit the User Guide.\n\nThe DAO is powered by smart contracts\n\nAll DAOs, or decentralized autonomous organizations, are part of a new approach to organizational management and decision making made possible by Ethereum.\n\nEthereum extended what’s possible with blockchains by adding the ability to decentralize the handling of data more complex than just records of token ownership. Ethereum did this by allowing people to put smart contracts on a blockchain.\n\nWhat’s a smart contract?\n\nA smart contract is a computer program that is run on the Ethereum blockchain. It can store both functions (bits of code that do things) and data (information). Smart contracts are often compared to vending machines. If you put in specific inputs, you get specific outputs. If I walk up to a vending machine, insert $1, and press the “orange soda” button, then I’ll get an orange soda if there’s any left in the machine. If there’s no more orange sodas, I’ll get my dollar back.\n\nSmart contracts work the same way, people can interact with them by sending information with the expectation of receiving specific results or information. Just like the vending machine doesn’t have a little person inside handing out sodas, smart contracts are automatic (dare we say, autonomous).\n\nIf you’d like to learn more about Ethereum smart contracts, the Ethereum documentation is the best place to dive in.\n\nThe DAO controls Decentraland’s critical smart contracts\n\nThe second important quality of smart contracts is their ability to own other smart contracts.\n\nThat’s right, every smart contract has its own address (just like the address of your Ethereum wallet) that allows it to own other smart contracts and cryptocurrencies.\n\nSo, in slightly more technical terms, a DAO is one or more smart contracts that can perform specific, pre-defined tasks and maintain ownership of cryptocurrencies. DAOs are built in such a way that they will only perform their tasks under specific conditions, such as the passing of a proposal voted on by a group of people who own a certain token (like MANA or LAND). All of this is done on a blockchain. Hence the name, “decentralized autonomous organization”.\n\nDecentraland’s DAO also owns a sum of MANA along with the LAND and Estate smart contracts. This MANA fund has been set aside to help sponsor community grants and to help grow the Decentraland platform according to the decisions and directions voted on by the community.\n\n\n  Note:\nThe DAO does not own, and so cannot modify, the MANA smart contract.\n\n  The MANA contract’s owner is the TokenSale contract. The owner of the TokenSale contract is a separate contract that self-destructed on deployment (as you can see on Etherscan here). This means that there is no other contract or wallet with the permissions to modify or pause the MANA supply.\n\n\nThere is other information that the DAO controls as well, such as the list of harmful or offensive names that are not permitted in Decentraland, a list of notable locations to be promoted to new users, and the list of community run servers that host Decentraland’s virtual world.\n\nTransferring any of the DAO’s MANA, modifying the LAND or Estate smart contracts, or modifying any of the other listed information controlled by the DAO can only be done with the approval of MANA and LAND holders."
        }
        
      
    
  
    
      
        ,
        
        "decentraland-what-do-you-need-to-participate": {
          "id": "decentraland-what-do-you-need-to-participate",
          "title": "Participation Requirements",
          "categories": "Decentraland",
          "url": " /decentraland/what-do-you-need-to-participate/",
          "content": "Broadly speaking, DAOs are organizations comprising token holders. In Decentraland’s case, the tokens needed to be a member of the DAO are MANA and LAND. By holding either MANA or LAND, you may create and vote in proposals. Your vote on a proposal is weighted according to the balance of LAND and MANA you have at the time that proposal was created. For more information, see Voting power in the User Guide.\n\nAnyone is allowed and welcome to participate in discussions related to the DAO in Discord, the Forum, or any of Decentraland’s other social channels, but only token holders can cast votes and create proposals."
        }
        
      
    
  
    
      
        ,
        
        "decentraland-what-can-you-do-with-the-dao": {
          "id": "decentraland-what-can-you-do-with-the-dao",
          "title": "DAO Uses",
          "categories": "Decentraland",
          "url": " /decentraland/what-can-you-do-with-the-dao/",
          "content": "The DAO allows for two general types of proposals: proposals with binding actions, and information gathering polls.\n\nProposals with binding actions\n\nThe DAO allows the community to vote on binding actions that will result in changes made to Decentraland’s smart contracts on the Ethereum network. One of these binding actions is the transfer of the DAO’s MANA to fund community grants. Other binding actions that can be proposed to the DAO are:\n\n\n  Adding a catalyst node to the network of servers that host and run Decentraland’s virtual world.\n  Adding points of interest, or highlighted locations within the virtual world, to a list that is shown to users. This list helps users to find popular and interesting locations to explore.\n  Banning a name from Decentraland. This proposal type allows users to ensure that avatars cannot be given offensive and harmful names.\n\n\nWhat about modifying the LAND or Estate smart contracts?\n\nRight now, the DAO owns both the LAND and Estate smart contracts. Any modifications to either of these contracts must be carried out by the Security Advisory Board (SAB) and DAO Committee – groups of trusted and elected persons tasked with ensuring the continued security of these important pieces of Decentraland’s infrastructure.\n\nThe SAB must vote through a multi-sig wallet to approve any changes to the LAND or Estate contracts, preventing a rogue SAB member from introducing a vulnerability.\n\nCurrently, there are no predefined proposal categories for modifying the LAND or Estate smart contracts via the DAO’s UI. That doesn’t mean it is impossible for a non-SAB member to initiate changes, but it is a lengthier process that requires obtaining support from the broader community in addition to having the technical expertise needed to supply the code changes and a trusted third party to audit those changes.\n\nThe source code for the LAND and Estate contracts is available on GitHub here.\n\nGenerally speaking, the process for modifying either contract would be:\n\n\n  Polling the community via the DAO, and publicly discussing your proposed changes to gather support\n  After gaining the community’s support, writing the updated code to be merged into the contract\n  Obtaining a successful code review and audit from a reputable third-party\n  Presenting the audited code to the community and obtaining their approval to have it merged with the contract\n  Once approved by another community vote, the DAO Committee or SAB would perform the contract upgrade with the new code\n\n\nNon-binding polls\n\nThe Decentraland DAO also allows the community to create and vote in non-binding multiple choice polls that are intended to gather opinions and sentiments on topics related to the platform. When paired with discussion in the forum, this is a powerful tool for building consensus within the community, but it has no immediate binding actions.\n\nAlways remember, the results of a poll do not necessitate any followup action."
        }
        
      
    
  
    
      
        ,
        
        "decentraland-the-daos-limitations": {
          "id": "decentraland-the-daos-limitations",
          "title": "DAO Limitations",
          "categories": "Decentraland",
          "url": " /decentraland/the-daos-limitations/",
          "content": "The most important thing to remember about the Decentraland DAO is that it is a specific governance tool with limited capabilities. Like a vending machine, the DAO is automated. However, this automation leads to limited options.\n\nThere is a finite number of functions within the DAO’s smart contracts. These functions can easily be called by passing one of the binding proposals in the Governance UI, but the process for adding or modifying the functions within the DAO is much more complex.\n\nThe second most important thing to remember about the DAO is that it is an organization. Making changes to how this organization runs takes time and social momentum that can only be built up through fostering productive relationships and dialogue with the broader Decentraland community."
        }
        
      
    
  
    
      
        ,
        
        "decentraland-the-dao-fund": {
          "id": "decentraland-the-dao-fund",
          "title": "The DAO Fund",
          "categories": "Decentraland",
          "url": " /decentraland/the-dao-fund/",
          "content": "One of the most common questions received about the DAO is “how much MANA does the DAO have, and what is it for?”\n\nThe DAO possesses 222 million MANA by means of a 10 year vesting contract.\n\nAt the time of this writing (May 21 2021), of that 222 million MANA, roughly 14.1 million MANA has been released (withdrawn) from the vesting contract. In addition to that 14.1 million MANA, an additional 13.5 million MANA may be released as of the time of this writing. This makes for a total of 27.6 million MANA currently available to the DAO.\n\nThe MANA in this contract vests every second, thus gradually increasing the size of the DAO’s fund.\n\nYou can view the DAO’s vesting contract here.\n\nThe DAO also has several sources of income:\n\n\n  The 2.5% transaction fees within the Decentraland Marketplaces on primary market commissions go to the DAO\n  The OpenSea Marketplace also receives a 2.5% transaction fee for sales of LAND, Estates, Names, and wearables, part of which is transferred to the DAO."
        }
        
      
    
  
    
      
        ,
        
        "decentraland-how-does-the-dao-work": {
          "id": "decentraland-how-does-the-dao-work",
          "title": "How the DAO works",
          "categories": "Decentraland",
          "url": " /decentraland/how-does-the-dao-work/",
          "content": "To circumvent the very high gas fees associated with full on-chain governance, Decentraland’s DAO uses a combination of free, off-chain voting for the community and a multi-sig wallet controlled by a “DAO Committee” to enact those off-chain decisions on the Ethereum blockchain. This allows everyone who holds MANA or LAND to participate in the DAO without having to pay any fees everytime they want to vote or open a proposal.\n\nThe use of a multi-sig wallet controlled by a committee of trusted persons guarantees the security of the DAO along with guaranteeing that passed proposals result in an on-chain action. A second multisig owned by the SAB provides a second layer of protection on top of the DAO Committee.\n\nThe DAO is a complex system created from several layers of entities and platforms, each of which is listed and described below:\n\nGovernance UI\n\nThe main interface for the Decentraland DAO is located at governance.decentraland.org. This is where users log-in, create proposals, and vote.\n\nSnapshot\n\nSnapshot is an off-chain voting platform that provides a free way for token holders to vote on proposals. By storing both the proposals and the votes on IPFS as cryptographically signed messages, Snapshot allows for secure and easily contested results.\n\nDecentraland’s DAO uses Snapshot to host the proposals and votes generated by the community.\n\nWhenever a proposal is opened at governance.decentraland.org, it is also created automatically on Decentraland’s Snapshot space. This allows the DAO to record and store proposals, votes, and results in a secure and decentralized manner - with the results displayed back on governance.decentraland.org.\n\nAragon\n\nAragon is a secure platform for creating and managing the collection of smart contracts needed to run a DAO. The backend of Decentraland’s DAO is built using Aragon, so anytime a proposal that results in a binding action is passed by the community in Snapshot, it is committed to the Ethereum mainnet in Aragon by the DAO Committee.\n\nDAO Committee\n\nThe DAO Committee is a group of three trusted individuals who have been selected by the community to hold keys in a multi-sig wallet. This multi-sig is responsible for enacting any passed votes with a binding action, like transferring grant funding, banning a name, adding a POI, or adding a Catalyst node.\n\nThe power DAO Committee is checked by the SAB, which has the ability to pause and cancel any action initiated by the Committee.\n\nEvery on-chain transaction initiated by the DAO Committee has an automatic 24-hour delay before it is completed, allowing the SAB or the Committee to revoke the transaction.\n\nSecurity Advisory Board (SAB)\n\nThe Security Advisory Board acts as a guarantor of Decentraland’s smart contract security, and is tasked with overseeing the work of the DAO Committee and responding to vulnerability and bug reports in any of Decentraland’s contracts.\n\nThe SAB includes 5 Solidity experts that have initially been selected by the Decentraland development team.\n\nAny time a modification is to be made to the LAND or Estate contracts, the update must be unanimously supported by the SAB’s multi-sig. At least three signatories are required with no dissenting votes in order to make any changes to the LAND or Estate contracts.\n\nThe SAB has the ability to pause, resume, or cancel any action taken by the DAO Committee.\n\nInitiating the addition or removal of a member of the SAB can be done by opening a proposal on governance.decentraland.org.\n\nThe Forum\n\nThe Decentraland Forum is the communication hub for the DAO. Everytime a new proposal is created, an accompanying thread is opened automatically on the Forum under the Governance section. These proposal topics can be found either by browsing the Forum, or by clicking the “Discuss in the Forum’’ button on any proposal’s detail page in the Governance UI. These threads are a space where voters can discuss the various impacts and issues that might result from a proposal."
        }
        
      
    
  
    
      
        ,
        
        "decentraland-dao-userguide": {
          "id": "decentraland-dao-userguide",
          "title": "DAO User Guide",
          "categories": "Decentraland",
          "url": " /decentraland/dao-userguide/",
          "content": "Table of Contents\n\n\n  Logging in\n  Voting power\n  Approval/Rejection Conditions\n  Browsing proposals\n  Viewing a proposal\n  Adding proposals to your watchlist\n  Voting\n  Participating in the Forum\n  Creating a proposal\n  Proposal categories\n  Deleting a proposal\n\n\nLogging in\n\nTo get started with the DAO, visit governance.decentraland.org. You will be presented with a welcome screen and quick start tutorial.\n\nAfter reading the quick start tutorial, click Sign In. You must connect a wallet in order to use the DAO. Currently, you can use either Metamask or Fortmatic.\n\nAfter connecting your wallet you will be taken to the homepage of the DAO featuring a list of all currently active proposals.\n\nVoting power\n\n\n  Note:\nIn the previous version of the Decentraland DAO, users were required to “wrap” MANA before they could vote or create proposals. Voting power was derived from the amount of MANA and LAND wrapped.\n\n  The current DAO no longer requires users to wrap any of their assets.\n\n  Voting power is calculated from the total balance of MANA and LAND associated with the wallet connected with the DAO. The DAO looks at both your wrapped and unwrapped balances, so you do not need to unwrap any MANA to achieve your full voting power. However, you can unwrap any previously wrapped MANA at any time from the “Voting Power” tab. There is still a gas fee associated with unwrapping MANA as it is a transaction on the Eth mainnet.\n\n\nYour vote in the Decentraland DAO is weighted according to the balance of MANA and LAND associated with the account you log in with.\n\nTo view your current voting power, navigate to the Voting Power tab.\n\nHow is voting power calculated?\n\nVoting power is represented as “VP”. MANA and LAND contribute to your total voting power as follows:\n\n\n  1 MANA contributes 1 VP\n  1 LAND parcel contributes 2000 VP\n  Each Estate is worth 2000 multiplied by the number of single LAND parcels in that Estate. For example, an Estate with 2 parcels will contribute 4000 VP to your total voting power.\n\n\nWhat happens if your voting power changes before a proposal closes?\nIf your MANA or LAND balance changes, it will affect your voting power, but only on proposals that are created after your balance changes.\n\nThe moment a new proposal is created, the DAO looks at all voters’ MANA and LAND balances to calculate their voting power. In other words, when you vote on a proposal, the voting power of your vote will be equal to the balance you had at the instant the proposal was initially created. You may vote with that VP, then change your MANA/LAND balance without affecting the weight of your vote.\n\nWhy does the Decentraland DAO use weighted votes?\nIf the Decentraland DAO gave each Ethereum address one vote, and each vote was weighted equally, then users could create as many separate addresses as they wanted to obtain more voting power.\n\nDetermining voting power by wrapping MANA and LAND is currently the most secure way to limit the amount of influence each voter may have. Additionally, the more MANA or LAND you own in Decentraland, the greater your personal stake is considered to be, thus earning your vote more influence within the DAO.\n\nApprove/Reject conditions\n\nA proposal in the Decentraland DAO is approved if and only if the total voting power in favor of the proposal is greater than the total voting power against the proposal. This is the typical 50/50 majority model we expect to see in most democratic votes.\n\nIf there is 0 VP worth of votes to reject a proposal, then there is a minimum of 1 VP worth of votes needed to approve the proposal.\n\nThe previous DAO allowed the approval conditions to be changed for each proposal. For example, a 20% approval rate might have been sufficient to pass a proposal. This model has been abandoned in favor of the 50/50 majority.\n\nIn the previous DAO, proposal creators were also able to set the minimum percentage of the total MANA token supply needed to participate in a vote in order for a proposal to be approved. This approach has also been abandoned. There is no longer a minimum participation rate needed to pass a proposal.\n\nMultiple choice polls are neither approved or rejected since they have no binding actions. After the duration of the vote is complete, polls are labeled “Finished”.\n\nBrowsing all proposals\n\nTo view all proposals in the DAO, visit governance.decentraland.org. The homepage of the DAO lists all recently added proposals sorted from most recent to oldest, by default.\n\nYou can filter proposals by Outcomes:\n\n\n  Active – proposals that are currently being voted on\n  Passed – proposals that have been approved by the community\n  Rejected – proposals that have already been voted on and rejected by the community\n  Enacted – proposals that have been enacted on-chain by the DAO Committee\n  Finished – proposals that are closed, but do not have yes/no results, like multiple choice polls\n\n\nYou can also filter proposals by Category using the category column in the left side of the UI:\n\n\n  All proposals – displays all proposals regardless of category or outcome\n  Catalyst Node – only displays proposals to add new Catalyst nodes\n  Point of Interest – only displays proposals to add new POIs\n  Name Ban – only displays proposals to ban a name\n  Grant Request – only displays grant requests\n  Poll – only displays non-binding polls\n\n\nTo view only proposals that have been passed, click the Enacted tab. Enacted proposals in this tab are sorted from most recent to oldest by default.\n\nViewing a proposal\n\nTo read a proposal, just click on the proposal’s title to view the details page.\n\nEach proposal detail page includes all of the descriptive information provided by the person who submitted the proposal.\n\nYou’ll also find links to the proposal’s discussion thread in the Forum, buttons to add a proposal to your watch list, the current voting results, buttons to vote YES or NO along with your current Voting Power.\n\nProposal details pages also list the unique avatar name associated with the Ethereum address that opened the proposal, if one exists, and the start and end dates of the proposal.\n\nFinally, you’ll see a link to the proposals entry on Snapshot – the voting platform used by the Decentraland DAO.\n\nAdding proposals to your watch list\n\nTo add a proposal to your watch list, view the proposal’s detail page and click Add to my Watchlist.\n\nTo remove a proposal from your watchlist, click Remove from my Watchlist from the proposal’s detail page. You can also click the red flag icon on any proposal currently in your watchlist to remove it.\n\nVoting\n\nTo vote on a proposal, log into the DAO at governance.decentraland.org with a wallet that contains LAND or MANA.\n\n\n  Minimum balance needed to vote:\n\n  Only LAND and MANA holders may vote on proposals in the Decentraland DAO. The current minimum balance needed to have a weighted vote on proposals in the DAO is 1 LAND or 1 MANA. Voting with a balance of zero will result in a vote with a weight of 0, which does not impact the final results.\n\n\nTo vote on a proposal once you’ve connected your wallet, simply view the proposal’s detail page and click the VOTE YES or VOTE NO button, according to how you’d like to vote.\n\nMake sure that you read the full proposal so that you understand the issue being discussed and what will happen if the proposal is approved or rejected.\n\nAfter clicking the Vote button, your connected Ethereum wallet will prompt you to sign the transaction. Remember, this is only a signed transaction, and requires no gas fee.\n\nYou will be given the option of adding the proposal to your watch list, this is a nice way to track the proposals you’re interested in. If you don’t want to add the proposal to your Watchlist, just click No thanks.\n\nAfter submitting your vote, you can change it at any time leading up to the end of the voting period - as shown in the proposal’s detail page.\n\nWhat happens if your VP changes before a proposal is complete?\n\nThe DAO calculates your voting power for each individual proposal at the moment each proposal is created. If your VP changes after this moment, it will not affect your vote on that proposal.\n\n\n  For a full discussion of voting power, and how and when it is calculated, please see the Voting Power section of the User Guide.\n\n\nParticipating in the Forum discussions\n\nAs a governance platform, the Decentraland DAO is most effective when paired with frequent discussion within the community. Every time a new proposal is opened on governance.decentraland.org, an accompanying topic is automatically opened on forum.decentraland.org.\n\nBefore casting your vote, please take the time to view and join in on these forum discussions. Click the button Discuss in the forum from the details page of any DAO proposal you wish to discuss. You can also browse open topics by navigating to forum.decentraland.org, heading to the Governance category, and browsing the open topics.\n\nYou don’t need to own MANA or LAND to participate in these discussions! Everyone is welcome to contribute to the conversation.\n\nCreating a proposal\n\nTo create a new proposal in the Decentraland DAO, start by logging in at governance.decentraland.org and connecting a wallet that contains LAND or MANA.\n\nAfter logging in and connecting your wallet, click Submit a proposal and select the proposal category you want to use. Each category will provide a form allowing you to provide the relevant information for your proposal.\n\nThe form for every category is different, so make sure that you select the correct category for your proposal. The proposal forms in the DAO support Markdown, so you can format the content of your proposal to make it more readable. This is especially helpful for longer proposals.\n\nTo preview your rendered Markdown text, toggle the Preview switch.\n\nIf you aren’t familiar with Markdown, you can use simple plain text.\n\nAfter completing the proposal form for the category you’ve selected, click Submit proposal. After successfully submitting your proposal, you will be taken to your new proposal’s detail page where you can add it to your watchlist and cast your vote.\n\nProposal Categories\n\nPoint of interest 📍\n\nPoints of interest are notable locations in Decentraland. These “POIs” are promoted in several areas of the virtual world’s UI, and are promoted as good places for users to explore, especially people new to Decentraland.\n\nIf you have created a location, or have found a location that you think should be on this list, you can use this proposal category to present your suggestion to the DAO.\n\nName ban 🚫\n\nThe “banned name” list includes offensive or harmful avatar and location names that are not permitted in Decentraland. Any names on this list cannot be claimed, used, or transferred between users. To suggest banning a name, you can use the Name ban proposal category in the DAO.\n\nCatalyst nodes 🌐\n\nCatalyst nodes are the community-run servers that provide the content and establish the peer-to-peer connections needed to keep Decentraland’s virtual world running. Whenever a user visits play.decentraland.org, they are connected to one of these nodes. However, only nodes that have been approved by the DAO are used in Decentraland’s network.\n\nTo suggest the addition of a new node to the network, you can use the Catalyst Node category.\n\nPoll 📊\n\nPolls in the Decentraland DAO are non-binding, multiple choice questionnaires that may be used to measure the community’s general opinion or sentiment regarding different issues. They are non-binding in that the DAO does not automatically act on the results of any of these polls. They do not necessitate changes to any of the products, tools, or smart contracts in the Decentraland platform.\n\nHowever, polls are powerful tools for building consensus within the community and for gathering information that could inform a future binding proposal.\n\nDeleting a proposal\n\nProposals can only be deleted by the person who created them.\n\nTo delete one of your proposals, navigate to the details page of the proposal you want to delete. Click Delete Proposal at the bottom of the right hand column. You will have to confirm your deletion.\n\nBe careful! Deleted proposals cannot be restored!\n\nIf you delete a proposal after people have voted on it, nothing will happen. Deleted proposals with binding actions will not be enacted by the DAO Committee."
        }
        
      
    
  
    
      
        ,
        
        "development-guide-dev-workflow": {
          "id": "development-guide-dev-workflow",
          "title": "Development Workflow",
          "categories": "development-guide",
          "url": " /development-guide/dev-workflow/",
          "content": "This document outlines the recommended steps involved in developing a scene for Decentraland, going from testing in the local environment to deploying to production.\n\nBefore you begin\n\nPlease make sure you first install the CLI tools by running the following command:\n\nnpm install -g decentraland\n\n\nSee the Installation Guide for more details instructions.\n\nMake sure you also own or have deploy rights on at least one parcel of land in Decentraland.\n\nLocal preview\n\nTo preview a scene run the following command on the scene’s main folder:\n\ndcl start\n\n\nSee Preview your scene ) for more details. Check the Debug a scene) for tips on how to debug any issues.\n\nDeploy to the test environment\n\nDeploy your scene to the test server.\n\ndcl deploy --target peer-testing.decentraland.org\n\n\nTo access scenes deployed to the test server, enter play.decentraland.org/?&amp;CATALYST=peer-testing.decentraland.org.\n\nPlayers aren’t directed to this server, so it’s a safe place to test out the full flow of a scene without distractions, including multiplayer interactions, wearables, blockchain interactions and everything you’d find in the production environment.\n\n\n  Note: The catalyst test server works like any other node in the catalyst network. This server only receives updates from the rest of the network, it doesn’t push any changes. All scenes available in the production environment are in this server, but scenes deployed to this server don’t get propagated to other servers.\n\n\nContent deployed to the test server is not private. It could potentially be visited by anyone who intentionally enters this server.\n\n\n  Tip: If you want to hide your content from any possible leaks, you might want to consider launching your own Catalyst server, and not submit it to the DAO for adding to the network. That way this server behaves just like the test server, but its address isn’t known to others. See the Catalyst repo readme for instructions on how to do this.\n\n\nLatest SDK changes\n\nWhen developing a new scene, you use the @latest stable SDK release by default.\n\nYou can install the @next SDK release if you want to leverage or preview upcoming features that didn’t yet make it into the latest stable release.\n\nTo do so, run the following on your scene:\n\nnpm i decentraland-ecs@next\n\n\n  Note: Keep in mind that the @next version might suffer issues from time to time. The syntax and name of new features might change before it’s released in a stable version.\n\n\nYou can also access your scene in the test environment with the features from @next by accessing the .zone client.\n\nAfter deploying your scene to the test server, enter the following address to view your scenes using the unreleased SDK features:\n\nplay.decentraland.zone/?&amp;CATALYST=peer-testing.decentraland.org&amp;ENV=org.\n\nUpload a scene to decentraland\n\nOnce you’re happy with your scene, it’s time to publish it to the production environment. There all players will have access to it if they visit the scene’s coordinates.\n\ndcl deploy\n\n\nCheck that your scene has all the necessary metadata: name, description, a preview image, spawn points. See scene metadata for details.\n\nSee publishing for more details.\n\n\n  Tip: To give your new scene more visibility, consider creating an inaugural event in the events page."
        }
        
      
    
  
    
      
        ,
        
        "builder-nfts": {
          "id": "builder-nfts",
          "title": "NFTs",
          "categories": "builder",
          "url": " /builder/nfts/",
          "content": "You can add NFTs (Non-Fungible Tokens) into your scene, displayed as picture frames.\n\nAll image and gif formats that are supported in OpenSea are also supported by Decentraland by picture frames. NFTs in video or audio format are currently not supported. NFTs that also have 3D representations, like Decentraland wearables, are displayed in picture frames as 2D images.\n\nFrom your wallet\n\nThe easiest way to import an NFT you own is to open the Collectibles tab on the right menu, under all the asset pack collections. There you’ll see a list of all the valid tokens available in the wallet you’re currently using. Simply drag an NFT into your scene, you can then move or scale it and treat it like any other item.\n\n\n\n\n  Note: The limitation of this approach is that you can only add NFTs that you own, and you can’t configure properties of the picture frame, like style of the frame an background color.\n\n\nNFTs By id\n\nThe more robust approach is to use the NFT smart item, that you can find in the Gallery asset pack, or by simply searching NFT in the search bar above. Once you drag a copy of the NFT item to your scene and select it, there are a few fields that your can configure.\n\n\n\nThe main fields to configure determine what NFT to display:\n\n\n  NFT ID: The unique id of this specific NFT\n  NFT Contract: The contract address of the collection that this NFT belongs to (ie: Cryptokitties, SuperRare, Decentraland Halloween Wearables 2019, etc)\n\n\nTo obtain these, the simplest way is to look them up in the Decentraland Marketplace and then check the URL. For example, from the URL of the following item:\n\nhttps://market.decentraland.org/contracts/0xb932a70a57673d89f4acffbe830e8ed7f75fb9e0/tokens/20175\n\nYou can infer that the contract is 0xb932a70a57673d89f4acffbe830e8ed7f75fb9e0 (referring to SuperRare) and the ID is 20175.\n\nSimilarly, you can also obtain these from the OpenSea URL of the token. For example, from the URL of the following item:\n\nhttps://opensea.io/assets/0x31385d3520bced94f77aae104b406994d8f2168c/2614\n\nYon can infer that the contract is 0x31385d3520bced94f77aae104b406994d8f2168c (referring to CryptoPunks) and the ID is 2614.\n\nOther optional fields that can be configured in this UI:\n\n\n  Frame Style: The default frame style has a glowing margin that might not match the style of the artwork or your scene. There are several other options to pick from with varying styles, from barroque to minimalist, or even tape on the painting’s corners.\n  Background Color: NFTs with transparent background are given a background color, violet by default. You can choose any other color. Note that some frame styles, like None, don’t include a background color at all. -Include UI: When players click on a picture frame, they see a UI with additional information about the token, including creator, description, sale info and links to purchase it. A hint text appears on screen when pointing at the image, which some might consider distracting from the art. Disable the UI to also remove the hint text. -Extra UI Text: The UI extracts most of its data from external sources, but allows for an additional field where you can add a custom description. This text is only available to players if Include UI is switched on.\n\n\n\n  Note: You can only see these changes take effect when entering the scene in Preview mode. None of these changes modify the representation of the smart item that you drag around in edit mode."
        }
        
      
    
  
    
      
        ,
        
        "market-api-migration-guide": {
          "id": "market-api-migration-guide",
          "title": "LAND API 2.0 Migration Guide",
          "categories": "market",
          "url": " /market/api-migration-guide/",
          "content": "Table of Contents\n\n\n  Where can I find the documentation for version 2.0?\n  Where can I find the documentation for version 1.0?\n  Version 2.0 Migration Guide\n\n\nWhere can I find the documentation for version 2.0?\n\nCurrent documentation (including configuration details) for the LAND API v2.0 can be found here. After version 1.0 has been fully deprecated on February 1st, 2021, all of the v2.0 documentation will be migrated to this URL within the Decentraland documentation.\n\nWhere can I find the documentation for version 1.0?\n\nYou can still find the docs for version 1.0 here. These docs will remain available until February 1st, 2021. After that date, full documentation will be available on this page.\n\nVersion 2.0 Migration Guide\n\nFollowing is a side-by-side comparison of v1 and v2 of the LAND API. Any version 1 endpoints with the tag Deprecated will be unavailable starting February 1st, 2021.\n\nAny version 1 endpoints without the deprecation tag will remain working and supported, as there is no replacement in version 2.0.\n\nThere are several v1 endpoints without a v2 counterpart, but the corresponding data can still be found via a query to Decentraland’s subgraph on The Graph. Example queries are included for each endpoint group, where applicable.\n\nTiles\n\nThe v1 tiles endpoint has been replaced with an improved v2 endpoint. The v2 endpoint returns a more readable and more easily parsed object. For an in depth discussion of these improvements, see this blogpost.\n\n\n  \n    \n      V1 Endpoint\n      Description\n      V2 Endpoint\n      Description\n    \n  \n  \n    \n      GET /v1/tiles\n      Returns all tiles in the map, using the legacy format. Deprecated.\n      GET /v2/tiles\n      Returns all tiles in the map, using the new v2 format. This replaces v1 of the same endpoint, returning an object with a new, more useful shape.\n    \n  \n\n\nBids\n\nAll of the v1 bid endpoints have been replaced with queries to the Graph. See the chart and example below for details.\n\n\n  \n    \n      V1 Endpoint\n      Description\n      V2 Endpoint\n      Description\n    \n  \n  \n    \n      GET /bids/:id\n      Returns a bid by the bid’s ID. Deprecated\n      See example subgraph query below.\n       \n    \n    \n      GET /addresses/:address/bids\n      Returns list of bids by the seller or bidder’s Ethereum address. Deprecated\n      See example subgraph query below.\n       \n    \n    \n      GET /parcels/:x/:y/bids\n      Returns a list of bids placed on a given parcel. Deprecated\n      See example subgraph query below.\n       \n    \n    \n      GET /estates/:id/bids\n      Returns a list of bids placed on a given estate. Deprecated\n      See example subgraph query below.\n       \n    \n    \n      GET /bids/:address/assets\n      Returns a list of bid assets by the seller or bidder’s Ethereum address. Deprecated\n      See example subgraph query below.\n       \n    \n  \n\n\nTo list open and non-expired bids where the expiration date is specified as a unix timestamp:\n\n{\n  bids(where:{ status: open, expiresAt_gt: 1611082372  }) {\n    nft {\n      name\n      contractAddress\n      tokenId\n    }\n    price\n    bidder\n    seller\n  }\n}\n\n\nDistricts and District Contributions\n\nV2 endpoints to expose data about Districts and District contributions are under active development. Until February 1st, 2021, you may still call the v1 endpoint. After that date, new documentation for the v2 endpoints will be published on this page.\n\n\n  \n    \n      V1 Endpoint\n      Description\n      V2 Endpoint\n      Description\n    \n  \n  \n    \n      GET /addresses/:address/contributions\n      Returns all contributions to districts by the contributor’s Ethereum address. Deprecated\n      GET /v2/addresses/:address/contributions\n      This v2 endpoint is under active development, and will be functional on February 1st, 2021 when v1 is deprecated.\n    \n    \n      GET /districts\n      Returns a list of all districts in Genesis City. Deprecated\n      GET /v2/addresses/:address/contributions\n      This v2 endpoint is under active development, and will be functional on February 1st, 2021 when v1 is deprecated.\n    \n  \n\n\nEstates\n\nWhile two v1 estate endpoints are replaced with Graph queries, version 2.0 introduces a new estate endpoint that allows you to return data about an estate based on the estates ID.\n\n\n  \n    \n      V1 Endpoint\n      Description\n      V2 Endpoint\n      Description\n    \n  \n  \n    \n      GET /estates\n      Returns a list of Estates. Deprecated\n      See example subgraph query below.\n       \n    \n    \n      GET /addresses/:address/estates\n      Returns all Estates belonging to the given Ethereum address. Deprecated\n      See example subgraph query below.\n       \n    \n    \n       \n       \n      GET /v2/estates/:id\n      New v2 endpoint that returns metadata about an estate with the given ID.\n    \n  \n\n\nTo obtain estate data, query the Graph for NFT entities with the condition:\n\n{\n  category: estate\n}\n\n\nMap\n\nThe v1 map endpoint remains unchanged and supported.\n\n\n  \n    \n      V1 Endpoint\n      Description\n      V2 Endpoint\n      Description\n    \n  \n  \n    \n      GET /map\n      Returns all parcels and estates in a given area. This endpoint is depcrecated and is replaced by GET /v1/map.png\n       \n       \n    \n    \n      GET /map.png\n      Returns a PNG image of a section of the map.\n      GET /v1/map.png\n      Returns a PNG image of a section of the map. This endpoint is still supported and functional! There is no v2 version of this endpoint, keep calling the v1 endpoint to get the same data.\n    \n    \n      GET /parcels/:x/:y/map.png\n      Returns a PNG image of a piece of the map centered on the given parcel.\n      GET /v1/parcels/:x/:y/map.png\n      Returns a PNG image of a map centered on a highlighted parcel with the given coordinates.\n    \n    \n      GET /estates/:id/map.png\n      Returns a PNG image of a piece of the map centered on an estate specified by the estate’s ID.\n      GET /v1/estates/:id/map.png\n      Returns a PNG image of a map centered on a highlighted estate with the given ID.\n    \n  \n\n\nMortgages\n\nThe mortgage endpoints are all deprecated with the v2 release. Since mortgages are no longer supported in the marketplace, there’s no longer any data in this category to expose via an API or Graph query.\n\n\n  \n    \n      V1 Endpoint\n      Description\n      V2 Endpoint\n      Description\n    \n  \n  \n    \n      GET /mortgages/:address/parcels\n      Returns list of parcels with an active mortgage requested by a given Ethereum address. Deprecated\n       \n       \n    \n    \n      GET /addresses/:address/mortgages\n      Returns all mortgages requested by a given Ethereum address. Deprecated\n       \n       \n    \n    \n      GET /parcels/:x/:y/mortgages\n      Returns all mortgages requested for a given parcel. Deprecated\n       \n       \n    \n  \n\n\nparcels\n\nSome of the parcel endpoints have v2 counterparts, while others are replaced with queries to the Graph. See the chart below for details.\n\n\n  \n    \n      V1 Endpoint\n      Description\n      V2 Endpoint\n      Description\n    \n  \n  \n    \n      GET /parcels\n      Returns a list of all parcels. Deprecated.\n      See the example subgraph query below.\n       \n    \n    \n      GET /addresses/:address/parcels\n      Returns a list of all parcels belonging to a given address. Deprecated.\n      See the example subgraph query below.\n       \n    \n    \n      GET /parcels/:x/:y\n      Returns a single parcel with the given coordinates. Deprecated.\n      GET /v2/parcels/:x/:y\n      Returns metadata about a parcel with the given coordinates. This new v2 endpoint queries The Graph instead of looking at the deprecated v1 server.\n    \n    \n      GET /parcels/:tokenId\n      Returns a single parcel based on its blockchain ID (also called a token ID). Deprecated.\n      GET /v2/contracts/:address/tokens/:id\n      Returns metadata about a parcel or estate with the given contract address and token/blockchain ID.\n    \n    \n      GET /parcels/:x/:y/encodedId\n      Returns the blockchain/token ID of a parcel based on its coordinates. Deprecated\n      GET /v2/tiles?x1&amp;x2&amp;y1&amp;y2&amp;include=tokenId\n      By setting both x1 and x2 to X and y1 and y2 to Y value, and including only the tokenId property you can find the same data using the new /v2/tiles endpoint.\n    \n  \n\n\nTo list all parcels owned by one specific address, submit this query to the Graph:\n\n{\n  nfts(where:{ category: parcel, owner: \"0x...\"  }) {\n    parcel {\n      x\n      y\n    }\n  }\n}\n\n\nPublications\n\nThe publications endpoints are all replaced with corresponding queries to the Graph.\n\n\n  \n    \n      V1 Endpoint\n      Description\n      V2 Endpoint\n      Description\n    \n  \n  \n    \n      GET /parcels/:x/:y/publications\n      Returns all previous publications for a given parcel. Deprecated\n      See example subgraph query below.\n       \n    \n    \n      GET /publications/:txHash\n      Returns a specific publication based on the publication’s transaction hash. Deprecated.\n      See example subgraph query below.\n       \n    \n  \n\n\nTo list all open and non-expired orders, submit this query to the Graph:\n\n{\n  orders(where:{ status: open, expiresAt_gt: 1611082372  }) {\n    nft {\n      name\n      contractAddress\n      tokenId\n    }\n    price\n  }\n}\n\n\n\nTranslations\n\nThis is a legacy endpoint that is only used by the UI. It remains supported and unchanged with the v2 release.\n\n\n  \n    \n      V1 Endpoint\n      Description\n      V2 Endpoint\n      Description\n    \n  \n  \n    \n      GET /translations/:locale\n      Returns all available translations for a given ‘locale’ where ‘locale’ can be ‘en’, ‘es’, ‘fr’, ‘ko’, or ‘zh’.\n       \n       "
        }
        
      
    
  
    
      
        ,
        
        "development-guide-performance-optimization": {
          "id": "development-guide-performance-optimization",
          "title": "Performance Optimization",
          "categories": "development-guide",
          "url": " /development-guide/performance-optimization/",
          "content": "There are several aspects you can optimize in your scenes to ensure the best possible experience for players who visit them. This document covers some best practices that can make a big difference in how fast your scene loads and how smoothly it runs for players that are on it or on neighboring scenes.\n\nKeep in mind that many players may be visiting Decentraland using hardware that is not built for gaming, and via the browser, which limits how much of the hardware’s processing power is available to use. The experience of visiting your scene should be smooth for everyone.\n\nThe Decentraland explorer enforces many optimizations at engine level. These optimizations make a big difference, but the challenge of rendering multiple user-generated experiences simultaneously in a browser is a big one. We need your help to make things run smoothly.\n\nTiming\n\nVideo playing\n\nPlaying videos is one of the most expensive things for the engine to handle. If your scene includes videos, make sure that only ONE VideoTexture is in use at a time. You can have dozens of planes sharing the same VideoTexture without significant impact on performance, but as soon as you add a second VideoTexture, its effects on framerate become very noticeable.\n\nYou should also avoid having videos playing in regions where they can’t be seen. For example, if you have a screen indoors, toggle the video using a trigger area based on when the player walks in and out.\n\n\n  TIP: A trick several scenes have used is to stream a single video with multiple regions that are mapped differently to different planes. Each video screen uses UV mapping ) to only show a distinct part of the VideoTexture. Thanks to this, it can appear that there are separate videos playing without the cost of multiple VideoTextures.\n\n\n\n  TIP: When players are standing outside your scene, VideoTextures are not updated on every frame. This helps reduce the impact for surrounding scenes. It’s nevertheless ideal only turn on the playing of any videos when players step inside your scene ) .\n\n\nLazy loading\n\nIf your scene is large, or has indoor areas that are not always visible, you can choose to not load the entire set of entities from the very start. Instead, load the content by region as the player visits different parts of the scene. This can significantly reduce the load time of the scene, and also the amount of textures and 3d content that the engine needs to handle on every frame.\n\nFor example, the main building of a museum could load from the start, but the paintings on each floor only load for each player as they visit each floor.\n\nSee this example scene for how that might work.\n\nFor the best result in terms of avoiding hiccups, hide entities by switching their shape’s visible property to false. With this approach, you add them to the engine when creating them, but you simply don’t make their models visible.\n\nAn alternative is to not add the entities to the engine until needed. This may result in some hiccups when the entities appear for the first time, and they might also take a couple of seconds to become visible. The advantage of this approach is that it’s a valid way to get around the scene limitations). Keep in mind that the scene limitations count is for the content that is being rendered in the scene at any given time, not for the total content that could be rendered. Loading and unloading parts of the scene should allow you to work around those limitations.\n\n\n  Note: Entities that are not visible but are added to the engine do count towards the scene limitations.\n\n\nYou can also toggle animations on or off for entities that are far or occluded. For example, for an NPC that plays a very subtle idle animation, you could make it only play that animation when the player is at less than 20 meters away. Use a trigger area around the NPC and toggle its animations on or off accordingly.\n\n\n  TIP: When an entity is far away and small enough, it’s culled by the engine. This culling helps at a drawcall level, removing entities from the engine is always better. This culling also doesn’t take occlusion by other entities into account, so entities that are not so small but hidden by a wall are still rendered.\n\n\nAsync blocks\n\nBlocks of async code) are processed in a separate thread from the rest of the scene, to prevent blocking the progress of everything else.\n\nAny processes that rely on responses from asynchronous services, such as getPlayerData() or getRealmData() should always run in async blocks, as they otherwise block the rest of the scene’s loading while waiting for a response. The same applies to any calls to third party servers.\n\nNote that the scene will be considered fully loaded when everything that isn’t async is done. Async processes might still be running when the player enters the scene. Avoid situations where an async process results in the loading of an entity that could potentially get the player stuck inside of its geometry.\n\nRely on Events\n\nTry to make the scene’s logic rely on listening to events) as much as possible, instead of running checks every frame.\n\nThe update() function in a system) runs on every frame, 30 times per second (ideally). Avoid doing recurring checks if you can instead subscribe to an event.\n\nFor example, instead of constantly checking the player’s wearables, you can subscribe to the onProfileChanged event, and check the player’s wearables only when they’ve changed.\n\nIf you must use a system, avoid doing checks or adjustments on every single frame. You can include a timer as part of the update function and only run the check once per every full second, or whatever period makes sense.\n\nOptimize 3d models\n\nThere are several ways in which your 3d models can be optimized to be lighter.\n\n\n  \n    When possible, share textures across 3d models. A good practice is to use a single texture as an atlas map, shared across all models in the scene. It’s better to have 1 large shared texture of 1024x1024 pixels instead of several small ones.\n\n    \n      Note: Avoid using the same image file for both the albedo texture and the normal map or the emissive map of a material. Use separate files, even if identical. Assigning a same image file to different types of texture properties may introduce unwanted visual artifacts when compressed to asset bundles.\n    \n  \n  \n    .glb is a compressed format, it will always weigh less than a .gltf. On the other hand, with .gltf it’s easy to share texture images by exporting textures as a separate file. You can have the best of both worlds by using the following pipeline, that allows you to have .glb models with external texture files.\n  \n  \n    Avoid using blended transparencies. Blended transparencies have to bypass quite a few of the rendering optimizations. If possible, favor opaque or alpha tested geometry.\n  \n  \n    Avoid skinned meshes. They can drag down the performance significantly.\n  \n\n\n\n  TIP: Read more on 3d model best practices in the 3d Modeling Section)\n\n\nAsset Bundle conversion\n\nAbout once a day, the Decentraland content servers run a process to compress every .gltf and .glb model in every newly deployed scene to asset bundle format. This format is significantly lighter, making scenes a lot faster to load and smoother to run on the browser.\n\n\n  Tip: When planning an event in Decentraland, make sure you deploy your scene a day in advance, so that the models are all converted to asset bundles by then. If you don’t want to spoil the surprize before the event, you can deploy a version of your scene that includes all the final 3d models in the project folder, but where these are not visible or where their size is set to 0.\n\n\n\n  Note: If you make any change to a 3d model file, even if just a name change, it will be considered a new file, and must be converted to asset bundle format again.\n\n\nConnectivity\n\nIf your scene connects to any 3rd party servers or uses the messagebus) to send messages between players, there are also some things you might want to keep in mind.\n\n\n  Your scene should only have one active WebSockets connection at a time.\n  HTTP calls are funneled by the engine so that only one is handled at a time. Any additional requests are queued internally and must wait till other requests are completed. This queuing process is handled automatically, you don’t need to do anything.\n  When using the messagebus) to send messages between players, be mindful that all messages are sent to all other players in the server island. Avoid situations where an incoming message directly results in sending another message, as the number of messages can quickly grow exponentially when there’s a crowd in the scene.\n\n\nScene UI\n\nScene UIs can become costly to render when they are made up of many individual elements. Keep in mind that each UI element requires a separate drawcall on the engine.\n\n\n  TIP: Try to merge multiple elements into one single image. For example if you have a menu with multiple text elements, it’s ideal to have the text from the tiles and any additional images baked into the background image. That saves the engine from doing one additional drawcall per frame for each text element.\n\n\nAvoid making adjustments to the UI on every frame, those are especially costly and can end up getting queued. For example, if there’s a health bar in your UI that should shrink over period of time, players would probably not notice a difference between if it updates at 10 FPS instead of at 30 FPS (on every frame). The system that updates this bar can use a brief timer that counts 100 milliseconds, and only affect the UI when this timer reaches 0.\n\nAvoid having many hidden UI elements, these also have an effect on performance even if not being rendered. When possible, try to create UI components on demand.\n\nMonitor Performance\n\nThe best metric to know how well a scene is performing is the FPS (Frames Per Second). In preview, you can see the current scene FPS in the debug panel. You should aim to always have 30 FPS or more.\n\nIn the deployed scene, you can toggle the panel that shows these metrics by writing /showfps into the chat window.\n\nOne of the main bottlenecks in a scene’s performance is usually the sending of messages between the scene’s code and the engine.\n\nWhen you run a scene in preview, note that on the top-right corner it says “Y = Toggle Panel”. Hit Y on the keyboard to open a panel with some useful information that gets updated in real time.\n\nAs you interact with things that involve messages between the SDK and the engine, you’ll notice the ‘Processed Messages’ number grows. You should closely watch the ‘Pending on Queue’ number, it should always be 0 or close to 0. This tells you how many of these messages didn’t get to be processed, and got pushed to a queue. If the ‘Pending on Queue’ count starts to grow, then you’ve entered the danger zone and should think about doing more optimizations to your scene.\n\n\n  Note: Don’t keep the panel open while you’re not using it, since it has a negative impact on performance.\n\n\nKeep in mind that the performance you experience in preview may differ from that in production:\n\n\n  Surrounding neighboring scenes might have a negative impact\n  The compression of the scenes’ 3d models into asset bundles can have a positive impact\n  Some players visiting your scene may be running on less powerful hardware\n\n\nIt’s always a good practice to try deploying your scene first to the test environment) to do some more thorough testing.\n\nAlways ask players for feedback. Never take for granted that how you experience the scene is the same for everyone else."
        }
        
      
    
  
    
      
        ,
        
        "decentraland-hardware-acceleration": {
          "id": "decentraland-hardware-acceleration",
          "title": "Hardware acceleration",
          "categories": "Decentraland",
          "url": " /decentraland/hardware-acceleration/",
          "content": "Since Decentraland runs in a web browser, you might need to configure your browser and/or operating system to have access to all of your machine’s potential to run Decentraland as smoothly as possible.\n\n\n\nIf you see this warning, it means that you are using a sub-optimal set up for rendering 3d graphics. Your experience when playing Decentraland might be laggy and unresponsive because of this. You might notice missing frames as you move around in a jumpy way.\n\n\n  Note: Some lower end machines, or machines that are not designed for gaming, may not have a dedicated graphics card at all. If that’s your case, then ignore this warning. You might still be able to improve how you experience Decentraland by opening the Settings panel and lowering the graphics quality.\n\n\nContext\n\nMany machines have a dedicated graphics card, a piece of hardware that is specifically optimized for graphics processing (also called a GPU). This graphics card is not always in use, this may be done to save battery or because certain programs (like the web browser) are not expected to require heavy use of 3d graphics processing. If the dedicated graphics card is off, the integrated graphics card takes its place. This other graphics card is a lot less powerful. Unlike the dedicated graphics card, the integrated graphics card is not a separate piece of hardware, it’s integrated into the machine’s mother board.\n\nThe browser exposes settings to enable or disable the use of the dedicated graphics card, but you may also need to change settings on your operating system to make this option truly available to the browser.\n\nBrowser configuration\n\nIn Chrome or Brave:\n\n\n  Open the three dots menu, select Settings\n  Open Advanced &gt; System (or directly search for “hardware”)\n  Tick Use hardware acceleration when available\n  Restart the browser\n\n\n\n    \n\n\nOn other browsers, the steps may vary slightly, but should be essentially the same.\n\n\n  Note: If you keep seeing the warning message in Decentraland, you may also need to set up your operating system to allow the browser to access this hardware.\n\n\nOperating System configuration\n\nMac\n\nTo set up hardware acceleration:\n\n\n  Open System Preferences\n  Open Battery\n  Uncheck the box for Automatic graphics switching. This will keep the dedicated graphics card always in use when applicable.\n\n\n\n  Note: Having this option checked turns off the dedicated graphics card whenever the laptop is unplugged. Another alternative is to always keep the machine plugged to a power outlet.\n\n\nWindows\n\nTo set up hardware acceleration:\n\n\n  Right click anywhere on the desktop and select Display Options\n  Scroll down to find the Graphics Settings link\n  Under Choose an app to set preference select Chrome or your browser of choice\n  Click on the app and click Options\n  Under Set graphics preference, choose High Performance and click Save\n\n\nGNU/Linux\n\nNote: Thes following instructions are meant for using with a Chromium-based browser and an NVIDIA GPU with drivers installed.\n\nTo set up hardware acceleration:\n\n\n  Open up a terminal and run sudo prime-select on-demand then logout of your seesion and log back in.\n  Open chrome://flags in your browser and search for these flags and enable them:\n\n\n#enable-gpu-rasterization\n#enable-accelerated-video-decode\n#enable-zero-copy\n#enable-vulkan\n\n\n\n  Hit Relaunch and close your browser again.\n  To force your browser to use NVIDIA gpu; run it using terminal using these commands:\n__NV_PRIME_RENDER_OFFLOAD=1 __GLX_VENDOR_LIBRARY_NAME=nvidia brave-browser\nor\n__NV_PRIME_RENDER_OFFLOAD=1 __GLX_VENDOR_LIBRARY_NAME=nvidia google-chrome-stable"
        }
        
      
    
  
    
      
        ,
        
        "development-guide-trigger-emotes": {
          "id": "development-guide-trigger-emotes",
          "title": "Trigger emotes",
          "categories": "development-guide",
          "url": " /development-guide/trigger-emotes/",
          "content": "To make a player perform an emote, use the triggerEmote() function. Note that only existing default emotes are supported for now. This function takes a single argument:\n\n\n  emote: An emote from the PredefinedEmote enum.\n\n\nimport { triggerEmote, PredefinedEmote } from \"@decentraland/RestrictedActions\"\n\nconst emoter = new Entity()\nemoter.addComponent(new BoxShape())\nemoter.addComponent(new Transform({ position: new Vector3(8, 0, 8) }))\nemoter.addComponent(\n  new OnPointerDown(\n    (e) =&gt; {\n      triggerEmote({ predefined: PredefinedEmote.ROBOT })\n    },\n    { hoverText: \"Dance\" }\n  )\n)\n\nengine.addEntity(emoter)\n\n\nOnly the emotes in the PredefinedEmote enum are currently supported. This list includes the following:\n\n\n  ‘WAVE’\n  ‘FIST_PUMP’\n  ‘ROBOT’\n  ‘RAISE_HAND’\n  ‘CLAP’\n  ‘MONEY’\n  ‘KISS’\n  ‘TIK’\n  ‘HAMMER’,\n  ‘TEKTONIK’\n  ‘DONT_SEE’\n  ‘HANDS_AIR’\n  ‘SHRUG’\n  ‘DISCO’\n  ‘DAB’\n  ‘HEAD_EXPLODDE’\n\n\nThe emote animation is seen both by the player (in 3rd person view) and any other players around. If the player walks, runs or jumps, they will interrupt the animation and return to playing the corresponding animations for these actions.\n\n\n  Note: Players can only be animated if they already are standing inside the scene’s bounds, not if they are on a neighboring scene.\n\n\nBefore you can use this feature, you must add the ALLOW_TO_TRIGGER_AVATAR_EMOTE permission to the scene.json file. If not yet present, create a requiredPermissions property at root level in the JSON file to assign it this permission.\n\n\"requiredPermissions\": [\n    \"ALLOW_TO_TRIGGER_AVATAR_EMOTE\"\n  ],\n\n\nSee Required permissions for more details.\n\n\n  Note: To prevent abusive behavior that might damage a player’s experience, the ability to make a player perform an emote is handled as a permission. Currently, this permission has no effect in how the player experiences the scene. In the future, players who walk into a scene with this permission in the scene.json file will be requested to grant the scene the ability to play emotes on them."
        }
        
      
    
  
    
      
        ,
        
        "development-guide-avatar-modifiers": {
          "id": "development-guide-avatar-modifiers",
          "title": "Modifier Areas",
          "categories": "development-guide",
          "url": " /development-guide/avatar-modifiers/",
          "content": "Avatar Modifiers\n\nAvatars behave and look consistently throughout Decentraland as they walk across scenes. However, you can add an AvatarModifierArea to a region of your scene to affect how player avatars behave when they enter that area.\n\nPlacing Avatar Modifier Areas\n\nAdd an entity with an AvatarModifierArea component and position this entity by using a Transform component.\n\nconst modArea = new Entity()\nmodArea.addComponent(\n  new AvatarModifierArea({\n    area: { box: new Vector3(16, 4, 16) },\n    modifiers: [AvatarModifiers.HIDE_AVATARS],\n  })\n)\nmodArea.addComponent(\n  new Transform({\n    position: new Vector3(8, 0, 8),\n  })\n)\nengine.addEntity(modArea)\n\n\nWhen creating an AvatarModifierArea component, you must provide the following:\n\n\n  area: Size and shape of the modifier area\n  modifiers: An array listing the modifiers to implement in the area\n\n\nThe only currently supported shape for the area is box. Specify the scale of this box as a Vector3, for example\n{ box: new Vector3(16, 4, 16) }.\n\nThe supported modifiers are:\n\n\n  AvatarModifiers.HIDE_AVATARS\n  AvatarModifiers.DISABLE_PASSPORTS\n\n\nAll the effects of an AvatarModifierArea only take place within the region of their area. Players return to normal when they walk out of the area.\n\nAn AvatarModifierArea affects only players that are inside the area, entering the area doesn’t affect how other players that are outside the area are perceived.\n\nThe effects of an AvatarModifierArea are calculated locally for each player. You can have an AvatarModifierArea that is only present in the scene for some players and not for others. For example, if the area hides avatars, then the players that don’t have the area in their local version of the scene will see all avatars normally. Even those that experience themselves as hidden. Players that do have the area will experience themselves and all other avatars as affected by the area when they enter it.\n\n\n  Note: Avatar modifier areas are affected by the position and rotation of the Transform component of their host entity, but they’re not affected by the scale.\n\n\nHide avatars\n\nWhen a player walks into an AvatarModifierArea that has the HIDE_AVATARS modifier, the player’s avatar stops being rendered. This applies both for the player in 3rd person view, and for when other players walk into the area.\n\nconst modArea = new Entity()\nmodArea.addComponent(\n  new AvatarModifierArea({\n    area: { box: new Vector3(16, 4, 16) },\n    modifiers: [AvatarModifiers.HIDE_AVATARS],\n  })\n)\nmodArea.addComponent(\n  new Transform({\n    position: new Vector3(8, 0, 8),\n  })\n)\nengine.addEntity(modArea)\n\n\nThis allows you to replace the default Decentraland avatar with any custom avatar you might want to show in your scene. Note that if you want to see other players with custom avatars, you should handle the syncing of player positions yourself.\n\nDisable Passport Popup\n\nWhen a player walks into an AvatarModifierArea that has the DISABLE_PASSPORTS modifier, clicking on them no longer opens up the passport UI that shows the player bio, inventory, etc.\n\nconst modArea = new Entity()\nmodArea.addComponent(\n  new AvatarModifierArea({\n    area: { box: new Vector3(16, 4, 16) },\n    modifiers: [AvatarModifiers.DISABLE_PASSPORTS],\n  })\n)\nmodArea.addComponent(\n  new Transform({\n    position: new Vector3(8, 0, 8),\n  })\n)\nengine.addEntity(modArea)\n\n\nThis is especially useful in games where accidentally opening this UI could interrupt the flow of a game, for example in a multiplayer shooter game.\n\nCamera modifiers\n\nPlayers are normally free to switch between first and third person camera by pressing V on the keyboard. Use a CameraModeArea to force the camera mode to either 1st or 3rd person for all players that stand within a specific area in your scene.\n\nconst modArea = new Entity()\nmodArea.addComponent(\n  new CameraModeArea({\n    area: { box: new Vector3(16, 1, 14) },\n    cameraMode: CameraMode.FirstPerson,\n  })\n)\nmodArea.addComponent(\n  new Transform({\n    position: new Vector3(8, 0, 8),\n  })\n)\nengine.addEntity(modArea)\n\n\nIf a player’s current camera mode doesn’t match that of the CameraModeArea, they will transition to that camera mode. A toast appears onscreen to clarify that this change is due to the scene. While inside, players can’t change their camera mode. When a player leaves the CameraModeArea, their camera mode is restored to what they had before entering.\n\nUse CameraModeArea in regions where players would have a significantly better experience by using a specific camera mode. For example, first person is ideal if the player needs to click on small object, or third person may be useful for players to notice some entity that your scene has attached over their head. Don’t assume players know how to switch camera modes, many first-time players might not know they have the option, or not remember the key to do it.\n\n\n  Note: Camera modifier areas are affected by the position and rotation of the Transform component of their host entity, but they’re not affected by the scale.\n\n\n\n  Note: If you overlap multiple camera modifier areas, the last one to be instanced by your scene’s code will take priority over the others.\n\n\nWhen creating an CameraModeArea component, you must provide the following:\n\n\n  area: Size and shape of the modifier area\n  cameraMode: Which camera mode to force in this area, from the CameraMode enum.\n\n\nThe only currently supported shape for the area is box. Specify the scale of this box as a Vector3, for example\n{ box: new Vector3(16, 4, 16) }.\n\nThe supported camera modes are:\n\n\n  CameraMode.FirstPerson\n  CameraMode.ThirdPerson\n\n\nDebug modifier areas\n\nIt can be tough to know exactly what parts of the scene your modifier areas cover based on the code. Visual feedback helps a lot to confirm that they’re well placed.\n\nTo verify the positions of a AvatarModifierArea or a CameraModeArea, give the entity holding it a BoxShape component, and set the scale to the same size as the area of the modifier area.\n\n\n  Note: Modifier areas aren’t affected by the scale property of the transform, their size is based on their area property.\n\n\nconst myEntity = new Entity()\nmyEntity.addComponent(\n  new Transform({\n    position: new Vector3(8, 1, 8),\n    scale: new Vector3(8, 3, 8),\n    rotation: Quaternion.Euler(0, 30, 0),\n  })\n)\nmyEntity.addComponent(\n  new CameraModeArea({\n    area: { box: new Vector3(8, 3, 8) },\n    cameraMode: CameraMode.FirstPerson,\n  })\n)\n\nmyEntity.addComponent(new BoxShape()).withCollisions = false\nengine.addEntity(myEntity)\n\n\nTo activate the effects of the modifier area, the player’s head or torso should enter the area. It won’t take effect if only the feet of the player are covered. Make sure the player can’t easily evade the area by jumping.\n\n\n  Note: The full area should fit inside the limits of your scene."
        }
        
      
    
  
    
      
        ,
        
        "decentraland-community-voting": {
          "id": "decentraland-community-voting",
          "title": "Community Voting",
          "categories": "Decentraland",
          "url": " /decentraland/community-voting/",
          "content": "The Decentraland DAO is a fully functional Decentralized Autonomous Organization, where token holders can vote over decisions that impact on the content and future operation of the platform.\n\nBy visiting governance.decentraland.org, you can see what’s currently being decided upon, cast your votes, and even post your own proposals to be voted on by others.\n\nWhen you vote, you use your Ethereum wallet as a unique identifier.\n\nConnecting to the app\n\nIn order to vote, you must first connect to the governance app.\n\n\n  Click on the Sign In button.\n  Your browser wallet will open a pop up requiring that you sign to accept connecting your wallet to this app.\n\n\nOnce you’re connected, you can vote on any of the open proposals on the Proposals tab, or create your own proposals.\n\nVoting power\n\nThe weight of your votes depend on the voting power of your account. Each account’s voting power is determined by three sources of power.\n\n\n  Wrapped MANA: MANA that is converted to WMANA, and is temporarily held by the governance contract. For each unit of WMANA that you hold, you get one (1) voting power unit.\n  LAND parcels: 2000 voting power units per parcel.\n  Estates: 2000 voting power units per parcel in each estate.\n\n\nFor these tokens to contribute to your voting power, you need to own them in the Ethereum address you’re voting with. In the case of LAND and Estate tokens, you also need to register them for voting.\n\n\n  Note: You need to be the owner of the LAND or Estate tokens. Holding a role over them is not valid for voting.\n\n\nAny changes to your voting power are only valid for proposals that are created or that move forward after that change. If you wrap MANA to increase your voting power while a proposal is already open, voting on that proposal will only reflect the voting power you had at the time that the voting started. If the proposal then transitions to the next voting stage, you will be able to use your updated voting power on the next stage.\n\nWrapping MANA\n\nWrapped MANA, or WMANA, is not spendable while wrapped onto the governance app. To spend or transfer this WMANA freely, you need to first unwrap it back into regular MANA.\n\nTo wrap MANA:\n\n\n  Go to the Voting Power tab. There you will see your available tokens for wrapping.\n  Click Unlock MANA. Your browser wallet will then ask you to approve a transaction to enable MANA for being wrapped.\n  When that transaction is complete, you can specify how much MANA you want to wrap, and carry out another transaction to convert the MANA.\n\n\n\n  Note: Both the transaction of unlocking MANA for wrapping, and the act of wrapping the MANA require that you pay a gas fee to the Ethereum blockchain, make sure you have Ether on that account to pay for that. You must then wait for the transaction to be completed, which can take up to a couple of minutes.\n\n\nRegistering LAND and Estates\n\nLAND and Estate tokens can be registered to the DAO so that they add to your voting power. Unlike MANA, LAND and Estate tokens that you use for voting continue to be on your wallet and can still be used normally. You’re still free to deploy content to them, and any holders of operator or manager permissions retain their permissions on the land.\n\nYou can also sell a registered LAND or Estate. If the buyer of your LAND or Estate tokens wants to use these to vote for themselves, they’ll have to register them again using their own address.\n\nTo register LAND or Estates:\n\n\n  Go to the Voting Power tab. There you will see your available tokens for wrapping.\n  Click Commit LANDS or Commit Estates\n  Your browser wallet will ask you to approve a transaction to register all of the tokens of the selected type that you currently hold in your wallet.\n\n\nIf you acquire new tokens after going through this process, these new tokens won’t contribute to your voting power until you repeat the transactions to register them.\n\n\n  Note: Registering your LAND or estates is a transaction that requires that you pay a gas fee to the Ethereum blockchain, make sure you have Ether on that account to pay for that. You must then wait for the transaction to be completed, which can take up to a couple of minutes.\n\n\nBrowsing Proposals\n\nYou can browse all the current and past proposals that took place on the DAO on the Proposals tab. In this view you can filter the proposal list to only view those that are in a specific state. If a proposal is still active, you can vote on it.\n\nClick on a proposal to open its details. There you can see the amount of votes in favor and against the proposal, the remaining time it has to still be voted, the minimum thresholds it must reach to move forward to the next stage, as well as the different stages the proposal has already gone through.\n\nVoting\n\nIf you have voting power and find a proposal you care about, open its details and then click Yes or No to approve or reject it.\n\nYour browser wallet will open a pop up requiring that you accept the vote transaction.\n\n\n  Note: This transaction requires that you pay a gas fee, so make sure you have Ether on that account to pay for that.\n\n\nAs a community member, there are two stages where you’ll be able to vote for a proposal: in the Inbox stage, to help filter out proposals that don’t have minimal approval, and in the Community stage, where proposals are voted to be implemented.\n\nTo move forward to the next stage, a proposal must meet the minimum requirements of the stage. These are measured by looking at two metrics:\n\n\n  Minimum approval: Out of the total voting power distributed throughout the total supply of wrapped MANA and registered LAND and Estates, how much of that has been used to vote in approval of this proposal.\n  Support: Out of the votes that were casted for this proposal, how much voting power has been used to vote in favor of the proposal vs against it.\n\n\nVoting against a proposal affects the Support metric of the proposal, but has no effect on the Minimum Approval metric, because this metric only looks at the amount of positive votes.\n\nThe Lifecycle of a Proposal\n\nA newly created proposal goes through the following stages of revision:\n\n\n\n\n  \n    Inbox filtering: The community has seven days to view it. This phase serves as an initial filter to find proposals that the community has an interest in.\n&gt;1 % Minimum Approval and &gt;25% Support needed\n\n    After 7 days and if approved, the proposal can be Enacted to move to the next stage.\n  \n  \n    Security Advisory Board revision: The Security Advisory Board has 24 hours to review the proposal. This phase serves to protect the DAO from proposals that are badly intended or that could harm the ecosystem. At this stage, the Security Advisory Board can choose to reject or delay the proposal. This delay also serves to give community members enough time to register to vote or to wrap MANA before the vote.\n\n    After 24 hours and if not rejected or delayed, the proposal can be Executed to move to the next stage.\n  \n  \n    Community vote: Once someone executes the vote for the proposal, the community has another seven days to vote for the proposal. This phase determines if the proposal should be acted upon or not.\n20 % Minimum Approval and 66 % Support needed\n\n    After 7 days and if approved, the proposal can be Enacted so that its changes are made on-chain.\n  \n\n\nTo enact or execute a proposal:\n\n\n  Open the proposal’s details.\n  Click the Enact or Execute button. If the proposal is not ready, the button will be grayed out.\n  Your browser wallet will require that you approve a transaction\n\n\n\n  Note: Any user with or without voting power can execute or enact proposals. Both these transactions require that you pay a gas fee to the Ethereum network.\n\n\nIf a proposal gathers enough positive votes so that it’s assured to succeed, even if all of the remaining voting power were to vote against it, then it’s not necessary to wait the full duration of the stage. The same transaction for the vote that makes the proposal reach this level of approval also enacts the proposal.\n\nMiscellaneous proposals without on-chain consequences don’t need to be enacted after the final stage, they are forwarded to the Decentraland Foundation to be enacted upon by them.\n\nCreate a Proposal\n\nYou can submit your own proposal to be voted on by the community. To do this, click New Proposal and select the type of proposal:\n\n\n\n\n  Catalyst: Propose adding a server to the Catalyst network that makes up the backend of Decentraland. The servers on the Catalyst network are owned by community members and hold copies of all scenes deployed to Decentraland, serving this content to players as they explore the virtual world. These servers also handle the messaging and interactions between players.\n  Point of interest: These are highlighted locations on the Decentraland map, places where we’d like to direct players so that they don’t miss out on the best content out there.\n  Ban Name: Prevent an offensive or abusive player name from being displayed for other players to see.\n\n\nOnce a proposal has been created, it goes through the proposal lifecycle to determine if it has enough support.\n\n\n  Tip: If you intend to vote on your own proposal, remember that any changes you make to your voting power after the creation of a proposal aren’t considered when voting. Make sure that any MANA you want to wrap is already wrapped, or any LAND or Estates that you want to register are already registered before creating the proposal.\n\n\nProposals of type Catalyst, Point of interest, and Ban Name that are voted affirmatively have direct on-chain consequences, without requiring any human intervention. Proposals of type Poll are forwarded to the Decentraland Foundation for enacting them.\n\nAbout The Security Advisory Board\n\nA body known as the Security Advisory Board (SAB) safeguards some of the most advanced behind-the-scenes functionality that Aragon – the software that powers the DAO – has to offer for the benefit of the community.\n\nThe SAB has the following structure:\n\n\n  Five members, who can be voted in and out by DAO vote\n  Full consensus is required for contract upgrades. This means that if any one of the five members decides to vote against an upgrade, the four remaining members can’t force a change on the smart contract.\n  SAB members can install new applications to the DAO and can add or remove permissions of applications.\n\n\nWhen a proposal makes it past the Inbox stage, the members of the SAB have one day to review it before it makes its way forward to the Community stage. The members of the council are tasked not with voting based on personal preference, but only against things they consider harmful."
        }
        
      
    
  
    
      
        ,
        
        "development-guide-move-player": {
          "id": "development-guide-move-player",
          "title": "Move a player",
          "categories": "development-guide",
          "url": " /development-guide/move-player/",
          "content": "To change the player’s position in the scene, use the movePlayerTo() function. This function takes two arguments:\n\n\n  position: Where to move the player, expressed as an object with x, y, and z properties.\n  cameraTarget: (optional) What direction to make the player face, expressed as an object with x, y, and z properties that represent the coordinates of a point in space to stare at. If no value is provided, the player will maintain the same rotation as before moving.\n\n\nimport { movePlayerTo } from '@decentraland/RestrictedActions'\nconst respawner = new Entity()\nrespawner.addComponent(new BoxShape())\nrespawner.addComponent(new Transform({ position: new Vector3(8, 0, 8) }))\nrespawner.addComponent(\n  new OnPointerDown(\n    (e) =&gt; {\n      movePlayerTo({ x: 1, y: 0, z: 1 }, { x: 8, y: 1, z: 8 })\n    },\n    { hoverText: \"Move player\" }\n  )\n)\n\nengine.addEntity(respawner)\n\n\nThe player’s movement occurs instantly, without any confirmation screens or camera transitions.\n\n\n  Note: Players can only be moved if they already are standing inside the scene’s bounds, and can only be moved to locations that are inside the limits of the scene’s bounds. You can’t use movePlayerTo() to transport a player to another scene. To move a player to another scene, see Teleports.\n\n\nYou must first add the ALLOW_TO_MOVE_PLAYER_INSIDE_SCENE permission to the scene.json file before you can use this feature. If not yet present, create a requiredPermissions property at root level in the JSON file to assign it this permission.\n\n\"requiredPermissions\": [\n    \"ALLOW_TO_MOVE_PLAYER_INSIDE_SCENE\"\n  ],\n\n\nSee Required permissions for more details.\n\n\n  Note: To prevent abusive behavior that might damage a player’s experience, the ability to move a player is handled as a permission. Currently, this permission has no effect in how the player experiences the scene. In the future, players who walk into a scene with this permission in the scene.json file will be requested to grant the scene the ability to move them."
        }
        
      
    
  
    
      
        ,
        
        "development-guide-utils": {
          "id": "development-guide-utils",
          "title": "Utils library",
          "categories": "development-guide",
          "url": " /development-guide/utils/",
          "content": "The Decentraland ECS Utils library includes a number of helpful pre-built tools that include components, methods, and systems. They offer simple solutions to common scenarios that you’re likely to run into while building scenes.\n\n\n  Gradual Movement\n    \n      Move an entity\n      Follow a path\n      Follow a curved path\n      Rotate an entity\n      Sustain rotation\n      Change scale\n      Non-linear changes\n      Callback on finish\n    \n  \n  Toggle\n  Time\n    \n      Delay a function\n      Delay removing an entity\n      Repeat at an Interval\n    \n  \n  Triggers\n    \n      Trigger Component\n      Trigger layers\n    \n  \n  Conversions\n    \n      clamp\n      map\n      world position\n      world rotation\n    \n  \n  Send requests\n  Labels\n  Debug helpers\n    \n      Debug cube\n    \n  \n  Action sequence\n    \n      IAction\n      Action Sequence Builder\n      Action Sequence System\n      Full example\n    \n  \n\n\nUsing the Utils library\n\nTo use any of the helpers provided by the utils library\n\n\n  Install it as an npm package. Run this command in your scene’s project folder:\n\n\nnpm install @dcl/ecs-scene-utils -B\n\n\n\n  Run dcl start or dcl build so the dependencies are correctly installed.\n\n\n3) Import the library into the scene’s script. Add this line at the start of your game.ts file, or any other TypeScript files that require it:\n\nimport * as utils from '@dcl/ecs-scene-utils'\n\n\n\n  In your TypeScript file, write utils. and let the suggestions of your IDE show the available helpers.\n\n\nGradual Movement\n\nMove an entity\n\nTo move an entity over a period of time, from one position to another, use the MoveTransformComponent component.\n\nMoveTransformComponent has three required arguments:\n\n\n  start: Vector3 for the start position\n  end: Vector3 for the end position\n  duration: duration (in seconds) of the translation\n\n\nThis example moves an entity from one position to another over 2 seconds:\n\nimport * as utils from '@dcl/ecs-scene-utils'\n\n// Create entity\nconst box = new Entity()\n\n// Give entity a shape and transform\nbox.addComponent(new BoxShape())\nbox.addComponent(new Transform())\n\n//Define start and end positions\nlet StartPos = new Vector3(1, 1, 1)\nlet EndPos = new Vector3(15, 1, 15)\n\n// Move entity\nbox.addComponent(new utils.MoveTransformComponent(StartPos, EndPos, 2))\n\n// Add entity to engine\nengine.addEntity(box)\n\n\nFollow a path\n\nTo move an entity over several points of a path over a period of time, use the FollowPathComponent component.\n\nFollowPathComponent has two required arguments:\n\n\n  points: An array of Vector3 positions that form the path.\n  duration: The duration (in seconds) of the whole path.\n\n\nThis example moves an entity over through four points over 5 seconds:\n\nimport * as utils from '@dcl/ecs-scene-utils'\n\n// Create entity\nconst box = new Entity()\n\n// Give entity a shape and transform\nbox.addComponent(new BoxShape())\nbox.addComponent(new Transform())\n\n//Define the positions of the path\nlet path = []\npath[0] = new Vector3(1, 1, 1)\npath[1] = new Vector3(1, 1, 15)\npath[2] = new Vector3(15, 1, 15)\npath[3] = new Vector3(15, 1, 1)\n\n// Move entity\nbox.addComponent(new utils.FollowPathComponent(path, 2))\n\n// Add entity to engine\nengine.addEntity(box)\n\n\nFollow a curved path\n\nTo move an entity following a curved path over a period of time, use the FollowCurvedPathComponent component.\n\nThe curved path is composed of multiple straight line segments put together. You only need to supply a series of fixed path points and a smooth curve is drawn to pass through all of these.\n\nFollowCurvedPathComponent has three required arguments:\n\n\n  points: An array of Vector3 positions that the curve must pass through.\n  duration: The duration (in seconds) of the whole path.\n  numberOfSegments: How many straight-line segments to use to construct the curve.\n\n\n\n  Tip: Each segment takes at least one frame to complete. Avoid using more than 30 segments per second in the duration of the path, or the entity will move significantly slower while it stops for each segment.\n\n\nThis example moves an entity over through a curve that’s subdivided into 40 segments, over a period of 5 seconds. The curve passes through four key points.\n\nimport * as utils from '@dcl/ecs-scene-utils'\n\n// Create entity\nconst box = new Entity()\n\n// Give entity a shape and transform\nbox.addComponent(new BoxShape())\nbox.addComponent(new Transform())\n\n//Define the positions of the path\nlet path = []\npath[0] = new Vector3(1, 1, 1)\npath[1] = new Vector3(1, 1, 15)\npath[2] = new Vector3(15, 1, 15)\npath[3] = new Vector3(15, 1, 1)\n\n// Move entity\nbox.addComponent(new utils.FollowCurvedPathComponent(path, 5, 40))\n\n// Add entity to engine\nengine.addEntity(box)\n\n\nThe FollowCurvedPathComponent also lets you set:\n\n\n  turnToFaceNext: If true, the entity will rotate on each segment of the curve to always face forward.\n  closedCircle: If true, traces a circle that starts back at the beginning, keeping the curvature rounded in the seams too\n\n\nRotate an entity\n\nTo rotate an entity over a period of time, from one direction to another, use the rotateTransformComponent component, which works very similarly to the MoveTransformComponent component.\n\nrotateTransformComponent has three required arguments:\n\n\n  start: Quaternion for the start rotation\n  end: Quaternion for the end rotation\n  duration: duration (in seconds) of the rotation\n\n\nThis example rotates an entity from one rotation to another over 2 seconds:\n\nimport * as utils from '@dcl/ecs-scene-utils'\n\n// Create entity\nconst box = new Entity()\n\n// Give entity a shape and transform\nbox.addComponent(new BoxShape())\nbox.addComponent(new Transform())\n\n//Define start and end directions\nlet StartRot = Quaternion.Euler(90, 0, 0)\nlet EndRot = Quaternion.Euler(270, 0, 0)\n\n// Rotate entity\nbox.addComponent(new utils.RotateTransformComponent(StartRot, EndRot, 2))\n\n// Add entity to engine\nengine.addEntity(box)\n\n\nSustain rotation\n\nTo rotates an entity continuously, use KeepRotatingComponent. The entity will keep rotating forever until it’s explicitly stopped or the component is removed.\n\nKeepRotatingComponent has one required argument:\n\n\n  rotationVelocity: A quaternion describing the desired rotation to perform each second second. For example Quaternion.Euler(0, 45, 0) rotates the entity on the Y axis at a speed of 45 degrees per second, meaning that it makes a full turn every 8 seconds.\n\n\nThe component also contains the following method:\n\n\n  stop(): stops rotation and removes the component from any entities its added to.\n\n\nIn the following example, a cube rotates continuously until clicked:\n\nimport * as utils from '@dcl/ecs-scene-utils'\n\n// Create entity\nconst box = new Entity()\n\n// Give entity a shape and transform\nbox.addComponent(new BoxShape())\nbox.addComponent(new Transform({ position: new Vector3(1, 1, 1) }))\n\n// Rotate entity\nbox.addComponent(new utils.KeepRotatingComponent(Quaternion.Euler(0, 45, 0)))\n\n// Listen for click\nbox.addComponent(\n  new OnClick(() =&gt; {\n    box.getComponent(utils.KeepRotatingComponent).stop()\n  })\n)\n\n// Add entity to engine\nengine.addEntity(box)\n\n\nChange scale\n\nTo adjust the scale of an entity over a period of time, from one size to another, use the ScaleTransformComponent component, which works very similarly to the MoveTransformComponent component.\n\nScaleTransformComponent has three required arguments:\n\n\n  start: Vector3 for the start scale\n  end: Vector3 for the end scale\n  duration: duration (in seconds) of the scaling\n\n\nThis example scales an entity from one size to another over 2 seconds:\n\nimport * as utils from '@dcl/ecs-scene-utils'\n\n// Create entity\nconst box = new Entity()\n\n// Give entity a shape and transform\nbox.addComponent(new BoxShape())\nbox.addComponent(new Transform())\n\n//Define start and end positions\nlet StartSize = new Vector3(1, 1, 1)\nlet EndSize = new Vector3(0.75, 2, 0.75)\n\n// Move entity\nbox.addComponent(new utils.ScaleTransformComponent(StartSize, EndSize, 2))\n\n// Add entity to engine\nengine.addEntity(box)\n\n\nNon-linear changes\n\nAll of the translation components, the MoveTransformComponent, rotateTransformComponent, ScaleTransformComponent, and FollowPathComponent have an optional argument to set the rate of change. By default, the movement, rotation, or scaling occurs at a linear rate, but this can be set to other options.\n\nThe following values are accepted:\n\n\n  Interpolation.LINEAR\n  Interpolation.EASEINQUAD\n  Interpolation.EASEOUTQUAD\n  Interpolation.EASEQUAD\n\n\nThe following example moves a box following an ease-in rate:\n\nbox.addComponent(\n  new utils.MoveTransformComponent(\n    StartPos,\n    EndPos,\n    2,\n    null,\n    utils.InterpolationType.EASEINQUAD\n  )\n)\n\n\nCallback on finish\n\nAll of the translation components, the MoveTransformComponent, rotateTransformComponent, ScaleTransformComponent, FollowPathComponent, and FollowCurvedPathComponent have an optional argument that executes a function when the translation is complete.\n\n\n  onFinishCallback: function to execute when movement is done.\n\n\nThe following example logs a message when the box finishes its movement. The example uses MoveTransformComponent, but the same applies to rotateTransformComponent and ScaleTransformComponent.\n\nbox.addComponent(\n  new utils.MoveTransformComponent(StartPos, EndPos, 2, () =&gt; {\n    log('finished moving box')\n  })\n)\n\n\nThe FollowPathComponent has a two optional arguments that execute functions when a section of the path is complete and when the whole path is complete.\n\n\n  \n    onFinishCallback: function to execute when movement is complete.\n  \n  \n    onPointReachedCallback: function to execute when each section of the path is done.\n  \n\n\nThe following example logs a messages when the box finishes each segment of the path, and another when the entire path is done.\n\nbox.addComponent(\n  new utils.FollowPathComponent(\n    path,\n    2,\n    () =&gt; {\n      log('finished moving box')\n    },\n    () =&gt; {\n      log('finished a segment of the path')\n    }\n  )\n)\n\n\nToggle\n\nUse the ToggleComponent to switch an entity between two possible states, running a same function on every transition.\n\nThe ToggleComponent has the following arguments:\n\n\n  startingState: Starting state of the toggle (ON or OFF)\n  onValueChangedCallback: Function to call every time the toggle state changed.\n\n\nIt exposes three methods:\n\n\n  toggle(): switches the state of the component between ON and OFF\n  isOn(): reads the current state of the component, without altering it. It returns a boolean, where true means ON.\n  setCallback(): allows you to change the function to be executed by onValueChangedCallback, for the next time it’s toggled.\n\n\nThe following example switches the color of a box between two colors each time it’s clicked.\n\nimport * as utils from '@dcl/ecs-scene-utils'\n\n// Create entity\nconst box = new Entity()\n\n// Give entity a shape and transform\nbox.addComponent(new BoxShape())\nbox.addComponent(new Transform())\n\n//Define two different materials\nlet greenMaterial = new Material()\ngreenMaterial.albedoColor = Color3.Green()\nlet redMaterial = new Material()\nredMaterial.albedoColor = Color3.Red()\n\n// Add a Toggle component\nbox.addComponent(\n  new utils.ToggleComponent(utils.ToggleState.Off, value =&gt; {\n    if (value == utils.ToggleState.On) {\n      //set color to green\n      box.addComponentOrReplace(greenMaterial)\n    } else {\n      //set color to red\n      box.addComponentOrReplace(redMaterial)\n    }\n  })\n)\n\n//listen for click on the box and toggle it's state\nbox.addComponent(\n  new OnClick(event =&gt; {\n    box.getComponent(utils.ToggleComponent).toggle()\n  })\n)\n\n// Add entity to engine\nengine.addEntity(box)\n\n\nCombine Toggle with Translate\n\nThis example combines a toggle component with a move component to switch an entity between two positions every time it’s clicked.\n\nimport * as utils from '@dcl/ecs-scene-utils'\n\n// Create entity\nconst box = new Entity()\n\n// Give entity a shape and transform\nbox.addComponent(new BoxShape())\nbox.addComponent(new Transform())\n\n//Define two positions for toggling\nlet Pos1 = new Vector3(1, 1, 1)\nlet Pos2 = new Vector3(1, 1, 2)\n\n//toggle for wine bottle\nbox.addComponent(\n  new utils.ToggleComponent(utils.ToggleState.Off, value =&gt; {\n    if (value == utils.ToggleState.On) {\n      box.addComponentOrReplace(\n        new utils.MoveTransformComponent(Pos1, Pos2, 0.5)\n      )\n    } else {\n      box.addComponentOrReplace(\n        new utils.MoveTransformComponent(Pos2, Pos1, 0.5)\n      )\n    }\n  })\n)\n\n//listen for click on the box and toggle it's state\nbox.addComponent(\n  new OnClick(event =&gt; {\n    box.getComponent(utils.ToggleComponent).toggle()\n  })\n)\n\n// Add entity to engine\nengine.addEntity(box)\n\n\nTime\n\nThese tools are all related to the passage of time in the scene.\n\nDelay a function\n\nAdd a Delay component to an entity to execute a function only after an n amount of milliseconds.\n\nThis example creates an entity that only becomes visible in the scene after 100000 milliseconds (100 seconds) have passed.\n\nimport * as utils from '@dcl/ecs-scene-utils'\n\n// create entity\nconst easterEgg = new Entity()\n\n// give entity a shape and set invisible\nconst easterEggShape = new BoxShape()\neasterEggShape.visible = false\neasterEgg.addComponent(easterEggShape)\n\n// add a delayed function\neasterEgg.addComponent(\n  new utils.Delay(100000, () =&gt; {\n    easterEgg.getComponent(BoxShape).visible = true\n  })\n)\n\n// add entity to scene\nengine.addEntity(easterEgg)\n\n\nTo delay the execution of a task that isn’t directly tied to any entity in the scene, create a dummy entity that only holds a Delay component.\n\nDelay removing an entity\n\nAdd an ExpireIn component to an entity to remove it from the scene after an n amount of milliseconds.\n\nThis example creates an entity that is removed from the scene 500 milliseconds after it’s clicked.\n\nimport * as utils from '@dcl/ecs-scene-utils'\n\n// create entity\nconst box = new Entity()\n\n// give entity a shape\nbox.addComponent(new BoxShape())\n\n// add a function to run when clicked\nbox.addComponent(\n  new OnClick(() =&gt; {\n    box.addComponent(new utils.ExpireIn(500))\n  })\n)\n\n// add entity to scene\nengine.addEntity(box)\n\n\nRepeat at an Interval\n\nAdd an Interval component to an entity to make it execute a same function every n milliseconds.\n\nThis example creates an entity that changes its scale to a random size every 500 milliseconds.\n\nimport * as utils from '@dcl/ecs-scene-utils'\n\n// create entity\nconst box = new Entity()\n\n// give entity a shape and transform\nbox.addComponent(new BoxShape())\nbox.addComponent(new Transform())\n\n// add a repeated function\nbox.addComponent(\n  new utils.Interval(500, () =&gt; {\n    let randomSize = Math.random()\n    box.getComponent(Transform).scale.setAll(randomSize)\n  })\n)\n\n// add entity to scene\nengine.addEntity(box)\n\n\nTo repeat the execution of a task that isn’t directly tied to any entity in the scene, create a dummy entity that only holds an Interval component.\n\nTriggers\n\nTrigger Component\n\nThe trigger component can execute whatever you want whenever the player’s position or the position of a specific entity or type of entity overlaps with an area.\n\nThe TriggerComponent has the following arguments:\n\n\n  shape: Shape of the triggering collider area, either a cube or a sphere (TriggerBoxShape or TriggerSphereShape)\n  data: An object of type TriggerData containing several optional parameters to configure the behavior of the trigger area.\n\n\nThe TriggerData type may contain the following parameters:\n\n\n  onCameraEnter: Callback function for when the player enters the trigger area\n  onCameraExit: Callback function for when the player leaves the trigger area\n  layer: Layer of the Trigger, useful to discriminate between trigger events. You can set multiple layers by using a | symbol.\n  triggeredByLayer: Against which layers to check collisions\n  onTriggerEnter: Callback when an entity of a valid layer enters the trigger area\n  onTriggerExit: Callback function for when an entity of a valid layer leaves the trigger area\n  enableDebug: When true, makes the trigger area visible for debug purposes. Only visible when running a preview locally, not in production.\n\n\nThe following example creates a trigger that changes its position randomly when triggered by the player.\n\nimport * as utils from '@dcl/ecs-scene-utils'\n\n//create entity\nconst box = new Entity()\n\n//create shape for entity and disable its collision\nbox.addComponent(new BoxShape())\nbox.getComponent(BoxShape).withCollisions = false\n\n//set transform component with initial position\nbox.addComponent(new Transform({ position: new Vector3(2, 1, 2) }))\n\n// create trigger area object, setting size and relative position\nlet triggerBox = new utils.TriggerBoxShape()\n\n//create trigger for entity\nbox.addComponent(\n  new utils.TriggerComponent(\n    triggerBox, //shape\n    {\n      onCameraEnter : () =&gt; {\n\t  log('triggered!')\n\t  box.getComponent(Transform).position = new Vector3(\n\t\t1 + Math.random() * 14,\n\t\t0,\n\t\t1 + Math.random() * 14\n\t        )\n      }\n    }\n  )\n)\n\n//add entity to engine\nengine.addEntity(box)\n\n\n\n  Note: The trigger shape can be positioned or stretched, but it can’t be rotated on any axis. This is a design decision taken for performance reasons. To cover a slanted area, we recommend adding multiple triggers if applicable.\n\n\nEach trigger area has a shape for its area to check for collisions, which is completely independent of the visible shape of the entity. The shape of the area can either be determined by a TriggerBoxShape or a TriggerSphereShape. When instancing these, can set the scale and an offset position. By default, the trigger shape starts in the same position as the entity that has the TriggerComponent.\n\nYou can check where exactly the trigger area is and its scale by setting the enableDebug flag to true. You will then see this shape in the scene when running a preview. This debug shape is only visible in the context of a preview, not once the scene is deployed.\n\nDissable a collision component\n\nTriggerComponent components have an enabled property, which is set to true by default when creating it. You can use this property to disable the behavior of the component without removing it.\n\nbox.getComponent(utils.TriggerComponent).enabled = false\n\n\nSet a custom shape for player\n\nYou can optionally configure a custom shape and size for the player’s trigger area, according to your needs:\n\nutils.TriggerSystem.instance.setCameraTriggerShape(\n  new utils.TriggerBoxShape(\n    new Vector3(0.5, 1.8, 0.5),\n    new Vector3(0, -0.91, 0)\n  )\n)\n\n\nChanging this configuration affects the behavior of all onCameraEnter and onCameraExit functions of all TriggerComponents in the scene.\n\nTrigger layers\n\nYou can define different layers (bitwise) for triggers, and set which other layers can trigger it.\n\nThe following example creates a scene that has:\n\n\n  food (cones)\n  mice (spheres)\n  cats (boxes)\n\n\nFood is triggered (or eaten) by both cats or mice. Also, mice are eaten by cats, so a mouse’s trigger area is triggered by only cats.\n\nCats and mice always move towards the food. When food or mice are eaten, they respawn in a random location.\n\nimport * as utils from '@dcl/ecs-scene-utils'\n\n//define layers\nconst foodLayer = 1\nconst mouseLayer = 2\nconst catLayer = 4\n\n//define a reusable collision shape object\nlet triggerBox = new utils.TriggerBoxShape(Vector3.One(), Vector3.Zero())\n\n//create food\nconst food = new Entity()\nfood.addComponent(new ConeShape())\nfood.getComponent(ConeShape).withCollisions = false\nfood.addComponent(\n  new Transform({\n    position: new Vector3(1 + Math.random() * 14, 0, 1 + Math.random() * 14)\n  })\n)\nfood.addComponent(new utils.TriggerComponent(\n  triggerBox,\n  {\n\tlayer: foodLayer\n\ttriggeredByLayer: mouseLayer | catLayer\n\tonTriggerEnter: () =&gt; {\n\t  food.getComponent(Transform).position = new Vector3(\n\t    1 + Math.random() * 14,\n\t    0,\n\t    1 + Math.random() * 14\n\t  )\n\t  mouse.addComponentOrReplace(\n\t    new utils.MoveTransformComponent(\n\t\tmouse.getComponent(Transform).position,\n\t\tfood.getComponent(Transform).position,\n\t\t4\n\t    )\n\t  )\n\t  cat.addComponentOrReplace(\n\t    new utils.MoveTransformComponent(\n\t\tcat.getComponent(Transform).position,\n\t\tfood.getComponent(Transform).position,\n\t\t4\n\t    )\n\t )\n       }\n  }\n))\n\n//create mouse\nconst mouse = new Entity()\nmouse.addComponent(new SphereShape())\nmouse.getComponent(SphereShape).withCollisions = false\nmouse.addComponent(\n  new Transform({\n    position: new Vector3(1 + Math.random() * 14, 0, 1 + Math.random() * 14),\n    scale: new Vector3(0.5, 0.5, 0.5)\n  })\n)\nmouse.addComponent(new utils.TriggerComponent(\n  triggerBox,\n  {\n\tlayer: mouseLayer\n\ttriggeredByLayer: catLayer\n\tonTriggerEnter: () =&gt; {\n\t  mouse.getComponent(Transform).position = new Vector3(\n\t    1 + Math.random() * 14,\n\t    0,\n\t    1 + Math.random() * 14\n\t  )\n\t  mouse.addComponentOrReplace(\n\t    new utils.MoveTransformComponent(\n\t      mouse.getComponent(Transform).position,\n\t      food.getComponent(Transform).position,\n\t      4\n\t    )\n          )\n        }\n  }\n))\n\n//create cat\nconst cat = new Entity()\ncat.addComponent(new BoxShape())\ncat.getComponent(BoxShape).withCollisions = false\ncat.addComponent(\n  new Transform({\n    position: new Vector3(1 + Math.random() * 14, 0, 1 + Math.random() * 14)\n  })\n)\ncat.addComponent(new utils.TriggerComponen(\n\ttriggerBox,\n\t{\n\t\tlayer: catLayer\n\t}\n))\n\n//set initial movement for mouse and cat\nmouse.addComponentOrReplace(\n  new utils.MoveTransformComponent(\n    mouse.getComponent(Transform).position,\n    food.getComponent(Transform).position,\n    4\n  )\n)\ncat.addComponentOrReplace(\n  new utils.MoveTransformComponent(\n    cat.getComponent(Transform).position,\n    food.getComponent(Transform).position,\n    4\n  )\n)\n\n//add entities to engine\nengine.addEntity(food)\nengine.addEntity(mouse)\nengine.addEntity(cat)\n\n\nConversions\n\nThis library includes a number of helpful functions for common value conversions.\n\nClamp\n\nUse the clamp() function to easily clamp possible values between a maximum and a minimum.\n\nThe clamp() function takes the following arguments:\n\n\n  value: Input number to convert\n  min: Minimum output value.\n  max: Maximum output value.\n\n\nThe following example limits an incoming value between 5 and 15. If the incoming value is less than 5, it will output 5. If the incoming value is more than 15, it will output 15.\n\nlet input = 200\nlet result = utils.clamp(input, 5, 15)\nlog(result)\n\n\nMap\n\nUse the map() function to map a value from one range of values to its equivalent, scaled in proportion to another range of values, using maximum and minimum.\n\nThe map() function takes the following arguments:\n\n\n  value: Input number to convert\n  min1: Minimum value in the range of the input.\n  max1: Maximum value in the range of the input.\n  min2: Minimum value in the range of the output.\n  max2: Maximum value in the range of the output.\n\n\nThe following example maps the value 5 from a scale of 0 to 10 to a scale of 300 to 400. The resulting value is 350, as it keeps the same proportion relative to the new maximum and minimum values.\n\nlet input = 5\nlet result = utils.map(input, 0, 10, 300, 400)\nlog(result)\n\n\nWorld position\n\nIf an entity is parented to another entity, or to the player, then its Transform position will be relative to its parent. To find what its global position is, taking into account any parents, use getEntityWorldPosition().\n\nThe getEntityWorldPosition() function takes a single argument:\n\n\n  entity: The entity from which to get the global position\n\n\nThe function returns a Vector3 object, with the resulting position of adding the given entity and all its chain of parents.\n\nThe following example sets a cube as a child of the player, and logs its true position when clicked.\n\nconst cube = new Entity()\ncube.addComponent(new Transform({ position: new Vector3(0, 0, 1) }))cube.addComponent(new BoxShape())\nengine.addEntity(cube)\ncube.setParent(Attachable.FIRST_PERSON_CAMERA)\n\ncube.addComponent(\n  new OnPointerDown(() =&gt; {\n\tlog(getEntityWorldRotation(myCube))\n  }))\n\n\nWorld rotation\n\nIf an entity is parented to another entity, or to the player, then its Transform rotation will be relative to its parent. To find what its global rotation is, taking into account any parents, use getEntityWorldRotation().\n\nThe getEntityWorldRotation() function takes a single argument:\n\n\n  entity: The entity from which to get the global rotation\n\n\nThe function returns a Quaternion object, with the resulting rotation of multiplying the given entity to all its chain of parents.\n\nThe following example sets a cube as a child of the player, and logs its true rotation when clicked.\n\nconst cube = new Entity()\ncube.addComponent(new Transform({ position: new Vector3(0, 0, 1) }))cube.addComponent(new BoxShape())\nengine.addEntity(cube)\ncube.setParent(Attachable.FIRST_PERSON_CAMERA)\n\ncube.addComponent(\n  new OnPointerDown(() =&gt; {\n\tlog(getEntityWorldRotation(myCube))\n  }))\n\n\nSend requests\n\nUse the sendRequest() function to easily send HTTP requests to APIs.\n\nThe sendRequest() function has a single required argument:\n\n\n  url: The URL to send the request\n\n\nasync function request() {\n  let response = await utils.sendRequest(\n    'https://events.decentraland.org/api/events/?limit=5'\n  )\n\n  log(response)\n}\n\n\n\n  NOTE: The sendRequest() function is asynchronous, since it must wait for the external server to respond back before it can return a response. If you need your code to access the data on the request’s response, you must use the sendRequest() within an async block of code, and add an await to the function.\n\n\nThe sendRequest() function also lets you use the following arguments, for sending more advanced requests:\n\n\n  method: The HTTP method to use. GET is the default, other common options are POST, PUT, and DELETE.\n  headers: The HTTP headers of the request, as a JSON object.\n  body: The body of the request, as a JSON object.\n\n\nasync function request() {\n  let response = await utils.sendRequest(\n  \t'https://jsonplaceholder.typicode.com/posts',\n    'POST',\n    {\n      'content-type': 'application/json',\n    },\n    {\n      content: 'My test JSON',\n    }\n}\n\n\nLabels\n\nAdd a text label floating over an entity using addLabel().\n\nThe addLabel() function has just two required arguments:\n\n\n  text: The string of text to display\n  parent: The entity to set the label on\n\n\nconst cube = new Entity()\ncube.addComponent(new Transform({ position: new Vector3(8, 1, 8) }))\ncube.addComponent(new BoxShape())\nengine.addEntity(cube)\n\nutils.addLabel('Random Cube', cube)\n\n\nThe addLabel() function also lets you set the following:\n\n\n  billboard: If true, label turns to always face player. True by default.\n  color: Text color. Black by default.\n  size: Text font size, 3 by default.\n  textOffset: Offset from parent entity’s position. By default 1.5 meters above the parent.\n\n\n\n  Tip: The addLabel() function returns the created entity used for the text. You can then tweak this entity in any way you choose.\n\n\nDebug helpers\n\nDebug cube\n\nRender a simple clickable cube to use as a trigger when debugging a scene with addTestCube().\n\n\n  NOTE: The test cube is only shown in preview, unless configured to appear also in production.\n\n\nThe addTestCube() function has just two required arguments:\n\n\n  pos: The position, rotation and/or scale of the cube, expressed as a TransformConstructorArgs object, as gets passed when creating a Transform component.\n  triggeredFunction: A function that gets called every time the cube is clicked.\n\n\nutils.addTestCube({ position: new Vector3(2, 1, 2) }, () =&gt; {\n  log('Cube clicked')\n})\n\n\nThe addTestCube() function also lets you set the following:\n\n\n  label: An optional label to display floating over the cube\n  color: A color for the cube’s material.\n  sphere: If true, it renders as a Sphere instead of a cube.\n  noCollider: If true, the cube won’t have a collider and will let players walk through it.\n  keepInProduction: If true, it will be visible for players in-world once the scene is deployed. Otherwise, the cube is only present when previewing he scene locally.\n\n\n\n  Tip: The addTestCube() function returns the created entity for the cube. You can then tweak this entity in any way you choose. addTestCube() is an async function (because the function first checks if you’re in preview or in production). If you need the function to return the cube (instead of a promise of a cube) use it inside an async block of code with an await on the addTestCube() function.\n\n\nasync function addMyCube() {\n  myCube = await utils.addTestCube({ position: new Vector3(0, 0, 1) }, () =&gt; {\n    log('Cube clicked')\n  })\n}\n\n\nAction sequence\n\nUse an action sequence to play a series of actions one after another.\n\nIAction\n\nThe IAction interface defines the actions that can be added into a sequence. It includes:\n\n\n  hasFinished: Boolean for the state of the action, wether it has finished its execution or not.\n  onStart(): First method that is called upon the execution of the action.\n  update(): Called on every frame on the action’s internal update.\n  onFinish(): Called when the action has finished executing.\n\n\nAction Sequence Builder\n\nThis object creates action sequences, using simple building blocks.\n\nThe SequenceBuilder exposes the following methods:\n\n\n  then(): Enqueue an action so that it’s executed when the previous one finishes.\n  if(): Use a condition to branch the sequence\n  else(): Used with if() to create an alternative branch\n  endIf(): Ends the definition of the conditional block\n  while(): Keep running the actions defined in a block until a condition is no longer met.\n  breakWhile(): Ends the definition of the while block\n\n\nAction Sequence System\n\nThe action sequence system takes care of running the sequence of actions. The ActionsSequenceSystem exposes the following methods:\n\n\n  startSequence(): Starts a sequence of actions\n  setOnFinishCallback(): Sets a callback for when the whole sequence is finished\n  isRunning(): Returns a boolean that determines if the sequence is running\n  stop(): Stops a running the sequence\n  resume(): Resumes a stopped sequence\n  reset(): Resets a sequence so that it starts over\n\n\nFull example\n\nThe following example creates a box that changes its scale until clicked. Then it resets its scale and moves.\n\nimport * as utils from '@dcl/ecs-scene-utils'\n\n//set clicked flag\nlet boxClicked = false\n\n//create box entity\nconst box = new Entity()\nbox.addComponent(new BoxShape())\nbox.addComponent(new Transform({ position: new Vector3(14, 0, 14) }))\nbox.addComponent(new OnClick(() =&gt; (boxClicked = true)))\nengine.addEntity(box)\n\n//Use IAction to define action for scaling\nclass ScaleAction implements utils.ActionsSequenceSystem.IAction {\n  hasFinished: boolean = false\n  entity: Entity\n  scale: Vector3\n\n  constructor(entity: Entity, scale: Vector3) {\n    this.entity = entity\n    this.scale = scale\n  }\n\n  //Method when action starts\n  onStart(): void {\n    const transform = this.entity.getComponent(Transform)\n    this.hasFinished = false\n\n    this.entity.addComponentOrReplace(\n      new utils.ScaleTransformComponent(\n        transform.scale,\n        this.scale,\n        1.5,\n        () =&gt; {\n          this.hasFinished = true\n        },\n        utils.InterpolationType.EASEINQUAD\n      )\n    )\n  }\n  //Method to run on every frame\n  update(dt: number): void {}\n  //Method to run at the end\n  onFinish(): void {}\n}\n\n//Use IAction to define action for movement\nclass MoveAction implements utils.ActionsSequenceSystem.IAction {\n  hasFinished: boolean = false\n  entity: Entity\n  position: Vector3\n\n  constructor(entity: Entity, position: Vector3) {\n    this.entity = entity\n    this.position = position\n  }\n\n  //Method when action starts\n  onStart(): void {\n    const transform = this.entity.getComponent(Transform)\n\n    this.entity.addComponentOrReplace(\n      new utils.MoveTransformComponent(\n        transform.position,\n        this.position,\n        4,\n        () =&gt; {\n          this.hasFinished = true\n        }\n      )\n    )\n  }\n  //Method to run on every frame\n  update(dt: number): void {}\n  //Method to run at the end\n  onFinish(): void {}\n}\n\n//Use sequence builder to create a sequence\nconst sequence = new utils.ActionsSequenceSystem.SequenceBuilder()\n  .while(() =&gt; !boxClicked)\n  .then(new ScaleAction(box, new Vector3(1.5, 1.5, 1.5)))\n  .then(new ScaleAction(box, new Vector3(0.5, 0.5, 0.5)))\n  .endWhile()\n  .then(new ScaleAction(box, new Vector3(1, 1, 1)))\n  .then(new MoveAction(box, new Vector3(1, 0, 1)))\n\n//Create a sequence system, and add it to the engine to run the sequence\nengine.addSystem(new utils.ActionsSequenceSystem(sequence))"
        }
        
      
    
  
    
      
        ,
        
        "development-guide-video-playing": {
          "id": "development-guide-video-playing",
          "title": "Play Videos",
          "categories": "development-guide",
          "url": " /development-guide/video-playing/",
          "content": "There are two different ways you can show a video in a scene. One is to stream the video from an external source, the other is to pack the video file with the scene and play it from there.\n\nIn both cases, you assign the video to a VideoTexture, which can be used on a material and then applied to any primitive shape like a plane, cube, or even a cone.\n\n\n  TIP: Since the video is a texture that’s added to a material, you can also experiment with other properties of materials, like tinting it with a color, of adding other texture layers. for example to produce a dirty screen effect.\n\n\nShow a video\n\nThe following instructions apply both to streaming and to showing a video from a file:\n\n\n  \n    Create a VideoClip object, either referencing a streaming URL or a path to a video file.\n  \n  \n    Create a VideoTexture object, and assign the VideoClip to it.\n  \n  \n    Create a Material or BasicMaterial, and set its albedoTexture or texture to the VideoTexture you created.\n  \n  \n    Then add that Material to an entity that has a primitive shape, like a PlaneShape or a BoxShape.\n  \n  \n    Play the video texture\n  \n\n\nThis example uses a video stream:\n\n// #1\nconst myVideoClip = new VideoClip(\n  \"https://theuniverse.club/live/consensys/index.m3u8\"\n)\n\n// #2\nconst myVideoTexture = new VideoTexture(myVideoClip)\n\n// #3\nconst myMaterial = new Material()\nmyMaterial.albedoTexture = myVideoTexture\nmyMaterial.roughness = 1\nmyMaterial.specularIntensity = 0\nmyMaterial.metallic = 0\n\n\n// #4\nconst screen = new Entity()\nscreen.addComponent(new PlaneShape())\nscreen.addComponent(\n  new Transform({\n    position: new Vector3(8, 1, 8),\n  })\n)\nscreen.addComponent(myMaterial)\nscreen.addComponent(\n  new OnPointerDown(() =&gt; {\n    myVideoTexture.playing = !myVideoTexture.playing\n  })\n)\nengine.addEntity(screen)\n\n// #5\nmyVideoTexture.play()\n\n\nTo use a video file, just change the first step to reference the path to the file:\n\nconst myVideoClip = new VideoClip(\"videos/myVideo.mp3\")\n\n\nVideo Materials\n\nTo many, the default properties of a material make the video look quite opaque for a screen, but you can enhance that by altering other properties of the material.\n\nconst myMaterial = new Material()\nmyMaterial.albedoTexture = videoTexture\nmyMaterial.roughness = 1\nmyMaterial.specularIntensity = 0\nmyMaterial.metallic = 0\n\n\nIf you want the screen to glow a little, you can even set the emissiveTexture of the material to the same VideoTexture as the albedoTexture.\n\nconst myMaterial = new Material()\nmyMaterial.albedoTexture = videoTexture\nmyMaterial.roughness = 1.0\nmyMaterial.specularIntensity = 0\nmyMaterial.metallic = 0\nmyMaterial.emissiveTexture = videoTexture\nmyMaterial.emissiveColor = Color3.White()\nmyMaterial.emissiveIntensity = 0.6\n\n\nSee materials for more details.\n\nAbout Streaming\n\nThe source of the streaming must be an https URL (http URLs aren’t supported), and the source should have CORS policies (Cross Origin Resource Sharing) that permit externally accessing it. If this is not the case, you might need to set up a server to act as a proxy and expose the stream in a valid way.\n\nTo launch your own video streaming server, we recommend using a Node Media Server, which provides most of what you need out of the box.\n\nKeep in mind that streaming video demands a significant effort from the player’s machine. We recommend not having more than one video stream displayed at a time per scene. Also avoid streaming videos that are in very high resolution, don’t use anything above HD. We also recommend activating the stream only once the player performs an action or approaches the screen, to avoid affecting neighbouring scenes.\n\nAbout Video Files\n\nThe following file formats are supported:\n\n\n  .mp4\n  .ogg\n  .webm\n\n\nKeep in mind that a video file adds to the total size of the scene, which makes the scene take longer to download for players walking into your scene. The video size might also make you go over the scene limitations, as you have a maximum of 15 MB per parcel to use. We recommend compressing the video as much as possible, so that it’s less of a problem.\n\nWe also recommend starting to play the video when the player is near or performs an action to do that. Starting to play a video when your scene is loaded far in the horizon will unnecessarily affect performance while players visit neighboring scenes.\n\nHandle a video file\n\nWhen playing a video from a file, you can perform the following actions:\n\n\n  \n    play(): Plays the video. It will start from where the seek property indicates.\n  \n  \n    pause(): Stops the video playing, but leaves its seek property where the video last was. The last played frame remains visible.\n  \n  \n    reset(): Stops the video playing and sends its seek property back to the begining of the video. The first frame of the video is displayed.\n  \n  \n    seekTime(): Sets the seek property to a specific value, so that the video plays from that point on. It’s expressed in seconds after the video’s original beginning.\n  \n\n\nYou can also change the following properties:\n\n\n  \n    loop: Boolean that determines if the video is played continuously in a loop, or if it stops after playing once. false by default.\n  \n  \n    playbackRate: Changes the speed at which the video is played. 1 by default.\n  \n  \n    volume: Lets you change the volume of the audio. 1 by default.\n  \n  \n    seek: Allows you to set a different starting position on the video. It’s expressed in seconds after the video’s original beginning. -1 by default, which makes it start at the actual start of the video."
        }
        
      
    
  
    
      
        ,
        
        "development-guide-external-links": {
          "id": "development-guide-external-links",
          "title": "Outbound links",
          "categories": "development-guide",
          "url": " /development-guide/external-links/",
          "content": "You can add links from your scene out to other content, either to other scenes or to external websites.\n\nTeleports\n\nTo teleport a player to another scene, call the following function, indicating the coordinates that you want players to teleport to.\n\nteleportTo('-51,1')\n\n\nPlayers are presented a confirmation screen before they are teleported, this screen displays information from the destination scene’s scene.json file, including the scene name, description and navmapThumbnail. See scene metadata for details on how to set this data.\n\nYou can also teleport players to the most crowded place in Genesis City by doing teleportTo(‘crowd’), which is equivalent to typing /goto crowd in the chat. Similarly you can teleport players to a random location from the curated list that you reach with /goto magic by doing ``teleportTo(‘magic’)`.\n\nBare in mind that teleports take you to a scene in the indicated coordinates, but not necessarily to that same coordinates. This means that when travelling to a scene that has multiple parcels, players may not be landing on the same coordinates as specified, but rather into one of the spawn points designated by the creator of the scene.\n\nTo move a player to another set of coordinates inside the current scene, use the movePlayerTo() function instead. See Move a Player.\n\nExternal links\n\nTo add a link to an external website, use the openExternalURL() command.\n\nconst entity = new Entity()\nentity.addComponent(new BoxShape())\nconst transform = new Transform({ position: new Vector3(4, 0, 4) })\nentity.addComponent(transform)\nentity.addComponent(\n  new OnPointerDown(() =&gt; {\n    openExternalURL(\"https://docs.decentraland.org\")\n  })\n)\nengine.addEntity(entity)\n\n\nTo prevent any abusive usage of this feature to spam players, it’s only possible to call the openExternalURL from an explicit click or button event on an entity. It’s not possible to call this function as a result of a timer, or a collision area, or a global click event.\n\nWhen openExternalURL is called, players are prompted with a confirmation screen, where they are informed of where the link will take them, and where can accept of decline to visit the link.\n\nThe link is opened in a new tab, keeping the original tab in Decentraland.\n\nIf players tick the trust this domain checkbox, they won’t be prompted again during their session, as long as the link comes from the same scene and is to the same domain."
        }
        
      
    
  
    
      
        ,
        
        "blockchain-integration-transactions-in-polygon": {
          "id": "blockchain-integration-transactions-in-polygon",
          "title": "Transactions in Polygon",
          "categories": "blockchain-integration",
          "url": " /blockchain-integration/transactions-in-polygon/",
          "content": "What is Polygon?\n\nAs stated in the the official Polygon website, “Polygon is a protocol and a framework for building and connecting Ethereum-compatible blockchain networks. Aggregating scalable solutions on Ethereum supporting a multi-chain Ethereum ecosystem.”\n\nWhat is Matic?\n\nMATIC is Polygon’s native token. It is a cryptocurrency used to cover gas fees in the Polygon network, among other use cases. MATIC is to Polygon as Eth is to Ethereum.\nYou can buy MATIC in most cryptocurrency exchanges.\n\nPolygon in Decentraland’s Marketplace\n\nBy using the Polygon network, and thanks to Decentraland’s DAO, users can list, sell and buy wearables for free. But transactions in Polygon are not free. The Decentraland Foundation covers the cost of the transactions in Polygon, but there is a “free transaction limit”.\n\nWhat is the free transaction limit?\n\nTransactions on the Polygon network cost gas. The Decentraland DAO covers the cost up to a certain limit, so that users can enjoy many costless transactions in the Marketplace.\n\nTransactions on the Polygon network cost gas.\n\nThe Decentraland DAO covers the cost up to a certain limit, so that users can enjoy many costless transactions in the Marketplace.\n\nWhat happens if the free transaction limit is reached?\n\nThe free transaction limit renews every day, so you can try again tomorrow. Alternatively, you can cover the cost of your transaction with MATIC while being connected to the Polygon network.\n\nThe MATIC fee will be deducted automatically as part of the transaction. You only need to be connected to the Polygon network and have MATIC in your wallet.\n\nGas fees are variable."
        }
        
      
    
  
    
      
        ,
        
        "examples-get-a-wallet": {
          "id": "examples-get-a-wallet",
          "title": "Get a Wallet – Beginners guide",
          "categories": "examples",
          "url": " /examples/get-a-wallet/",
          "content": "What is a wallet?\n\nDecentraland uses the Ethereum blockchain to record the ownership of all digital assets and tradable items.\n\n\n\nDigital wallets are tools that work as a bridge between the blockchain and the dApp (decentralized applications). This means that with a wallet you will be able to monitor your available funds, transaction history and security options.\n\nDo I need a wallet to play in Decentraland?\n\n\n\nIf you want to fully enjoy the Decentraland experience, we highly recommend you get yourself a digital wallet. Why? Because it will work as your personal account, allowing you to connect from different devices, keeping all your digital assets (such as names, collectibles, LANDs) and progress safe.\n\nIf you choose to experience Decentraland without a wallet, the information will be only be locally stored: you will be able to walk around, customize your avatar and chat with others in-world, but you won’t have the chance to receive daily rewards, participate in events or log in with a different device using the same Guest ID and Avatar.\n\nHow do I get a digital wallet?\n\nTo enter Decentraland, you must use a wallet that is integrated to your web browser, so we recommend you MetaMask\n\n\n\nOnce you install it, you will see an icon like this:\n\n\n\nWallet address\n\nAll wallets have a public and private key. A public key Is a unique identifier for your wallet and it looks like this: 0xcba113f589805095a892ecefdb4eb83eff45d98. It is basically a name that you can share freely with others and it’s used to direct assets to your wallet.\n\nYou can localize your wallet address clicking on the extension icon in your browser, and then clicking on your wallet name with the public key to copy it to clipboard:\n\n\n\nOr by clicking on your account details:\n\n\n\nThe private key is used by your wallet to sign each transaction and certify that it was truly sent by you. It is also used to restore your wallet in case you forget your password.\n\nKeep in mind that a digital wallet is like a bank account, so make sure you don’t forget your password, or backup phrase. Keep them in a safe place and don’t share them with anyone.\n\nWhat is Ether (ETH), and how do I send it to my wallet?\n\n\n\nFor executing transactions, you’ll need to put money in your wallet. dApps based on Ethereum, like Decentraland, use Ether: a digital currency that powers the Ethereum network. It acts like any other currency, in that its value fluctuates with the market.\n\n\n  You need to convert your currency (e.g. USD, CAD, GBP) into Ether to pay for things such as a collectibles.\n\n\nHow do I get Ether?\n\nFor US citizens only:\n\nYou can purchase ETH for the MetaMask Browser Extension with the Coinbase service.\n\n\n  Click the Buy button.\n  Select the Coinbase option.\n  Click the Continue to Coinbase button to purchase Ethereum.\n\n\nFor the rest of the World:\n\nYou need to buy ETH from Coinbase or another exchange using normal fiat currency.\n\n\n  Copy your MetaMask address by clicking on your name account and address.\n  Select Copy Address to clipboard.\n  Go to Coinbase or another exchange.\n  Click Accounts in your top navigation.\n  Select your ETH wallet and click buy.\n  Follow the steps to Add payment method and paste your MetaMask address with the amount you’d like to transfer.\n\n\nWhat is MANA and how do I get it?\n\n\n\nMANA is Decentraland’s fungible (reproducible or interchangeable) cryptocurrency token. It is burned, or spent in exchange for LAND parcels, wearables and names.\n\nSteps to buy MANA:\n\n\n  First, you need to register with an exchange that lists MANA (such as Coinbase, Huobi, Binance).\n  Secondly, you will need to deposit funds into your account. While things change rapidly in the crypto world, it’s not likely that there’s an exchange available to convert your USD directly for MANA. If that’s the case, you’ll first need to obtain a cryptocurrency listed in a currency pair with MANA, such as Ether (ETH), and then exchange it for Decentraland’s native token.\n  Third, once logged into your exchange account, click on the “Markets” or “Exchange” link and search for your desired currency pairing. For example, MANA/ETH. In the “Buy” field, you can then specify the amount of MANA you want to buy or the amount of ETH you want to spend. Make sure you take a moment to review the full details of the transaction including any fees that apply and the total cost of completing your purchase.\n\n\nWhat is ‘gas’?\n\n‘Gas’ is a shorthand term used to describe the cost of powering a transaction or contract in Ethereum. Because blockchain is decentralized, every transaction is distributed through multiple computers, not a central server. This ensures each token – in this case, each collectible – is secure and one-of-a-kind. It also takes a lot of computational power, which is covered by the cost of gas.\n\n\n  ‘Gas’ is composed of two parts: Gas Price and Gas Limit. Gas Price is what you offer to pay the miners (in a tiny measurement of ether called ‘gwei’) for each operation to execute the smart contract. Gas Limit is how many operations you let them do before they run out of gas and drop the transaction.\n  1 gwei = 1/1,000,000,000th of an Ether.\n\n\n\n\nTo summarize, Gas Price (gwei) is the amount of Ether offered per gas unit to pay miners to process your transaction. The higher the gas price you set, the faster your transaction will get processed. So, for more important transactions – such as a collectible that you really like ;D – think about increasing the suggested gas price.\n\nFor extra technical information, visit this link\nhttps://docs.decentraland.org/blockchain-integration/ethereum-essentials/"
        }
        
      
    
  
    
      
        ,
        
        "releases-sdk-6-0": {
          "id": "releases-sdk-6-0",
          "title": "SDK Release 6.0.0",
          "categories": "releases, sdk",
          "url": " /releases/sdk/6.0/",
          "content": "Latest releases:\n\nRepository link\n\nLegacy releases\n\n6.4.9\n\n\n  External links\n  Font support (for now only San Francisco and its variations)\n  Support for videos from files\n  Picture frame support for any NFT from Open Sea\n  Picture frame support for GIF NFTs\n  Open picture frame UI\n  New reflection texture on metallic materials\n  Preview keeps loading even when browser window is inactive\n  Hide/Show DCL UI by pressing the U key\n  Several scene-loading optimizations\n\n\n6.4.8\n\n\n  Support for audio streaming\n  Support for video streaming\n  \n    Support for external texture URLs with upper and lower case\n  \n  Bug Fixes:\n    \n      Fixed issue with flickering of textures while loading, which sometimes made objects transparent or partially transparent\n      An OnPointerDown component is no longer passed on to an entity’s parents\n      Invisible entities no longer show on-hover click feedback.\n      On-hover click feedback no longer shown when entities are too far to click\n    \n  \n\n\n6.4.7\n\n\n  Support for 3rd person view in preview (use v to toggle)\n  Placeholder values for user name an ID when in preview\n\n\n6.4.5\n\n\n  Obtain the server and layer of the player.\n  \n    Customize the on-hover text on clickable entities.\n  \n  Bug Fixes:\n    \n      NFT picture frames work\n      Various performance and stability improvements\n    \n  \n\n\n6.4.4\n\n\n  On-hover feedback for clickable entities Button events\n  The rays of button events don’t go through other entity’s colliders.\n  Mouse sensitivity improved, making it easier to point at small objects\n  \n    Bug Fixes:\n  \n  Camera rotation includes all axis again\n  Player less likely to fall off moving platforms\n\n\n6.4.3\n\n\n  Optimized queuing of raycasting messages. See Raycasting for details.\n  Fine tuned messaging budget per frame to handle more actions in the scene\n  \n    Bug fixes:\n\n    \n      Players now take their time to fall, instead of falling instantly\n      Various animations fixes, including support for animations that are non-skeletal or that have rotations, colliders, or transitions with non-linear curves.\n      Fixed uv mapping of textures created via code\n      Triangle count in the Panel now properly reflects true triangles being used.\n      Issue fixed with large animations that were timing out and not loaded into the scene\n      Issue fixed where cursor gets stuck for a few seconds when leaving the preview window and then returning.\n    \n  \n\n\n6.4.2\n\n\n  Material colors now support Color4 to include alpha values easily\n  \n    Bug fixes:\n  \n  The UITextInput now retunrs the provided text in the “value” field\n  The player no longer loses control of the pointer when standing on a rotating platform\n  The player no longer instantly teleports to the ground when falling off a cliff\n  Transparent materials using AlphaTest mode now work as expected\n\n\n6.4.1\n\n\n  More detailed feedback when entities are out of scene bounds, marking mesh bounding boxes\n  \n    Various bug fixes:\n  \n  Original material for entities out of scene bounds is restored on hot reload\n  Alpha clipping is fixed on 3D models that use partially transparent textures\n  Players can jump from slanted ground\n  Scene spawning points defined on scene.json work on preview\n  Repeated 3D models with animations now all play\n  P2P communication fixed between local isntances of a scene running in preview\n  Large scene loading time performance improvements\n\n\n6.4.0\n\n\n  Raycasting\n  Global BUTTON_DOWN and BUTTON_UP events\n  Support for PRIMARY and SECONDARY button events (E and F keys, on a keyboard)\n  If player is standing on an entity, they now move together with that entity\n  Entities that extend outside scene boundaries are now marked as red\n  \n    Fixed bugs\n\n    \n      Several bugs with entity lifecycle when adding and removing from engine\n      Several bugs with billboard mode\n    \n  \n\n\n6.3.2\n\n\n  Support for Billboard component\n  Bug fixes related to scene loading &amp; lifecycle\n\n\n6.3.1\n\n\n  Support for OnPointerDown and OnPointerUp events\n  Camera height adjusted slightly, so avatars see each other eye-to-eye\n  Support for hot-reload and export functionalities with the latest CLI version\n  Bug fixes and performance improvements\n\n\n6.3.0\n\n\n  NFT picture frames support\n  All shapes, including primitives, have collisions by default\n  GLTFShapes can have collisions dissabled\n  Several optimizations\n\n\n6.2.4\n\n\n  Entities that have visible = false can’t be clicked\n  Several optimizations\n  Bug fixes - Fix parsing of materials on GLTFs (normal maps, emissive maps, roughness maps, etc)\n\n\n6.2.3\n\n\n  Bug fixes - Fix parsing of materials on GLTFs (emissive, specular, etc)\n\n\n6.2.2\n\n\n  Important optimizations, specially for scenes with multiple transforms updated on every frame\n  Updated Unity engine to latest version: 2019.1.8.f1\n  Reduced fog levels and other art adjustments to materials\n  Bug fixes: - Fix Z-fighting between surfaces that are close to each other - Entities that share a same shape component can be removed independently without affecting the other - Fix alignment of children of UIContainerStack components - Audio can now be looped - Audio sounds no longer start on the first frame if not explicitly played - Fixed exaggerated doppler effect, that was most notable when running - AnimationClip.Stop() now returns the model to the first frame of the animation\n\n\n6.2.1\n\n\n  Unlock cursor by pressing Esc only once (used to require pressing Esc twice)\n  Enter key focuses or leaves from chat\n  Change empty floor texture\n  Bug fixes: - Fix UI positioning - setParent(null) now sets an entity to be a child of the scene object - Removed entity now can be re-added to engine\n\n\n6.2\n\n\n  Bug fixes: - Very large scenes disappear when walking too far from origin\n\n\n6.1.5\n\n\n  Serverless multiplayer: Send messages over content server, publish - subscribe\n  Bug fixes: - Emissive and transparent materials for primitives fixed - Alignment of TextShape components - Audio fixed work as positional - UI positioning when set to invisible\n\n\n6.1.3\n\n\n  Bug fixes: - Emissive materials fixed for primitives - Camera.position &amp; Camera.rotation fixed\n\n\n6.1.2\n\n\n  UI screen space limited to not use the top 10% of the screen\n  Decentraland UI components always rendered on top layer, above screen-specific UIs\n  Bug fixes\n\n\n6.1.1\n\n\n  Unity set as the default engine\n  Various bug fixes\n\n\n6.1\n\n\n  Unity engine integration - Shadows - Various optimizations\n  Components for player UIs, see UI for details.\n\n\n6.0.1 - Beta\n\n\n  Fix a bug with entity positions out of bounds\n  Rename the AnimationClip object to AnimationState for more clarity\n  Rename the BUTTON_A_DOWN and BUTTON_A_UP events to BUTTON_DOWN and BUTTON_UP\n\n\n6.0 - Beta\n\nThis release includes the following new features\n\n\n  \n    Each parcel now measures 16 x 16 meters. This was decided via a vote by the community. New scenes created with the CLI are 16 x 16, old scenes remain as 10 x 10, but we recommend migrating to a 16 x 16 format. Scene limitations per each parcel haven’t changed since 5.0.\n  \n  \n    Improved audio engine: Multiple audio samples can be played at once. Also, each audio sample has a specific location. See Sounds for details.\n  \n\n\nconst trevor = new Entity()\n\n//Create audio clip\nconst audioClip = new AudioClip(\"sounds/Vexento.mp3\")\naudioClip.loop = true\n\n//Create audio source\nconst audioSource = new AudioSource(audioClip)\ntrevor.addComponent(audioSource)\n\nengine.addEntity(trevor)\n\n\n\n  Custom events are now possible, using functions to emit and listen for them.\n\n\nThis version includes several bug fixes and optimizations. It also includes the following changes:\n\n\n  \n    3D model animations are now handled by an Animator component, instead of by the GLTFModel component.\n\n    let shark = new Entity()\n// Create Animator component\nconst animator = new Animator()\nshark.addComponent(animator)\n\n// Create animation clips\nlet clipSwim = new AnimationState(\"swim\")\nlet clipBite = new AnimationState(\"bite\")\nanimator.addClip(clipBite)\nanimator.addClip(clipSwim)\n\n// Activate swim animation\nclipSwim.play()\n\nengine.addEntity(shark)\n    \n  \n  \n    Textures are now handled by a specialized Texture component, that can be referenced by a Material component.\n\n    let wheel1 = new Entity()\n\n// Create texture\nconst spiralTexture = new Texture(\"materials/hypno-wheel.png\")\n\n// Create material\nlet spiralMaterial = new Material()\nspiralMaterial.albedoTexture = spiralTexture\n\n// Add material to wheels\nwheel1.addComponent(spiralMaterial)\n\nengine.addEntity(wheel1)\n    \n  \n  \n    Billboard mode is now done via a separate specialized component, instead of by setting a property in shape components.\n\n    let box = new Entity()\nbox.addComponent(new BoxShape())\nbox.addComponent(\n  new Transform({\n    position: new Vector3(5, 1, 5),\n  })\n)\nbox.addComponent(new Billboard())\nengine.addEntity(box)\n    \n  \n  \n    Basic commands for handling components are renamed for more clarity. For example get is now getComponent, add is now addComponent and set is now addComponentOrReplace.\n  \n\n\nSee the  migration guide for clear examples of how to migrate your code.\n\nRead the [release announcement(https://decentraland.org/blog/announcements/introducing-sdk-6-beta/) blogpost for more details about these new features!\n\n\n  Note: All 3D models are now rotated 180 degrees along the Y axis to follow standards that are consistent with most other platforms. Any 3D models in your scene will now be rendered facing backwards. You may have to reposition or rotate your entities to compensate for this new rotation. Also, we now check that 3D models are within scene bounds by looking at the bounding boxes, not at each individual vertex. This is a lot more efficient, but some 3D models may have empty bounding boxes that stretch far beyond the vertexes. If that’s the case, you’ll have to clean up the 3D model so that the bounding boxes more closely match the vertexes of the model."
        }
        
      
    
  
    
      
        ,
        
        "decentraland-builder-faq": {
          "id": "decentraland-builder-faq",
          "title": "Builder FAQ",
          "categories": "Decentraland",
          "url": " /decentraland/builder-faq/",
          "content": "How do scene limits work? What are triangles? How about materials? What’s going on?\n\nGenesis City is a really, really big place. In order to make sure everyone has a smooth experience, there’s a limit to how much stuff each scene can hold.\n\nIn the bottom left corner of the Builder, if you click on the set of squares, you’ll find a little list explaining what each of these limits are, and how far along you are to reaching each one. Let’s take a look at each of these:\n\n\n  Geometries: these define different simple shapes, like a box or a wheel.\n  Bodies: a body is just a copy of a geometry. For example, a bike might have three bodies: the frame and two wheels. By copying similar geometries, we can save resources.\n  Triangles: each surface of a body is shaped like a triangle. More complex models have more triangles than simpler models.\n  Materials: materials make your scenes more realistic by describing how a model or shape should look. They change the way light is reflected (or emitted) from different models, and can include one or more textures.\n  Textures: these are the images used in materials. Textures are images of different patterns and colors - like wood, stone, or grass.\n  Entities: an entity can include one or more bodies, like the bike in the example above. Entities include everything you need for an asset: the geometries, bodies, materials, and textures.\n\n\nI can’t upload my scene because it says something is out of bounds, what does that mean?\n\nThis is likely because some of your models are falling off the edges of your scene. Even if it’s barely out-of-bounds, it’ll still be marked in red. Watch out! Some of these troubled models might be hiding in other objects you’ve put on the edge of your parcel (like trees!).\n\nCan I upload custom assets?\n\nYes, you can import 3D models in .gltf and .glb formats. To do so, either click the plus sign at the top of the Asset list, or click the NEW ASSET PACK button at the bottom of the list. Then follow the instructions to import one or more 3d models. You will then find your assets in their own asset pack on the right-hand menu.\n\nCan I deploy my scene to my land?\n\nYes, you can deploy to land you own, or land where you have deploy permissions. To do so, click the UPDATE SCENE button on the top-right, then you can choose what parcels to deploy it to, and orient the scene in the right direction to fit these.\n\nTo do so, you need to have the Metamask or Dapper account that owns the parcels or the permissions open on your browser.\n\nCan I move items underground?\n\nYes, you can place an object underground, or partially underground. However, the floor on the scene can’t be removed, so you can’t do tunnels or holes for players to see what’s underground.\n\nHow do I add images to my scene?\n\nYou can’t import, upload, or paste images into the Builder right now. You can however import a custom 3D model that has an image on as a texture.\n\nCan I share my scenes with other Builder users?\n\nYes, the Share button on the top-right of the screen lets you share a link or a post on Twitter or Facebook that can let others view and explore the scene as players.\n\nHow do I save projects?\n\nProjects are saved automatically to your account.\n\nCan I export my scenes?\n\nYes, just click the Download scene icon on the top-right corner. You can either import that scene back into the builder, or work on it to add extra functionality to it, by writing code with the SDK.\n\nCan I import scenes from the SDK?\n\nNo, you can export scenes to the SDK, but not the other way round.\n\nCan I group objects?\n\nYou can multi-select objects by pressing control and keeping it pressed while selecting more, and then apply actions to that group.\n\nCan I snap/attach items to other items?\n\nNo, but you can press and hold Shift for more precise placement when moving objects.\n\nHow does Preview mode work?\n\nUse the W, A, S, and D keys to move around in Preview mode, and Space to jump. If you can’t move, you may be stuck in an object. Changing where you spawn (enter the scene) is a feature we have planned for the future.\n\nCan I pick the color or texture of items?\n\nRight now, all of the models come with one texture, but we agree that it’d be awesome to have more control over each model’s appearance. You can however export a 3D model, edit it in a 3D modeling tool, and import it again into a custom asset pack.\n\nWhere can I find the default Builder 3D models if I want to edit them?\n\nYou can find all of these models in this repo. You can also add the models you wish to a scene in the Builder and then export that scene, and you’ll find the used models in a folder.\n\nBefore editing the models, see the 3D Modeling section of our docs.\n\nCan I create my own smart items?\n\nYes. Doing that requires using code and being familiar with the Decentraland SDK. You can find details here."
        }
        
      
    
  
    
      
        ,
        
        "development-guide-smart-items": {
          "id": "development-guide-smart-items",
          "title": "Smart items",
          "categories": "development-guide",
          "url": " /development-guide/smart-items/",
          "content": "Through the Builder, you can drag and drop smart items into a scene. These are items that have configurable parameters and actions that can be triggered, like doors that can be opened or levers that can be activated. There is a default collection of smart items in the Builder, but you can also create your own and import them.\n\nSmart items are written using the same SDK code that you use for creating a scene, making use of entities, components and systems. This document assumes that you’re familiar with these concepts and will focus on how to encapsulate this code so that it interfaces with the scene and other smart items.\n\nSmart item references\n\nWe recommend that you start working from an existing smart item, and use it as a template.\n\nYou can find the default collection of smart items that are in the builder in this repository:\n\nhttps://github.com/decentraland/smart-items\n\nYou can also obtain the code of a smart item by using it in a scene in the Builder and then exporting that scene. The code for the smart item will be in a sub-folder of src.\n\nThe asset manifest\n\nEvery smart item has an asset.json file. This is a manifest that exposes how the item can be configured via the Builder UI, and how other items can activate it.\n\n\n  TIP: We recommend starting the development of your smart item from the manifest. There you can first define the item’s interface and configurable parameters, and then develop the supporting backend for that.\n\n\nGeneral item data\n\n\n  \n    id: A unique uuid for the smart item. The dcl init command generates a random value for this ID.\n\n    \n      Note: If you’re copying a project from an existing smart item, make sure you generate a new UUID for your item. Otherwise the Builder will not recognize this as a distinct item. Use uuidgenerator.net to generate a new random UUID.\n    \n  \n  \n    name: Refers to the name that this model will have in the Builder UI.\n\n    \n      Note: Today, the item name that’s visible in the UI is taken directly from the name of the 3d model file. Don’t leave any spaces in the file name, use underscores to separate the words in it.\n    \n  \n  \n    model refers to the 3D model that is used as a placeholder when dragging the item into the scene in edit mode. This can be especially useful when the item is made up of several 3D models, as you’ll want to display an alternative placeholder model that includes all the meshes together. Make sure this placeholder model has the same size and orientation as the item that will be seen in the scene. Also make sure that the item isn’t displaced via code from its default location, unless the placeholder matches this.\n  \n  \n    tags let you make the item easier to find when using the search.\n  \n  \n    category places the item into a subcategory inside the asset pack, for example “nature” or “decorations”.\n  \n\n\nParameters\n\nThe asset.json file contains an array of parameters that can be configured via UI. The corresponding UI is generated in the Builder, automatically taking care of spacial arrangement and formatting of these menu items.\n\n\n\nEvery parameter must have:\n\n\n  a label to display in the UI\n  an id by which its value can be used in your item’s code\n  a type that determines the accepted values. The UI will change accordingly to match the type.\n\n\nParameters can also have a default value, to help make the item easier to use out of the box.\n\n {\n      \"id\": \"distance\",\n      \"label\": \"Distance\",\n      \"type\": \"integer\",\n      \"default\": 10\n  },\n\n\nThe basic supported types for parameters are :\n\n\n  text\n  integer\n  float\n  boolean\n\n\nSpecial types\n\nType actions refers to an action in this or another smart item. When this type is used, the field will present two dropdown menus. One selects a smart item, the other an action from that item.\n\n  {\n      \"id\": \"onUse\",\n      \"label\": \"When used\",\n      \"type\": \"actions\"\n    },\n\n\n\n  Note: Decorators can use the plus sign to add as many actions as they want to one single actions field.\n\n\n\n\nType entity refers to another item. When this type is used, the field will present a single dropdown to select a smart item.\n\n    {\n      \"id\": \"target\",\n      \"label\": \"Used on\",\n      \"type\": \"entity\"\n    },\n\n\n\n  Note: Decorators can add a single entity in fields of type entity.\n\n\n\n\nType textarea refers to a multi-line string, that appears in the UI as a text box.\n\n    {\n      \"id\": \"text\",\n      \"label\": \"Text\",\n      \"type\": \"textarea\",\n      \"default\": \"Some text\"\n    },\n\n\nType slider exposes a draggable slider bar in the UI. This bar has a maximum and minimum value, and moves by fixed steps.\n\n    {\n      \"id\": \"speed\",\n      \"label\": \"Speed\",\n      \"type\": \"slider\",\n      \"default\": 3,\n      \"max\": 20,\n      \"min\": 0,\n      \"step\": 1\n    },\n\n\nType options exposes a dropdown menu with a set of options you can list.\n\n\"parameters\": [\n    {\n      \"id\": \"sound\",\n      \"label\": \"Sound\",\n      \"type\": \"options\",\n      \"options\": [\n\t\t{\n          \"value\": \"Birds\",\n          \"label\": \"Birds\"\n        },\n        {\n          \"value\": \"City\",\n          \"label\": \"City\"\n        },\n        {\n          \"value\": \"Factory\",\n          \"label\": \"Factory\"\n        },\n        {\n          \"value\": \"Field\",\n          \"label\": \"Field\"\n        },\n        {\n          \"value\": \"Swamp\",\n          \"label\": \"Swamp\"\n        },\n        {\n          \"value\": \"Town\",\n          \"label\": \"Town\"\n        }\n      ],\n      \"default\": \"Birds\"\n    }\n]\n\n\nActions\n\nActions can be called by this item or others to trigger a specific behavior. These don’t appear in the item’s own UI, but all fields of type actions list all of the actions available on all the items that are currently in the scene.\n\nActions have a label that is shown in the dropdown menus, and an id that lets you refer to this value in the item’s code.\n\n \"actions\": [\n    {\n      \"id\": \"open\",\n      \"label\": \"Open\",\n      \"parameters\": []\n    },\n    {\n      \"id\": \"close\",\n      \"label\": \"Close\",\n      \"parameters\": []\n    },\n    {\n      \"id\": \"toggle\",\n      \"label\": \"Open or Close\",\n      \"parameters\": []\n    }\n  ]\n\n\n\n\nActions can also have parameters that you can use to pass information with the action event. These parameters follow the same syntax, types and conventions as explained for the item parameters.\n\n  \"actions\": [\n    {\n      \"id\": \"changeText\",\n      \"label\": \"Change Text\",\n      \"parameters\": [\n        {\n          \"id\": \"newText\",\n          \"label\": \"New Text\",\n          \"type\": \"textarea\"\n        }\n      ]\n    }\n  ]\n\n\n\n\nItem code\n\nThe item.ts file is where you place the main logic for the item. This mainly includes creating an object that exposes at least an init() and a spawn() function.\n\nBelow is an example of the item.ts of a door smart item:\n\nexport type Props = {\n  onClick?: Actions\n  onOpen?: Actions\n  onClose?: Actions\n}\n\nexport default class Door implements IScript&lt;Props&gt; {\n  openClip = new AudioClip(\"sounds/open.mp3\")\n  closeClip = new AudioClip(\"sounds/close.mp3\")\n\n  active: Record&lt;string, boolean&gt; = {}\n\n  init() {}\n\n  toggle(entity: Entity, value: boolean, playSound = true) {\n    if (this.active[entity.name] === value) return\n\n    if (playSound) {\n      const source = new AudioSource(value ? this.openClip : this.closeClip)\n      entity.addComponentOrReplace(source)\n      source.playing = true\n    }\n\n    const animator = entity.getComponent(Animator)\n    const openClip = animator.getClip(\"open\")\n    const closeClip = animator.getClip(\"close\")\n    openClip.stop()\n    closeClip.stop()\n    const clip = value ? openClip : closeClip\n    clip.play()\n\n    this.active[entity.name] = value\n  }\n\n  spawn(host: Entity, props: Props, channel: IChannel) {\n    const door = new Entity(host.name + \"-button\")\n    door.setParent(host)\n\n    const animator = new Animator()\n    const closeClip = new AnimationState(\"close\", { looping: false })\n    const openClip = new AnimationState(\"open\", { looping: false })\n    animator.addClip(closeClip)\n    animator.addClip(openClip)\n    door.addComponent(animator)\n    openClip.stop()\n\n    door.addComponent(new GLTFShape(\"models/Door_Genesis.glb\"))\n\n    door.addComponent(\n      new OnPointerDown(() =&gt; {\n        channel.sendActions(props.onClick)\n      })\n    )\n\n    this.active[door.name] = false\n\n    // handle actions\n    channel.handleAction(\"open\", ({ sender }) =&gt; {\n      this.toggle(door, true)\n      if (sender === channel.id) {\n        channel.sendActions(props.onOpen)\n      }\n    })\n    channel.handleAction(\"close\", ({ sender }) =&gt; {\n      this.toggle(door, false)\n      if (sender === channel.id) {\n        channel.sendActions(props.onClose)\n      }\n    })\n    channel.handleAction(\"toggle\", ({ sender }) =&gt; {\n      const newValue = !this.active[door.name]\n      this.toggle(door, newValue)\n      if (sender === channel.id) {\n        channel.sendActions(newValue ? props.onOpen : props.onClose)\n      }\n    })\n\n    // sync initial values\n    channel.request&lt;boolean&gt;(\"isOpen\", (isOpen) =&gt;\n      this.toggle(door, isOpen, false)\n    )\n    channel.reply&lt;boolean&gt;(\"isOpen\", () =&gt; this.active[door.name])\n  }\n}\n\n\n\n  Note: Keep in mind that external libraries aren’t supported in smart items, not even the decentraland-esc-utils library, so all of your item’s logic should be written using the SDK directly.\n\n\nItem class setup\n\nThe init() function is executed once the first time that a smart item of this kind is added to a scene.\nIt’s a great place to define elements that will be shared amongst all instances of the item, like materials, a system, etc.\n\nItem instancing\n\nThe spawn() function is executed every time a new instance of the smart item is added to the scene. This is where you should instance the entity and components of the item, as well as initiate all the action handlers.\n\nspawn(host: Entity, props: Props, channel: IChannel)\n\nThe spawn() function takes a host entity as a parameter. This host’s positioning will be applied to the positioning of the item in the scene. Instead of adding components like a shape, audiosource, etc directly to the host entity, create a new entity and set it as a child of the host.\n\nThe props parameter will expose all the properties that are defined in the asset.josn file, calling them by the id specified for each in that file.\n\nYou should define a custom type for props, that includes the specific set of properties used by the item. You can then refer to these properties in the spawn() function via the parameter’s id: props.onClick.\n\nThe channel parameter refers to the name of the channel of communication that will be used by this smart item. Smart items use the message bus to communicate between items and to sync state changes with other players. Having separate channels for each item avoids unwanted crosstalk between unrelated items.\n\nHandling actions\n\nIn the spawn function you should also set up handlers to respond when another item calls this item to trigger an action.\n\nFor example, a door can have an ‘open’ action, that could be called by a button, a key, or even another door.\n\nchannel.handleAction(\"open\", ({ sender }) =&gt; {\n  this.toggle(door, true)\n  if (sender === channel.id) {\n    channel.sendActions(props.onOpen)\n  }\n})\n\n\nIn the example above, each time an open action arrives, the door runs the toggle function to play its corresponding animation and sound and to change its state. Then it verifies that the open action effectively came from this player instance and not from another player; if so, it will call any actions that were configured to be called on the item’s OnOpen. If this check isn’t done, then the actions would be sent out multiple times, once for every player in the scene. This, besides being inefficient, can be quite disruptive when dealing with toggle-type actions.\n\n\n  TIP: As your item gets more complex, we recommend keeping the action handlers light, and keep most of the logic in external functions that can be called from these.\n\n\nTesting your item\n\nUse the game.ts file to test out your item just as you would test a scene. Add an instance of your item to the game.ts item, giving it a transform to position it and including all the required parameters inside an object.\n\nimport { Spawner } from \"../node_modules/decentraland-builder-scripts/spawner\"\nimport Door, { Props } from \"./item\"\n\nconst door = new Door()\nconst spawner = new Spawner&lt;Props&gt;(door)\n\nspawner.spawn(\n  \"door\",\n  new Transform({\n    position: new Vector3(4, 0, 8),\n  }),\n  {\n    onClick: [\n      {\n        actionId: \"toggle\",\n        entityName: \"door\",\n        values: {},\n      },\n    ],\n  }\n)\n\n\nThen simply run dcl start on the item’s folder, as you would for a normal scene. You’ll be able to interact with the item. The preview will hot-reload as you change your item’s code.\n\nTry providing different values to the item’s properties, to make sure it functions as expected.\n\nImporting into the Builder\n\nWhen you’re ready to export the item, run dcl pack on the item’s folder. This will generate an item.zip file. Then import this file into a custom asset pack in the Builder.\n\nYou can then test it in a Builder scene. We recommend you do the following tests:\n\n\n  Set different values in the item’s parameters\n  Have its actions called by other items\n  Call other items from it\n  Add multiple instances of the item to make sure they don’t interfere with each other\n\n\nIf this all works then congratulations, you have a fully stable smart item!\n\nStoring state data\n\nYour item might need to store information at an instance level. For example, each door needs to keep track of if its open or closed, but other more complex items might keep track of more information about themselves.\n\nThe example above uses a list of booleans to represent the open/closed state of each door, where the entity name of each door is used as a key. For items with more information, it’s advisable to instead define a custom component that holds all of the data of the item.\n\nWhen instancing an item in the spawn() function, you should then add this component to new items.\n\n\n  TIP: We recommend defining the custom component in a separate file from item.ts, to keep your code cleaner.\n\n\nIt’s important that you name your custom components with unique names that shouldn’t overlap with names used by other smart items. We recommend including the item name as part of the component name to avoid this. Otherwise, conflicting smart items in a same scene could interfere with each other in unexpected ways.\n\nCustom systems\n\nIf you need your item to perform a gradual action that is executed frame by frame, like moving or rotating (not by animation), then you need to define systems to carry this out. Delaying an action also requires creating a system that waits x milliseconds.\n\n\n  NOTE: The decentraland-ecs-utils library can perform many of these actions in a scene’s code, but this library is not supported in smart items. Any transition needs to be explicitly written as a system.\n\n\nAs with custom components, systems need to have unique names that don’t overlap with those of other smart items used in the same scene. Again, we recommend using the item name as part of the system name to avoid this.\n\nNote that besides defining the system, you also need to add an instance of it to the engine. The ideal place for that is in the init() function of the smart item, which is executed once when the first item of this type is added.\n\n\n  TIP: We recommend defining systems in a separate file from item.ts, to keep your code cleaner.\n\n\nMultiplayer behavior\n\nAll the smart items that are available by default in the Builder have multiplayer capabilities. They achieve this by using the message bus to send peer to peer messages between players every time that something changes.\n\nSince the state of the item is shared amongst peers, if all players leave the area of the scene, the state of the item is no longer stored anywhere, and it reverts to its initial state.\n\nTo keep the state of your smart item in sync between players, make sure that any relevant changes send out messages via the item’s channel for other instances to follow it.\n\nWhen new players join the scene, make sure that they obtain any relevant information from other players about the current state of the item. For example, to do this, the door item sends out a channel.request when spawning, and if there are any other players with instances of that door there should be code that will reply with a boolean indicating if the door is currently open.\n\n// we send a request to all other players\nchannel.request&lt;boolean&gt;(\"isOpen\", (isOpen) =&gt; this.toggle(door, isOpen, false))\n\n// we respond to this incoming request from other players\nchannel.reply&lt;boolean&gt;(\"isOpen\", () =&gt; this.active[door.name])\n\n\nIn some cases, you might not want the actions of a player affecting others. For example, when one player picks up a key, you don’t want all players to have that key equipped. To avoid this, you can filter the sender of a message and only react when it matches the channel id.\n\nchannel.handleAction(\"equip\", (action) =&gt; {\n  if (!this.isEquipped(key)) {\n    // we only equip the key for the player who triggered the action\n    if (action.sender === channel.id) {\n      this.equip(key)\n      channel.sendActions(props.onEquip)\n    }\n    // we remove the key from the scene for everybody\n    this.hide(key)\n  }\n})"
        }
        
      
    
  
    
      
        ,
        
        "releases-sdk-5-0": {
          "id": "releases-sdk-5-0",
          "title": "SDK Release 5.0.0",
          "categories": "releases, sdk",
          "url": " /releases/sdk/5.0/",
          "content": "5.0\n\nThis release introduces a new Entity Component System architecture. There are no new features, but the entire SDK has been rewritten based on the new paradigm.\n\nThe following features aren’t currently supported in this implementation:\n\n\n  Video\n  Audio is only partially supported\n\n\nYou can find a detailed announcement of this release and the reasons for it in this blogpost."
        }
        
      
    
  
    
      
        ,
        
        "development-guide-game-objects": {
          "id": "development-guide-game-objects",
          "title": "Game objects",
          "categories": "development-guide",
          "url": " /development-guide/game-objects/",
          "content": "As your scene becomes more complicated, it’s useful to put some of the logic into separate game object files. By doing this, you can keep the main code for the scene clean and simple to read, while encapsulating reusable parts that control several entities in the scene.\n\nA Game Object holds all the properties and methods for a type of entity you might find in your scene, for example a door or a button or a monster. Thanks to this abstraction, the files with your scene’s main logic can instance full game objects through just one line of code. You can also call the methods on these objects with the same ease.\n\nWe recommend keeping game object definitions each in a separate file.\n\nBelow is an example of a Door game object. This object has a constructor that requires that you pass it a shape, a sound and a position. It also exposes an openDoor, closeDoor and toggleDoor method, that can be called from other files.\n\nexport class Door extends Entity {\n  public isOpen: boolean\n\n  // Allow each room to specify a unique look and feel\n  constructor(\n    model: GLTFShape,\n    transform: TranformConstructorArgs,\n    sound: AudioClip\n  ) {\n    super()\n    engine.addEntity(this)\n\n    this.addComponent(model)\n    this.addComponent(new Transform(transform))\n\n    this.addComponent(new Animator())\n    this.getComponent(Animator).addClip(\n      new AnimationState(\"Door_Open\", { looping: false })\n    )\n    this.getComponent(Animator).addClip(\n      new AnimationState(\"Door_Close\", { looping: false })\n    )\n\n    this.addComponent(new AudioSource(sound))\n  }\n\n  /**\n   * Exposing `openDoor` as an action this object is capable of doing\n   * This contains the open door experience (animation and sound) while allowing\n   * the scene to decide when the action occurs\n   */\n\n  public openDoor(playAudio = true): void {\n    if (!this.isOpen) {\n      this.isOpen = true\n\n      this.getComponent(Animator).getClip(\"Door_Close\").stop() // bug workaround\n      this.getComponent(Animator).getClip(\"Door_Open\").play()\n\n      if (playAudio) {\n        this.getComponent(AudioSource).playOnce()\n      }\n    }\n  }\n\n  // Similiarly we can close the door.\n  public closeDoor(playAudio = true): void {\n    if (this.isOpen) {\n      this.isOpen = false\n\n      this.getComponent(Animator).getClip(\"Door_Open\").stop() // bug workaround\n      this.getComponent(Animator).getClip(\"Door_Close\").play()\n\n      if (playAudio) {\n        this.getComponent(AudioSource).playOnce()\n      }\n    }\n  }\n\n  // Or toggle the state between open and closed\n  public toggleDoor(playAudio = true): void {\n    if (this.isOpen) {\n      this.closeDoor(playAudio)\n    } else {\n      this.openDoor(playAudio)\n    }\n  }\n}\n\n\nA few things to note from the code above:\n\n\n  export makes the class available to other files in your scene\n  extends Entity makes this definition inherit everything from the base Entity class\n  this refers to the current instance of the game object\n\n\nNone of the code above produces any changes in the scene on its own. It just exposes constructors and methods that can be called from other files, keeping what’s possible separate from what is to be done.\n\nOnce the Door class is defined in your scene, you can use it in your game.ts or any other file:\n\nimport { Door } from \"./door\"\n\nconst door = new Door(\n  new GLTFShape(\"models/Door.glb\"),\n  { position: new Vector3(24, 0, 24) },\n  new AudioClip(\"sounds/door_squeak.mp3\")\n)\ndoor.addComponent(\n  new OnClick((): void =&gt; {\n    door.toggleDoor()\n  })\n)\n\n\nThe code above imports the Door class, then instances a door, and adds an OnClick behavior to it that simply calls the toggleDoor method in the Door class.\n\n\n  Tip: To learn more about using game objects in Decentraland scenes, see this Tutorial video\n\n\nThe Type Object Pattern\n\nIf your scene uses various types of game objects that have much in common, you might want to take this refactor even further, and define a base game object type with all the things that these have in common. You can then create sub classes that inherit from this base class.\n\nYou can read more about this pattern in Game Programming Patterns."
        }
        
      
    
  
    
      
        ,
        
        "development-guide-raycasting": {
          "id": "development-guide-raycasting",
          "title": "Raycasting",
          "categories": "development-guide",
          "url": " /development-guide/raycasting/",
          "content": "Raycasting is a fundamental tool in game development. With raycasting, you can trace an imaginary line in space, and query if any entities are intersected by the line. This is useful for calculating lines of sight, trajectories of bullets, pathfinding algorithms and many other applications.\n\nWhen a player clicks or pushes the primary or secondary button, a ray is traced from the player’s position in the direction they are looking, see button events for more details about this. This document covers how to trace an invisible ray from any arbitrary position and direction, independent of player actions, which you can use in many other scenarios.\n\nPhysicsCast\n\nThe PhysicsCast object is a static class that serves as the main raycasting interface. You can refer to it in your scene as PhysicsCast.instance. You’ll see it has several methods that are all specific to raycasting.\n\nlet physicsCast = PhysicsCast.instance\n\n\nCreate a ray\n\nA ray object describes the invisible ray that will be used to query for entities. Rays are defined using three bits of information:\n\n\n  origin: Vector3 with the coordinates in scene space to start the ray from.\n  direction: Vector3 describing the direction (as if the ray started from 0,0,0).\n  distance: number to set the length with which this ray will be traced.\n\n\nlet originPos = new Vector3(2, 1, 4)\nlet direction = new Vector3(0, 1, 1)\n\nlet ray: Ray = {\n  origin: originPos,\n  direction: direction,\n  distance: 10,\n}\n\n\nAs an alternative, you can also generate a ray from providing two points in space. Both the direction and distance will be implicit in this information. To do this, use the getRayFromPositions() method of the PhysicsCast object.\n\nlet physicsCast = PhysicsCast.instance\n\nlet originPos = new Vector3(2, 1, 1)\nlet targetPos = new Vector3(2, 3, 3)\n\nlet rayFromPoints = physicsCast.getRayFromPositions(originPos, targetPos)\n\n\nYou can also get generate a ray from the player’s current position and rotation. The only piece of information you need to pass in this case is the distance. To do this, use the getRayFromCamera() method of the PhysicsCast object.\n\nlet physicsCast = PhysicsCast.instance\n\nlet rayFromCamera = physicsCast.getRayFromCamera(1000)\n\n\nRun a raycast query\n\nRaycast queries are run by the PhysicsCast class. there are two methods available for doing this:\n\n\n  hitFirst(): this method only returns the first hit entity, starting from the origin point.\n  hitAll(): this method returns all hit entities, from the origin through to the length of the ray.\n\n\nBoth these methods need to be passed the following:\n\n\n  a Ray object\n  a callback function to execute after the query\n  an optional raycast id, to handle separate lossy queues\n\n\n\n\nNote that the callback function is always executed, even if no entities were hit by the ray.\n\nThis sample queries only for the first entity hit by the ray:\n\nlet physicsCast = PhysicsCast.instance\n\nlet originPos = new Vector3(2, 1, 4)\nlet direction = new Vector3(0, 1, 1)\n\nlet ray: Ray = {\n  origin: originPos,\n  direction: direction,\n  distance: 10,\n}\n\nphysicsCast.hitFirst(\n  ray,\n  (e) =&gt; {\n    log(e.entity.entityId)\n  },\n  0\n)\n\n\nThis sample queries for all entities hit by the ray:\n\nlet physicsCast = PhysicsCast.instance\n\nlet originPos = new Vector3(2, 1, 4)\nlet direction = new Vector3(0, 1, 1)\n\nlet ray: Ray = {\n  origin: originPos,\n  direction: direction,\n  distance: 10,\n}\n\nphysicsCast.hitAll(\n  ray,\n  (e) =&gt; {\n    for (let entityHit of e.entities) {\n      log(entityHit.entity.entityId)\n    }\n  },\n  0\n)\n\n\nResults from raycast query\n\nAfter running a raycast query, the callback function will be able to use the following information from the event object:\n\n\n  didHit: boolean that is true if at least one entity was hit, false if there were none.\n  ray: Ray that has been used in the query\n  hitPoint: Vector3 for the point in scene space where the hit occurred. If multiple entities were hit, it returns the first point of ray collision.\n  \n    hitNormal: Vector3 for the normal of the hit in world space. If multiple entities did hit, it returns the normal of the first point of ray collision.\n  \n  entity: Object with info about the entity that was hit. This is returned when using hitFirst(), and it’s only returned if there were any entities hit.\n  entities : Array of entity objects, each with info about the entities that were hit. This is returned when using hitAll(), and it’s only returned if there were any entities hit.\n\n\nThe entity object, and the objects in the entities array contain the following data:\n\n\n  entityId: String with the id for the hit entity\n  meshName: String with the internal name of the specific mesh in the 3D model that was hit. This is useful when a 3D model is composed of multiple meshes.\n\n\nThe example below shows how you can access these properties from the event object in the callback function:\n\nlet physicsCast = PhysicsCast.instance\n\nlet originPos = new Vector3(2, 1, 4)\nlet direction = new Vector3(0, 1, 1)\n\nlet ray: Ray = {\n  origin: originPos,\n  direction: direction,\n  distance: 10,\n}\n\nphysicsCast.hitFirst(\n  ray,\n  (e) =&gt; {\n    if (e.didHit) {\n      engine.entities[e.entity.entityId].addComponentOrReplace(hitMaterial)\n    }\n  },\n  0\n)\n\n\n\n  Tip: To reference an entity based on its ID, use the engine’s entities array, like this: engine.entities[e.entity.entityId].\n\n\nThe example below does the same, but dealing with an array of entities returned from the hitAll() function:\n\nlet physicsCast = PhysicsCast.instance\n\nlet originPos = new Vector3(2, 1, 4)\nlet direction = new Vector3(0, 1, 1)\n\nlet ray: Ray = {\n  origin: originPos,\n  direction: direction,\n  distance: 10,\n}\n\nphysicsCast.hitAll(\n  ray,\n  (e) =&gt; {\n    if (e.didHit) {\n      for (let entityHit of e.entities) {\n        engine.entities[entityHit.entity.entityId].addComponentOrReplace(\n          hitMaterial\n        )\n      }\n    }\n  },\n  0\n)\n\n\nRecurrent raycasting\n\nIf your scene does raycasting on every frame via a system, then you should be careful about how it affects your scene’s performance.\n\nBoth the hitAll and hitFirst methods have a third argument that takes a raycast id. All raycast queries that share a same id are handled in a lossy queue, so that if these requests pile up over time then only the latest one to arrive is processed. This can potentially save a lot of resources and makes your scene run a lot more smoothly.\n\nIn some cases you may want to have several separate raycast queries running at the same time, for example you might have a character that sends multiple rays in different directions to check for walls as it walks around. In these cases you should make sure that each raycast query has a separate id. Otherwise, if these different queries share a same id, the results of each might overwrite one another and valuable information will be lost on every frame.\n\nconst Ray1 = { origin: Vector3.zero, direction: Vector3.Left() }\nconst Ray2 = { origin: Vector3.zero, direction: Vector3.Right() }\nlet id1: number = 0\nlet id2: number = 1\n\nclass RaycastSystem implements ISystem {\n  update(dt: number) {\n    PhysicsCast.instance().hitFirst(\n      Ray1,\n      (e) =&gt; {\n        // Do stuff\n      },\n      id1\n    )\n\n    PhysicsCast.instance().hitFirst(\n      Ray2,\n      (e) =&gt; {\n        // Do stuff\n      },\n      id2\n    )\n  }\n}\n\nengine.addSystem(RaycastSystem)\n\n\nThis example runs two raycast queries on every frame of the scene. Since they each have a different id, the requests from the first query and from the second query are handled on different queues that are independent from the other."
        }
        
      
    
  
    
      
        ,
        
        "development-guide-scene-metadata": {
          "id": "development-guide-scene-metadata",
          "title": "Scene metadata",
          "categories": "development-guide",
          "url": " /development-guide/scene-metadata/",
          "content": "All scenes have a scene.json file where you can set metadata for the scene. Some fields in this file are predefined with information that’s necessary for the Decentraland client.\n\nYou’re also free to add any fields that you wish. In the future, custom fields can then be checked by alternative clients, or other scripts embedded in interactive inventory items.\n\nScene parcels\n\nWhen deploying a scene, the scene.json file must include information about what parcels will be occupied by this scene in the Decentraland map. The CLI reads this information from off this field and deploys to those parcels directly.\n\n \"scene\": {\n    \"parcels\": [\n      \"54,-14\"\n    ],\n    \"base\": \"54,-14\"\n  }\n\n\nThe default scene has its coordinates set to 0,0, this information is not necessary to change while developing a scene offline, unless you need to occupy multiple parcels. You will need to change this before deploying, to coordinates where you do have deploy permissions.\n\nThe base field defines which parcel to consider the base parcel. If your scene has a single parcel, the base should be that parcel. If your scene has multiple parcels, the base should be the bottom-left (South-West) parcel. All entity positions will be measured in reference to the South-West corner of this parcel.\n\nTo display multiple parcels in the scene preview, list as many parcels as you intend to use. They don’t need to be the exact parcels you’ll deploy to, but they should all be adjacent and arranged in the same way in relation to each other.\n\n \"scene\": {\n    \"parcels\": [\n      \"54,-14\",  \"55,-14\"\n    ],\n    \"base\": \"54,-14\"\n  }\n\n\nSet parcels via the command line\n\nYou can set the parcels in your scene by running the dcl coords command in your scene folder. This is especially useful for large scenes, as you don’t need to list every parcel involved.\n\nSingle parcel\n\nPass a single argument with the scene coords. This coordinate is also set as the base parcel.\n\ndcl coords &lt;parcel&gt;\n\nFor example:\n\ndcl coords 15,-26\n\nMuliple parcels\n\nPass two arguments: the South-West and the North-East parcels. The South-West parcel is also set as the base parcel.\n\ndcl coords &lt;parcel&gt; &lt;parcel&gt;\n\n\n  Tip: The South-West parcel is always the one with the lowest numbers on both the X and Y coordinates.\n\n\nFor example:\n\ndcl coords 15,-26 17,-24\n\nThis command generates a 3x3 scene, with its base parcel in 15,-26.\n\nCustomize Base Parcel\n\nPass three arguments: the South-West and the North-East parcels, and the parcel to use as a base parcel.\n\ndcl coords &lt;parcel&gt; &lt;parcel&gt; &lt;parcel&gt;\n\n\n  Note: The base parcel must be one of the parcels in the scene.\n\n\nNon-square scenes\n\nThe above commands all generate rectangular-shaped scenes. Decentraland scenes can have L shapes or other configurations. You can generate a larger square with dcl coords and then manually remove excess parcels from the scene.json file.\n\n\n  Note: The base parcel must be one of the parcels in the scene.\n\n\nScene title, description, and image\n\nGive your scene a title, a description and a thumbnail image to attract players to your scene and so they know what to expect.\n\nPlayers will see these when they select the parcels of your scene on the map, they will also see these in a confirmation screen when being teleported there by another scene.\n\n\n\nWhen players navigate the world and enter your scene, they are able to read the scene title from under the minimap.\n\n\n\n  \"display\": {\n    \"title\": \"My Cool Scene\",\n\t\"description\": \"You won't believe how cool this scene is\",\n\t\"navmapThumbnail\": \"images/scene-thumbnail.png\",\n    \"favicon\": \"favicon_asset\"\n   }\n\n\nThe thumbnail should be a .png or .jpg image of a recommended size of 228x160 pixels. The minimum supported size is 196x143 pixels. The image may be stretched if the width-to-height proportions don’t match 228x160.\n\nThe image on navmapThumbnail should be a path to an image file in the project folder. It can also be a URL link to an image hosted elsewhere.\n\n\n  Note: If you host an image elsewhere, make sure this is in a site that has permissive CORS policies for displaying content on other sites.\n\n\nContact information\n\nIn case you want other developers to be able to reach out to you, you can add contact information into the scene.json file.\n\n  \"contact\": {\n    \"name\": \"author-name\",\n    \"email\": \"name@mail.com\"\n  },\n\n\nSpawn location\n\nThe spawnPoints field defines where players spawn when they access your scene directly, either by directly typing in the coordinates into the browser or teleporting.\n\nYour scene might have objects that can block players from moving if they happen to spawn right over them, like trees or stairs, or your scene might have an elevated terrain. It would be a bad experience for players if they spawned over something that doesn’t let them move. That’s why you have the option to set multiple spawn positions in ad-hoc locations.\n\n  \"spawnPoints\": [\n    {\n      \"name\": \"spawn1\",\n      \"default\": true,\n      \"position\": {\n        \"x\": 5,\n        \"y\": 1,\n        \"z\": 4\n      }\n    }\n  ],\n\n\nThe position is comprised of coordinates inside the scene. These numbers refer to a position within the parcel, similar to what you’d use in the scene’s code in a Transform component to position an entity.\n\n\n  Note: All spawn points must be within the parcels that make up the scene. You can’t spawn a player outside the space of these parcels.\n\n\nMultiple spawn points\n\nA single scene can have multiple spawn points. This is useful to limit the overlapping of players if they all visit a scene at the same time. To have many spawn points, simply list them as an array.\n\n  \"spawnPoints\": [\n    {\n      \"name\": \"spawn1\",\n      \"default\": true,\n      \"position\": {\n        \"x\": 5,\n        \"y\": 1,\n        \"z\": 4\n      }\n\t},\n\t{\n      \"name\": \"spawn2\",\n      \"default\": true,\n      \"position\": {\n        \"x\": 3,\n        \"y\": 1,\n        \"z\": 1\n      }\n    }\n  ],\n\n\nSpawn points marked as default are given preference. When there are multiple spawn points marked as default, one of them will be picked randomly from the list.\n\n\n  Note: In future releases, when a player tries to spawn into a scene and the default spawn points are occupied by other players, the player will be sent to another of the listed locations. This will open the door to allowing players to teleport to a spawn point based on the spawn point’s name, as described in the scene.json.\n\n\nSpawn regions\n\nYou can set a whole region in the scene to act as a spawn point. By specifying an array of two numbers on any of the dimensions of the position, players will appear in a random location within this range of numbers. This helps prevent the overlapping of entering players.\n\n  \"spawnPoints\": [\n    {\n      \"name\": \"spawn1\",\n      \"default\": true,\n      \"position\": {\n        \"x\": [1,5],\n        \"y\": [1,1],\n        \"z\": [2,4]\n      }\n    }\n  ],\n\n\nIn the example above, players may appear anywhere in the square who’s corners are on 1,1,2 and 5,1,4.\n\nRotation\n\nYou can also specify the rotation of players when they spawn, so that they’re facing in a specific direction. This allows you to have better control over their first impression, and can be useful when wanting to help steer them towards a specific direction.\n\nSimply add a cameraTarget field to the spawn point data. The value of cameraTarget should reference a location in space, with x, y and z coordinates relative to the scene, just like the position field.\n\n  \"spawnPoints\": [\n    {\n      \"name\": \"spawn1\",\n      \"default\": true,\n      \"position\": {\n        \"x\": 5,\n        \"y\": 1,\n        \"z\": 4\n      },\n      \"cameraTarget\": {\n        \"x\": 10,\n        \"y\": 1,\n        \"z\": 4\n      }\n    }\n  ],\n\n\nThis example spawns a player on 5, 1, 4 looking East at 10, 1, 4. If the spawn position is a range, then the player’s rotation will always match the indicated target. If there are multiple spawn points, each can have its own separate target.\n\nRequired Permissions\n\nThe requiredPermissions property manages various controlled features that could be used in an abusive way and damage a player’s experience.\n\nThe corresponding features are blocked from being used by the scene, unless the permission is requested in the scene.json file.\n\n\"requiredPermissions\": [\n    \"ALLOW_TO_MOVE_PLAYER_INSIDE_SCENE\"\n  ],\n\n\nCurrently, only the following permission is handled:\n\n\n  ALLOW_TO_MOVE_PLAYER_INSIDE_SCENE: Refers to moving a Player\n  ALLOW_TO_TRIGGER_AVATAR_EMOTE: Refers to Playing emotes on the player avatar\n\n\nIf a requiredPermissions property doesn’t exist in your scene.json file, create it at root level in the json tree.\n\n\n  Note: In future releases, when a player enters a scene that has items listed in the requiredPermissions property, the scene will prompt the player to grant these permissions. The player will be able to decline these permissions for that scene.\n\n\nFeature Toggles\n\nThere are certain features that can be dissabled in specific scenes so that players can’t use these abusively. The featureToggles property manages these permissions.\n\nThe corresponding features are enabled by default, unless specified as dissabled in the scene.json file.\n\n\"featureToggles\": {\n    \"voiceChat\": \"disabled\"\n},\n\n\nCurrently, only the following feature is handled like this:\n\n\n  voiceChat: Refers to players using their microphones to have conversations over voice chat with other nearby players.\n\n\nIf a featureToggles property doesn’t exist in your scene.json file, create it at root level in the json tree.\n\nFetch metadata from scene code\n\nYou may need a scene’s code to access the fields from the metadata, like the parcels that the scene is deployed to, or the spawn point positions. This is especially useful for scenes that are meant to be replicated, or for code that is meant to be reused in other scenes. It’s also very useful for smart items, where the smart item’s code might for example need to know where the scene limits are.\n\nTo access this data, first import the ParcelIdentity library to your scene:\n\nimport { getParcel } from \"@decentraland/ParcelIdentity\"\n\n\nThen you can call the getParcel() function from this library, which returns a json object that includes much of the contents of the scene.json file.\n\nThe example bleow shows the path to obtain several of the more common fields you might need from this function’s response:\n\nimport { getParcel } from '@decentraland/ParcelIdentity'\n\nexecuteTask(async () =&gt; {\n  const parcel = await getParcel()\n\n  // parcels\n  log('parcels: ', parcel.land.sceneJsonData.scene.parcels)\n  log('base parcel: ', parcel.land.sceneJsonData.scene.base)\n\n  // spawn points\n  log('spawnpoints: ', parcel.land.sceneJsonData.spawnPoints)\n\n  // general scene data\n  log('title: ', parcel.land.sceneJsonData.display?.title)\n  log('author: ', parcel.land.sceneJsonData.contact?.name)\n  log('email: ', parcel.land.sceneJsonData.contact?.email)\n\n  // other info\n  log('tags: ', parcel.land.sceneJsonData.tags)\n})\n\n\n\n  Note: getParcel() needs to be run as an async function, since the response may delay a fraction of a second or more in returning data."
        }
        
      
    
  
    
      
        ,
        
        "development-guide-async-functions": {
          "id": "development-guide-async-functions",
          "title": "Asynchronous code",
          "categories": "development-guide",
          "url": " /development-guide/async-functions/",
          "content": "Overview\n\nMost of the code in your scene runs synchronously using a single thread. That means that commands are executed sequentially line by line. Each command must first wait for the previous command to finish executing before it can start.\n\nEven the update() functions in your scene’s systems are executed one by one, following a priority order.\n\nRunning code synchronously ensures consistency, as you can always be sure you’ll know the order in which the commands in your code run.\n\nOn the other hand, your scene needs to be updated many times per second, building the next frame. If a part of your code takes too long to respond, then the whole main thread is stuck and this results in lagging frame rates.\n\nThat’s why, in some cases you want some commands to run asynchronously. This means that you can start off a task in a new thread, and meanwhile the main thread can keep running over the the next lines of code.\n\nThis is especially useful for tasks that rely on external services that could take time to respond, as you don’t want that idle time waiting for that response to block other tasks.\n\nFor example:\n\n\n  When playing a sound file\n  When retrieving data from a REST API\n  When performing a transaction on the blockchain\n\n\n\n  Note: Keep in mind that several frames of your scene might be rendered before the task finishes executing. Make sure your scene’s code is flexible enough to handle the in-between scenarios while the asynchronous task is being completed.\n\n\nRun an async function\n\nMark any function as async so that it runs on a separate thread from the scene’s main thread every time that it’s called.\n\n// declare function\nasync function myAsyncTask() {\n  // run async steps\n}\n\n// call function\nmyAsyncTask()\n\n// rest of the code keeps being executed\n\n\nThe executeTask function\n\nThe executeTask function executes a lambda function asynchronously, in a separate thread from the scene’s main thread.\n\nexecuteTask(async () =&gt; {\n  let data = await myAsyncTask()\n  log(data)\n})\n\n// rest of the code keeps being executed\n\n\nThe then function\n\nThe then function takes in a lambda function as an argument, that only gets executed once the prior statement is finished. This lambda function can optionally have inputs that are mapped from whatever the prior statement returns.\n\nmyAsyncTask().then((data) =&gt; {\n  log(data)\n})\n\n\n\n  Note: It’s generally better to use the executeTask approach rather than the then function. In this example, the scene won’t be considered fully loaded by the explorer till the myAsyncTask() function is completed, which may affect load times. Also, if relying too much on the then function at multiple nested levels, you can end up with what’s known as “callback hell”, where the code can become very hard to read and maintain.\n\n\nOnPointerDown functions\n\nYou can add an OnPointerDown component to any entity to trigger an asynchronous lambda function every time that entity is clicked.\n\nmyEntity.addComponent(\n  new OnPointerDown((e) =&gt; {\n    log(\"clicked on the entity\", e)\n  })\n)\n\n\nSubscribe a listener\n\nAnother way to run asynchronous code is to instance an event listener. Event listeners trigger the running of an asynchronous lambda function every time that a given event occurs.\n\nInput.instance.subscribe(\"BUTTON_DOWN\", (e) =&gt; {\n  log(\"pointerUp works\", e)\n})\n\n\nThe example above runs a function every time that the button A is pressed down.\n\nThe await statement\n\nAn await statement forces the execution to wait for a response before moving over to the next line of code. await statements can only be used inside an async block of code.\n\n// declare function\nasync function myAsyncTask() {\n  try {\n    let response = await fetch(callUrl)\n    let json = await response.json()\n    log(json)\n  } catch {\n    log(\"failed to reach the URL\")\n  }\n}\n\n// call function\nmyAsyncTask()\n\n// Rest of the code keeps being executed\n\n\nThe example above executes a function that includes a fetch() operation to retrieve data from an external API. The fetch() operation is asynchronous, as we can’t predict how long the server will take to respond. However, the next line needs the output of this operation to be ready before we can parse it as a json. The await statement here ensures that the next line will only run once that operation has returned a value. Similarly, the response.json() function is also asynchronous, but the next line needs the json to be parsed before it can log it. The second await statement forces the next line to only be called once the parsing of the json is finished, however long it takes."
        }
        
      
    
  
    
      
        ,
        
        "development-guide-network-connections": {
          "id": "development-guide-network-connections",
          "title": "Network connections",
          "categories": "development-guide",
          "url": " /development-guide/network-connections/",
          "content": "Your scene can leverage external services that expose APIs, you can use this to obtain updated price data, weather data or any other kind of information exposed by an API.\n\nYou can also set up your own external server to aid your scene and serve to synchronize data between your players. This can either be done with a server that exposes a REST API, or with a server that uses WebSockets.\n\nCall a REST API\n\nYour scene’s code can send calls to a REST API to fetch data.\n\nSince the server might take time to send its response, you must execute this command as an asynchronous function, using executeTask().\n\nexecuteTask(async () =&gt; {\n  try {\n    let response = await fetch(callUrl)\n    let json = await response.json()\n    log(json)\n  } catch {\n    log(\"failed to reach URL\")\n  }\n})\n\n\nThe fetch command can also include a second optional argument that bundles headers, HTTP method and HTTP body into a single object.\n\n\n  url: Address to send the request\n  init: A FlatFetchInit object that may contain:\n    \n      method : HTTP method to use (GET, POST, DELETE, etc)\n      body: Contents of the request body. It must be sent as a stringified JSON object.\n      headers: Additional headers to include in the request. Headers related to the signature are added automatically.\n      \n        \n          \n            \n              redirect: Redirect strategy (‘follow’\n              ‘error’\n              ‘manual’)\n            \n          \n        \n      \n      responseBodyType: Specify if the body of the response is ‘text’ or ‘json’\n    \n  \n\n\nexecuteTask(async () =&gt; {\n  try {\n    let response = await fetch(callUrl, {\n      headers: { \"Content-Type\": \"application/json\" },\n      method: \"POST\",\n      body: JSON.stringify(myBody),\n    })\n    let json = await response.json()\n    log(json)\n  } catch {\n    log(\"failed to reach URL\")\n  }\n})\n\n\nThe fetch command returns a response object with the following data:\n\n\n  headers: A ReadOnlyHeaders object. Call the get() method to obtain a specific header, or the has() method to check if a header is present.\n  ok: Boolean\n  redirected: Boolean\n  status: Status code number\n  statusText: Text for the status code\n  type: Will have one of the following values: basic, cors, default, error, opaque, opaqueredirect\n  \n    url: URL that was sent\n  \n  json(): Obtain the body in JSON format.\n  text(): Obtain the body as text.\n\n\n\n  Note: json() and text() are mutually exclusive. If you obtain the body of the response in one of the two formats, you can no longer obtain the other from the response object.\n\n\n\n  Note: Each Decentraland scene is only permitted to perform one fetch command at a time. This has no effect on how the scene code must be structured, as requests are queued internally. If your scene requires sending multiple requests to different endpoints, keep in mind that each request is only sent when the previous one has been responded.\n\n\nSigned requests\n\nYou can employ an extra security measure to certify that a request is originating from a player session inside Decentraland. You can send your requests with an additional signature, that is signed using an ephemeral key that the Decentraland session generates for each player based on the player’s address. The server receiving the request can then verify that the signed message indeed matches an address that is currently active in-world.\n\nThese kinds of security measures are especially valuable when there may be an incentive for a player to abuse the system, to farm tokens or points in a game.\n\nTo send a signed request, all you need to do is use the signedFetch() function, in exactly the same way as you would use the fetch() function.\n\nexecuteTask(async () =&gt; {\n  try {\n    let response = await signedFetch(callUrl, {\n      headers: { \"Content-Type\": \"application/json\" },\n      method: \"POST\",\n      body: JSON.stringify(myBody),\n    })\n\n    if (!response.text) {\n      throw new Error(\"Invalid response\")\n    }\n\n    let json = await JSON.parse(response.text)\n\n    log(\"Response received: \", json)\n  } catch {\n    log(\"failed to reach URL\")\n  }\n})\n\n\nThe request will include an additional series of headers, containing a signed message and a set of metadata to interpret that. The signed message consists of all the contents of the request encrypted using the player’s ephemeral key.\n\nThe signedFetch() differs from the fetch() function in that the response is a promise of a full http message, expressed as a FlatFetchInit object. This includes the properties text, ok, status, headers, among others. By default, the To access the body of the response, parse the text property of the response as in the example above. If the response body is in json format, you can specify that in the responseBodyType and then access that from the json property in the response.\n\nValidating a signed request\n\nTo make make use of signed requests, the server receiving these should to validate that the signatures match the rest of the request, and that the timestamp that’s encoded within the signed message is current.\n\nYou can find a simple example of a server performing this task in the following example scene:\n\nValidate player authenticity\n\nUse WebSockets\n\nYou can also send and obtain data from a WebSocket server, as long as this server uses a secured connection with wss.\n\nvar socket = new WebSocket(\"url\")\n\nsocket.onmessage = function (event) {\n  log(\"WebSocket message received:\", event)\n}\n\n\nThe syntax to use WebSockets is no different from that implemented natively by JavaScript. See the documentation from Mozilla Web API for details on how to catch and send messages over WebSockets.\n\n\n  TIP: One library that simplifies the use of websocket connections and has been proven to work very well with Decentraland is Colyseus. It builds a layer of abstraction on top of the websocket connections that makes reacting to changes and storing a consistent game state remotely in the server super easy. You can see it in action in these examples. Several other websocket libraries aren’t compatible with the Decentraland SDK."
        }
        
      
    
  
    
      
        ,
        
        "development-guide-event-listeners": {
          "id": "development-guide-event-listeners",
          "title": "Event listeners",
          "categories": "development-guide",
          "url": " /development-guide/event-listeners/",
          "content": "There are several events that the scene can subscribe to, to know the actions of the player while in or near the scene.\n\nFor button and click events performed by the player, see Button events.\n\nPlayer connects or disconnects\n\nWhenever another player starts or stops being rendered by the local engine, this creates an event you can listen to. Players may or may not be standing on the same scene as you, but must be within visual range (not necessarily in sight). The onPlayerConnectedObservable detects both when a player newly connects nearby or comes close enough to be in visual range, likewise the onPlayerDisconnectedObservable detects when a player ends their session or or walks far away.\n\nonPlayerConnectedObservable.add((player) =&gt; {\n  log(\"player entered: \", player.userId)\n})\n\nonPlayerDisconnectedObservable.add((player) =&gt; {\n  log(\"player left: \", player.userId)\n})\n\n\nKeep in mind that if other players are already being rendered in the surroundings before the player has loaded your scene, this event won’t notify the newly loaded scene of the already existing players. If you need to keep track of all current players, you can query for existing players upon scene loading, and then listen to this event for updates.\n\nimport { getConnectedPlayers } from \"@decentraland/Players\"\n\nexecuteTask(async () =&gt; {\n  let players = await getConnectedPlayers()\n  players.forEach((player) =&gt; {\n    log(\"player was already here: \", player.userId)\n  })\n})\n\n\nPlayer enters or leaves scene\n\nWhenever an avatar steps inside or out of the parcels of land that make up your scene, or teleports in or out, this creates an event you can listen to. This event is triggered by all avatars, including the player’s.\n\nonEnterSceneObservable.add((player) =&gt; {\n  log(\"player entered scene: \", player.userId)\n})\n\nonLeaveSceneObservable.add((player) =&gt; {\n  log(\"player left scene: \", player.userId)\n})\n\n\n\n  Note: This event only responds to players that are currently being rendered locally. In large scenes where the scene size exceeds the visual range, players entering in the opposite corner may not be registered. If the number of players in the region exceeds the capabilities of an island on Decentraland servers, players that are not sharing a same island aren’t visible and are not tracked by these events either.\n\n\nOnly current player\n\nYou can filter out the triggered events to only react to the player’s avatar, rather than other avatars that may be around.\n\nimport { getUserData } from \"@decentraland/Identity\"\n\nexecuteTask(async () =&gt; {\n  let myPlayer = await getUserData()\n\n  onEnterSceneObservable.add((player) =&gt; {\n    log(\"player entered scene: \", player.userId)\n    if (player.userId === myPlayer?.userId) {\n      log(\"I entered the scene!\")\n    }\n  })\n\n  onLeaveSceneObservable.add((player) =&gt; {\n    log(\"player left scene: \", player.userId)\n    if (player.userId === myPlayer?.userId) {\n      log(\"I left the scene!\")\n    }\n  })\n})\n\n\nThis example first obtains the player’s id, then subscribes to the events and compares the userId returned by the event to that of the player.\n\nQuery all players in scene\n\nYou can also get the full list of players who are currently on your scene and being rendered by calling getPlayersInScene().\n\nimport { getPlayersInScene } from \"@decentraland/Players\"\n\nexecuteTask(async () =&gt; {\n  let players = await getPlayersInScene()\n  players.forEach((player) =&gt; {\n    log(\"player was already here: \", player.userId)\n  })\n})\n\n\n\n\nPlayer changes camera mode\n\nWhen the player changes the camera mode between 1st and 3rd person in or near your scene, this creates an event you can listen to.\n\nonCameraModeChangedObservable.add(({ cameraMode }) =&gt; {\n  log(\"Camera mode changed:\", cameraMode)\n})\n\n\nThe values of the returned property can be:\n\n\n  CameraMode.FirstPerson\n  CameraMode.ThirdPerson\n\n\nThis event is fired once when the scene first obtains information about the player’s current camera mode, and then any time the player changes camera mode while in or around your scene.\n\n\n  Tip: To encourage players to use a particular camera mode in your scene, display a UI message advising them to switch modes whenever they use the wrong one.\n\n\nKnowing the camera mode can be very useful to fine-tune the mechanics of your scene to better adjust to what’s more comfortable using this mode. For example, small targets are harder to click when on 3rd person.\n\nPlayer plays animation\n\nWhenever the player plays an emote (dance, clap, wave, etc), you can detect this event.\n\nonPlayerExpressionObservable.add(({ expressionId }) =&gt; {\n  log(\"Expression: \", expressionId)\n})\n\n\nThe event includes the following information:\n\n\n  expressionId: Name of the emote performed (ie: wave, clap, kiss)\n\n\nNote: This event is triggered any time the player makes an emote and the scene is loaded. The player could be standing in a nearby scene when this happens.\n\nPlayer clicks on another player\n\nWhenever the player clicks on another player, you can detect an event.\n\nonPlayerClickedObservable.add((clickEvent) =&gt; {\n  log(\"Clicked \", clickEvent.userId, \" details: \", clickEvent.ray)\n})\n\n\nNote: Both the player performing the click and the player being clicked must be standing within the parcels of the scene. This listener only detects events of the current player clicking on other players, not those of clicks performed by other players.\n\nThe event includes the following data:\n\n\n  userId: The id of the clicked player\n  ray: Data about the ray traced by the click\n    \n      direction: Vector3 A normalized Vector3 that represents the direction from the point of origin of the click to the hit point of the click.\n      distance: number The distance in meters from the point of origin to the hit point.\n      origin: Vector3 The point of origin of the click, the position of the player who did the click, relative to the scene.\n    \n  \n\n\nTip: The default behavior of clicking on another player is opening the player passport, where you can see additional information about that player, add them as a friend, etc. You can disable the opening of this UI so that it doesn’t get in the way of the experience you want to build by adding an Avatar Modifier Area.\n\nPlayer locks/unlocks cursor\n\nPlayers can switch between two cursor modes: locked cursor mode to control the camera or unlocked cursor mode for moving the cursor freely over the UI.\n\nPlayers unlock the cursor by clicking the Right mouse button or pressing the Esc key, and lock the cursor back by clicking anywhere in the screen.\n\nThis onPointerLockedStateChange event is activated each time a player switches between these two modes, while near the scene.\n\nonPointerLockedStateChange.add(({ locked }) =&gt; {\n  if (locked) {\n    log(\"Pointer has been locked\")\n  } else {\n    log(\"Pointer has been unlocked\")\n  }\n})\n\n\n\n  Note: This event is triggered even if the player is not standing directly inside the scene.\n\n\nThe locked property from this event is a boolean value that is true when the player locks the cursor and false when the player unlocks the cursor.\n\nThis event is useful if the player needs to change cursor modes and may need a hint for how to lock/unlock the cursor.\n\nThis can also be used in scenes where the player is expected to react fast, but the action can take a break while the player has the cursor unlocked.\n\nPlayer goes idle\n\nWhenever the player is inactive for a full minute, without interacting with any input being picked up by the Decentraland explorer, we can consider the player to be idle. Whenever this happens, it creates an event that you can listen to.\n\nonIdleStateChangedObservable.add(({ isIdle }) =&gt; {\n  log(\"Idle State change: \", isIdle)\n})\n\n\nThe isIdle property is a boolean value that is true when the player enters the idle mode and false when the player leaves the idle mode.\n\nThis event is especially useful for multiplayer scenes, when you might want to disconnect from the server players who are likely away from the machine or left Decentraland in a tab in the background.\n\n\n  Note: The idle state is inferred based on the player not using the keyboard or mouse for a full minute. This can of course produce false positives, for example a player might be watching other players interact or watching a video stream, standing still but fully engaged. Be mindful of these corner cases and what the experience is like for a player who stands still for a while.\n\n\nPlayer changes profile\n\nWhenever the player makes a change to their profile, the onProfileChanged event is called. These changes may include putting on different wearables, changing name, description, activating portable experiences, etc.\n\nonProfileChanged.add((profileData) =&gt; {\n  log(\"Own profile data is \", profileData)\n})\n\n\nEvent data includes only the ID of the player and a version number for that avatar’s profile, according to the catalyst server. Every time a change is propagated, the version number increases by 1.\n\n\n  Tip: When this event is triggered, you can then use the getUserData() function to fetch the latest version of this information, including the list of wearables that the player has on. You may need to add a slight delay before you call getUserData() to ensure that the version this function returns is up to date.\n\n\nWhen testing in preview, run the scene with dcl start --web3 so that you connect with your wallet. Otherwise, you will be using a random avatar.\n\n\n  Note: This event is only triggered by changes to the current player, not by changes on the profiles of other nearby players.\n\n\nScene finished loading\n\nWhen the scene finishes loading, the onSceneReadyObservable gets called. This works both if the player loads straight into the scene, or if the player walks up to the scene from somewhere else. When all of the content in the scene has finished its initial load, including heavy models, etc, this event is called.\n\nonSceneReadyObservable.add(() =&gt; {\n  log(\"SCENE LOADED\")\n})\n\n\nVideo playing\n\nWhen a VideoTexture changes its playing status, the onVideoEvent observable receives an event.\n\nonVideoEvent.add((data) =&gt; {\n  log(\"New Video Event \", data)\n})\n\n\nThe input of a video event contains the following properties:\n\n\n  videoClipId ( string): The ID for the VideoTexture component that changed status.\n  componentId (string): The ID of the VideoTexture component that changed status.\n  currentOffset (number): The current value of the seek property on the video. This value shows seconds after the video’s original beginning. -1 by default.\n  totalVideoLength (number ): The length in seconds of the entire video. -1 if length is unknown.\n  \n    videoStatus: The value for the new video status of the VideoTexture, expressed as a value from the VideoStatus enum. This enum can hold the following possible values:\n  \n  VideoStatus.NONE = 0,\n  VideoStatus.ERROR = 1,\n  VideoStatus.LOADING = 2,\n  VideoStatus.READY = 3,\n  VideoStatus.PLAYING = 4,\n  VideoStatus.BUFFERING = 5\n\n\nLearn more about playing videos in Decentraland in Video Playing.\n\nPlayer changes realm or island\n\nPlayers in decentraland exist in separate realms, and in separate islands within each realm. Players in different realms or islands cant see each other, interact or chat with each other, even if they’re standing on the same parcels.\n\nEach time the player changes realms or island, the onRealmChangedObservable event gets called.\n\nonRealmChangedObservable.add((realmChange) =&gt; {\n  log(\"PLAYER CHANGED ISLAND TO \", realmChange.room)\n})\n\n\nThis event includes the following fields:\n\n\n  serverName: string; The catalyst server name.\n  room: string; The island name.\n  displayName: string; The catalyst server name followed by a - and the island name. For example unicorn-x011.\n  domain: string; The url to the catalyst server being used.\n\n\nAs players move through the map, they may switch islands to be grouped with those players who are now closest to them. Islands also shift their borders dynamically to fit a manageable group of people in each. So even if a player stands still they could be changed island as others enter and leave surrounding scenes.\n\nIf your scene relies on a 3rd party server to sync changes between players in real time, then you may want to only share data between players that are grouped in a same realm+island, so it’s a good practice to change rooms in the 3rd party server whenever players change island.\n\nPlayer starts/ends the tutorial\n\nWhen a new player first enters Decentraland for the fist time, they go through a brief tutorial that shows the basic movements and UI elements. Typically players will experience this on Genesis Plaza, but a new player that enters a specific scene from an event as their first time in Decentraland will experience a shortened version of that tutorial wherever they are.\n\nThis tutorial includes some music, that could clash with the music of the scene that the player is currently on, so it’s recommended to stop any background music in case the player is going through the tutorial.\n\nimport { tutorialEnableObservable } from \"src/modules/tutorialHandler\"\n\ntutorialEnableObservable.add((tutorialEnabled) =&gt; {\n  if (tutorialEnabled) {\n    log(\"Player started tutorial\")\n    backgroundMusicSource.playing = false\n  } else {\n    log(\"Player finished tutorial\")\n    backgroundMusicSource.playing = true\n  }\n})\n\n\n\n  Note: This event only occurs when the player starts or ends the tutorial. It doesn’t get called at all in case the player has already experienced the tutorial in a prior session or scene."
        }
        
      
    
  
    
      
        ,
        
        "development-guide-user-data": {
          "id": "development-guide-user-data",
          "title": "Player data",
          "categories": "development-guide",
          "url": " /development-guide/user-data/",
          "content": "Track player position and rotation\n\nThe Camera object exposes information about the player’s point of view in your scene.\n\n\n  Camera.instance.position returns a 3D vector with the coordinates of the avatar’s center, relative to the scene. When the player is on the ground, the height of this point is approximately 1.177 m. In 3rd person camera mode, this value refers also to the avatar’s center, not to the position of the 3rd person camera.\n  Camera.instance.feetPosition returns a 3D vector with the coordinates of the player’s feet relative to the scene. When the player is at ground level, the height is nearly 0.155.\n  Camera.instance.worldPosition returns a 3D vector with the coordinates of the player’s center, relative to the whole of Genesis City. For example, if the scene is in coordinates 100,-100, and the player is standing on the bottom-left corner of that scene, the player’s world position will be about 1600, 1.177, -1600\n  Camera.instance.rotation returns a quaternion with the player’s rotation. In 3rd person camera mode, this refers to the 3rd person camera angle, not the direction faced by the avatar.\n  Camera.instance.rotation.eulerAngles returns a Vector3 with the player’s rotation. In 3rd person camera mode, this refers to the 3rd person camera angle, not the direction faced by the avatar.\n\n\nlog(Camera.instance.feetPosition)\nlog(Camera.instance.rotation.eulerAngles)\n\n\nThe example above logs the player’s position and rotation.\n\nclass CubeRotateSystem implements ISystem {\n  entity: Entity\n  constructor(entity: Entity) {\n    this.entity = entity\n  }\n\n  update() {\n    const transform = this.entity.getComponent(Transform)\n    transform.rotation = Camera.instance.rotation\n  }\n}\n\nconst cube = new Entity()\ncube.addComponent(new BoxShape())\ncube.addComponent(new Transform({ position: new Vector3(5, 1, 5) }))\nengine.addEntity(cube)\n\nengine.addSystem(new CubeRotateSystem(cube))\n\n\nThe example above uses the player’s rotation to set that of a cube in the scene.\n\n\n  Note: The Camera.instance data is updated at a throttled rate of 10 times per second. Due to this, positions &amp; rotations may lag slightly in relation to the scene that runs at 30 FPS under ideal conditions.\n\n\n\n\nGet player data\n\nThe following data can be fetched from a player:\n\n\n  displayName: (string) The player’s user name, as others see in-world\n  userId: (string) A UUID string that identifies the player. If the player has a public key, this field will have the same value as the public key.\n  publicKey: (string) The public key of the player’s Ethereum wallet. If the player logs in as a guest, with no linked wallet, this field will be null.\n  hasConnectedWeb3: (boolean) Indicates if the player has a public key. True if the player has one.\n  avatar: A nested object with data about the player’s appearance.\n  version: (number) A version number that increases by one every time the player changes any of their settings. Use this if you encounter conflicting data, to know what version is more recent.\n\n\n\n  Note: For any Ethereum transactions with the player, always use the publicKey field, instead of the userId, to avoid dealing with non-existing wallets.\n\n\nThe avatar object has the following nested information:\n\n\n  wearables: WearableId[] An array of identifiers for each of the wearables that the player is currently wearing. For example urn:decentraland:off-chain:base-avatars:green_hoodie. All wearables have a similar identifier, even if they’re NFTs.\n  \n    bodyShape: An identifier for the avatar’s general body shape. Either urn:decentraland:off-chain:base-avatars:BaseFemale for female or urn:decentraland:off-chain:base-avatars:BaseMale for male.\n  \n  skinColor: ColorString A hex value for the player’s skin color.\n  hairColor: ColorString A hex value for the player’s hair color.\n  eyeColor: ColorString A hex value for the player’s eye color.\n  snapshots: A nested object with base64 representations of .jpg images of the player in various resolutions.\n    \n      face256: string The player’s face as a 256x256 pixel image.\n      body: string The full resolution image of the player standing straight, with 512x1024 pixels.\n    \n  \n\n\n\n  WARNING: The snapshots of the avatar will be deprecated in the future and will no longer be returned as part of an avatar’s data. The recommended approach is to use AvatarTexture instead, see Avatar Portraits ).\n\n\nData from current player\n\nTo obtain information from the current player that’s running the scene, use getUserData().\n\nThe example below imports the Identity library and runs getUserData().\n\nimport { getUserData } from \"@decentraland/Identity\"\n\nexecuteTask(async () =&gt; {\n  let data = await getUserData()\n  log(data)\n})\n\n\nThe function returns the entire set of data described above, including address, name, wearables, snapshots, etc.\n\n\n  Tip: The getUserData() function is asynchronous. See Asynchronous functions if you’re not familiar with those.\n\n\n\n  Note: When running a local preview, use dcl start --web3 to connect with your wallet and fetch your actual data. Otherwise, the preview uses random user data, just as when you enter as a guest.\n\n\nData from nearby players\n\nYou can obtain data from other players that are nearby, by calling getPlayerData(), passing the id of a Decentraland account.\n\nimport { getPlayerData } from \"@decentraland/Players\"\n\nexecuteTask(async () =&gt; {\n  let data = await getPlayerData({ userId: \"0x….\" })\n  log(data)\n})\n\n\nThe function returns the entire set of data described above, including address, name, wearables, snapshots, etc.\n\n\n  Tip: The getPlayerData() function is asynchronous. See Asynchronous functions if you’re not familiar with those.\n\n\ngetPlayerData() can only fetch data from players who are currently nearby. They don’t have to be necessarily standing in the same scene, but in visual range, that’s because this information is being fetched from the local engine that’s rendering these avatars. To try this out in preview, open a second tab and log in with a different account.\n\n\n  Note: User IDs must always be lowercase. If copying a wallet address, make sure all the characters are set to lowercase.\n\n\nTo know what players are being rendered in the surroundings, use getConnectedPlayers(). This function returns an array with the ids of all the players that are currently being rendered, which are all eligible to call with getPlayerData(). You can pair this with listening for new players connecting and disconnecting by using onPlayerConnectedObservable and onPlayerDisconnectedObservable.\n\nimport { getConnectedPlayers } from \"@decentraland/Players\"\n\n// Get already connected players\nexecuteTask(async () =&gt; {\n  let players = await getConnectedPlayers()\n  players.forEach((player) =&gt; {\n    log(\"player is nearby: \", player.userId)\n  })\n})\n\n// Event when player connects\nonPlayerConnectedObservable.add((player) =&gt; {\n  log(\"player entered: \", player.userId)\n})\n\n// Event when player disconnects\nonPlayerDisconnectedObservable.add((player) =&gt; {\n  log(\"player left: \", player.userId)\n})\n\n\nAs an alternative, you can use getPlayersInScene() to only fetch the players that are standing within the scene boundaries and also being rendered. You can pair this with listening to new players entering and leaving the scene by using onEnterSceneObservable and onLeaveSceneObservable.\n\nimport { getPlayersInScene } from \"@decentraland/Players\"\n\n// Get all players already in scene\nexecuteTask(async () =&gt; {\n  let players = await getPlayersInScene()\n  players.forEach((player) =&gt; {\n    log(\"player is nearby: \", player.userId)\n  })\n})\n\n// Event when player enters scene\nonEnterSceneObservable.add((player) =&gt; {\n  log(\"player entered scene: \", player.userId)\n})\n\n// Event when player leaves scene\nonLeaveSceneObservable.add((player) =&gt; {\n  log(\"player left scene: \", player.userId)\n})\n\n\n\n  TIP: Read more about onPlayerConnectedObservable and onPlayerDisconnectedObservable in Player connects or disconnects and about about onEnterSceneObservable and onLeaveSceneObservable in Player enters or leaves scene.\n\n\nListen for events when players connect and disconnect\nAs more players connect and disconnect, you can pic\n\nData from any player\n\nTo obtain information from any player, make a REST API call to the content servers. This returns the same information as the getUserData() and getPlayerData() functions, detailed at the start of the section.\n\nThis information is exposed in the following URL, appending the player’s user id to the url parameter.\n\nhttps://peer.decentraland.org/lambdas/profile/&lt;player user id&gt;\n\n\n  Tip: Try the URL out in a browser to see how the response is structured.\n\n\nUnlike getPlayerData(), this option is not limited to just the players who are currently being rendered in the surroundings. With this approach you can fetch data from any player that has logged onto the servers in the past.\n\nIf you know which server the player you want to query is connected to, you can get more up-to-date data by sending your requests to that specific server. For example, if the player changes clothes, this information will be available instantly in the player’s server, but will likely take a couple of minutes to propagate to the peer.decentraland.org server.\n\nhttps://&lt;player server&gt;/lambdas/profile/&lt;player user id&gt;\n\n\n  Tip: You can obtain the current player’s server by doing getCurrentRealm().domain.\n\n\nThis example combines getUserData() and getCurrentRealm() to obtain the player’s data directly from the server that the player is on:\n\nimport { getUserData } from \"@decentraland/Identity\"\nimport { getCurrentRealm } from \"@decentraland/EnvironmentAPI\"\n\nasync function fetchPlayerData() {\n  const userData = await getUserData()\n  const playerRealm = await getCurrentRealm()\n\n  let url = `{playerRealm.domain}/lambdas/profile/{userData.userId}`.toString()\n  log(\"using URL: \", url)\n\n  try {\n    let response = await fetch(url)\n    let json = await response.json()\n\n    log(\"full response: \", json)\n    log(\"player is wearing :\", json[0].metadata.avatars[0].avatar.wearables)\n    log(\"player owns :\", json[0].metadata.avatars[0].inventory)\n  } catch {\n    log(\"an error occurred while reaching for player data\")\n  }\n}\n\nfetchPlayerData()\n\n\nGet player’s public Ethereum key\n\nAs an alternative to getUserData(), you can obtain a player’s public Ethereum key by using getUserPublicKey(). You can then use this information to send payments to the player, or as a way to recognize players.\n\nThe example below imports the Identity library and runs getUserPublicKey() to get the public key of the player’s Ethereum account and log it to console. The player must be logged into their Metamask account on their browser for this to work.\n\nimport { getUserPublicKey } from \"@decentraland/Identity\"\n\nconst publicKeyRequest = executeTask(async () =&gt; {\n  const publicKey = await getUserPublicKey()\n  log(publicKey)\n  return publicKey\n})\n\n\n\n  Tip: The getUserPublicKey() function is asynchronous. See Asynchronous functions if you’re not familiar with those.\n\n\nGet player realm data\n\nPlayers in decentraland exist in several separate realms. Players in different realms can’t see each other, interact or chat with each other, even if they’re standing on the same parcels. Dividing players like this allows Decentraland to handle an unlimited amount of players without running into any limitations. It also pairs players who are in close regions, to ensure that ping times between players that interact are acceptable.\n\nIf your scene sends data to a 3rd party server to sync changes between players in real time, then it’s often important that changes are only synced between players that are on the same realm. You should handle all changes that belong to one realm as separate from those on a different realm. Otherwise, players will see things change in a spooky way, without anyone making the change.\n\nimport { getCurrentRealm } from \"@decentraland/EnvironmentAPI\"\n\nexecuteTask(async () =&gt; {\n  let realm = await getCurrentRealm()\n  log(`You are in the realm: `, realm.displayName)\n})\n\n\nDecentraland handles its communications between players (including player positions, chat, messageBus messages and smart item state changes) through a decentralized network of communication servers. Each one of these servers can support multiple separate islands, each grouping a different set of players that are near each other on the Decentraland map.\n\nThe getCurrentRealm() function returns the following information:\n\n\n  displayName: (string) The full address of the realm, composed of the server + the layer\n  domain: (string) The URL of the server\n  serverName: (string) The name of the server\n\n\n\n  Tip: The getCurrentRealm() function is asynchronous. See Asynchronous functions if you’re not familiar with those.\n\n\nAs players move through the map, they may switch islands to be grouped with those players who are now closest to them. Islands also shift their borders dynamically to fit a manageable group of people, so even if a player stands still, as players enter and leave the world, the player could find themselves on another island.\n\nSee onRealmChangedObservable for how to detect changes regarding the player’s realm or island.\n\n\n  Note: When the scene first loads, there might not yet be an island assigned for the player. The explorer will always eventually assign an island to the player, but this can sometimes occur a couple of seconds after the scene is loaded.\n\n\nGet player platform\n\nPlayers can access Decentraland via various platforms, currently via the browser or via the native desktop app.\n\nUse getPlatform() to know what platform the current player is running Decentraland on.\n\nimport { getPlatform, Platform } from \"@decentraland/EnvironmentAPI\"\n\nexecuteTask(async () =&gt; {\n  let data = await getPlatform()\n  log(data)\n  if (data === Platform.BROWSER) {\n    log(\"In browser\")\n  } else if (data === Platform.DESKTOP) {\n    log(\"In native desktop app\")\n  }\n})\n\n\nPlayers using the desktop app are likely to have a much smoother experience than those on the browser, since the browser imposes performance limitations on how much of the machine’s processing power the browser tab can use. You could use this information to render higher quality materials or other performance-heavy improvements only for players on desktop, as they are less likely to suffer bad frame rate from the extra content.\n\nGet Portable Experiences\n\nPortable experiences are essentially scenes that are not constrained to parcels of land. Players can carry these with them anywhere they go in Decentraland, adding a new layer of content over the world. Smart Wearables are examples of portable experiences. You may want to know if a player is wearing one of these, since a smart wearable may enable players to have abilities that could be considered cheating in a competitive game. For example, in a platform game, a player that wears a jetpack has a very unfair advantage over others.\n\nAs a scene creator, you may want to limit what players wearing portable experiences can do in your scene. Use getPortableExperiencesLoaded() to check if the player has any portable experiences currently activated.\n\nexecuteTask(async () =&gt; {\n  let portableExperiences = await getPortableExperiencesLoaded()\n  log(portableExperiences)\n})\n\n\ngetPortableExperiencesLoaded() returns an array of objects, each of these objects includes an id attribute. In the case of wearables, the id is the wearable’s URN.\n\nGet detailed info about all wearables\n\nMake a REST API call to the following URL, to obtain a full updated list of all wearables that are currently usable, with details about each.\n\nhttps://dcl-wearables-dev.now.sh/expected.json\n\nThis feature could be used together with fetching info about the player, to for example only allow players to enter a place if they are wearing any wearable from the halloween collection, or any wearable that is of legendary rarity.\n\n\n  Tip: Try the URL out in a browser to see how the response is structured.\n\n\nasync function fetchWearablesData() {\n  let url = `https://dcl-wearables-dev.now.sh/expected.json`\n\n  try {\n    let response = await fetch(url)\n    let json = await response.json()\n    log(\"full response: \", json)\n  } catch {\n    log(\"an error occurred while reaching for wearables data\")\n  }\n}\n\nexecuteTask(fetchWearablesData)\n\n\nCheck the player’s camera mode\n\n\n  Note: Camera.instance.cameraMode is currently deprecated and is not always reliable. The recommended approach is to track camera change events with onCameraModeChangedObservable. This event is fired once when the scene first obtains information about the player’s current camera mode, and then any time the player changes camera mode while in or around your scene. See Event Listeners.\n\n\nPlayers can either be using a 1st or 3rd person camera when exploring Decentraland. Check which of these the player is using by checking the value Camera.instance.cameraMode.\n\nThe value of this property can either be CameraMode.FirstPerson or CameraMode.ThirdPerson.\n\nif (Camera.instance.cameraMode == CameraMode.FirstPerson) {\n  log(\"The player is using the 1st person camera\")\n} else {\n  log(\"The player is using the 3rd person camera\")\n}\n\n\nThe Camera.instance.cameraMode property is read-only, you can’t force the player to change camera mode.\n\n\n  Tip: To encourage players to use a particular camera mode in your scene, display a UI message advising them to switch modes whenever they use the wrong one.\n\n\nKnowing the camera mode can be very useful to fine-tune the mechanics of your scene to better adjust to what’s more comfortable using this mode. For example, small targets are harder to click when in 3rd person."
        }
        
      
    
  
    
      
        ,
        
        "development-guide-custom-events": {
          "id": "development-guide-custom-events",
          "title": "Custom events",
          "categories": "development-guide",
          "url": " /development-guide/custom-events/",
          "content": "Sometimes it’s useful to decouple the different parts of your scene’s code and make them interact with each other via sending events.\n\nDecentraland scenes handle some default events like click events and buttonDown or buttonUp events, but you can create your own to handle things that are specific to your scene.\n\nFor example, you could have a pickedCoin event that’s emitted every time the player picks up a coin in your scene. You could then have a score board that listens for these events and updates the score accordingly. Thanks to this, the part of your code that handles the picking of coins doesn’t need to have any reference to the part of the code that updates the scoreboard.\n\nInitiate the event manager\n\nBefore you can emit or listen for events, you need to initiate the event manager in your scene.\n\nconst events = new EventManager()\n\n\nDefine event types\n\nIf you want events in your scene to contain custom data fields, you need to define a specific type for your events. You do this by defining a class that has an @EventConstructor() decorator.\n\n@EventConstructor()\nclass MyEvent {\n  field1: string\n  field2: number\n  constructor(public field1: string, public field2: number) {\n    this.field1 = field1\n    this.field2 = field2\n  }\n}\n\n\nEmit events\n\nTo emit an event, you call the fireEvent() function of the event manager.\n\nevents.fireEvent(new MyEvent(field1, field2))\n\n\nNote that in this example, the event being sent contains an object of a custom event type.\n\nListen for events\n\nTo listen for an event, you can add call the addListener() function of the event manager. This function takes in the following arguments:\n\n\n  The type of the event object to listen for.\n  The listener to use. This will almost always be null.\n  The function to execute every time the event is caught.\n\n\nevents.addListener(MyEvent, null, ({ field1, field2 }) =&gt; {\n  // function\n})\n\n\nFull example\n\nThe following example scene emits and listens for events.\n\n// Initiate event manager\nconst events = new EventManager()\n\n// Define an event type\n@EventConstructor()\nclass UpdateEvent {\n  entity: Entity\n  dt: number\n  constructor(public entity: Entity, public dt: number) {\n    this.entity = entity\n    this.dt = dt\n  }\n}\n\n// Define a system\nexport class RotatorSystem implements ISystem {\n  group = engine.getComponentGroup(Transform)\n\n  update(dt: number) {\n    for (let entity of this.group.entities) {\n      // Emit custom event\n      events.fireEvent(new UpdateEvent(entity, dt))\n    }\n  }\n}\n\nengine.addSystem(new RotatorSystem())\n\n// Add a listener\nevents.addListener(UpdateEvent, null, ({ entity, dt }) =&gt; {\n  const transform = entity.getComponent(Transform)\n  const euler = transform.rotation.eulerAngles\n  euler.y += dt * 10\n  transform.rotation.eulerAngles = euler\n})\n\n// Add an entity to work with\nconst cube = new Entity()\nconst transform = new Transform()\n\ncube.addComponentOrReplace(transform)\ntransform.position.set(5, 0, 5)\n\nconst boxShape = new BoxShape()\ncube.addComponentOrReplace(boxShape)\n\nengine.addEntity(cube)"
        }
        
      
    
  
    
      
        ,
        
        "releases-sdk-sdk-roadmap": {
          "id": "releases-sdk-sdk-roadmap",
          "title": "SDK Roadmap",
          "categories": "releases, sdk",
          "url": " /releases/sdk/sdk-roadmap/",
          "content": "Next features\n\n\n  Collision triggers: - When overlapping with area - When in contact with surface\n  Raycasting additional features: - Ray hits on avatars - Filtering layers - Sphere casting\n\n\nLater\n\n\n  Easier Multiplayer tools\n  Extensions to Transform component: - Global position/rotation/scale (not relative to parent) - Forward vector - Clone Transform component\n  Event when player leaves scene\n  Attach an entity to be fixed to the player\n  Improvements adding sound to a scene\n  Reposition a player to a spawn point via code\n  Fetch data from the scene’s parcels to know size and shape of the scene"
        }
        
      
    
  
    
      
        ,
        
        "development-guide-onscreen-ui": {
          "id": "development-guide-onscreen-ui",
          "title": "2D UI",
          "categories": "development-guide",
          "url": " /development-guide/onscreen-ui/",
          "content": "There are several special component types that are meant for using in a 2D screen space as part of the UI, instead of in the 3D world space. These components are displayed fixed on the player’s screen.\n\nUI elements are only visible when the player is standing inside the scene’s LAND parcels, as neighboring scenes might have their own UI to display. When the player clicks the close UI button, on the bottom-right corner of the screen, all UI elements go away.\n\nThe UI can also be triggered to open when certain events occur in the world-space, for example if the player clicks on a specific place.\n\nThe default Decentraland explorer UI includes a chat widget, a map, and other elements. These UI elements are always displayed on the top layer, above any scene-specific UI. So if your scene has UI elements that occupy the same screen space as these, they will be occluded.\n\nAdd a Screenspace UI\n\nTo add a screenspace UI to your scene, you must create a UICanvas component, this component doesn’t need to belong to any Entities to work. All the visible UI elements that you want the player to see are added as additional objects that are children of this parent component.\n\n\n\n// Create screenspace component\nconst canvas = new UICanvas()\n\n// Create a textShape component, setting the canvas as parent\nconst text = new UIText(canvas)\ntext.value = \"Hello world!\"\n\n\n\n  Note: Create only one UICanvas per scene. To have different menus that appear at different times, make them all children of the same UICanvas, and set their visibility at that level.\n\n\nTypes of UI content\n\nThere are several different types of UI elements you can add to the screenspace:\n\n\n  \n    Images: Add a UIImage component to display any image. Use the source field to point to the path of the image.\n  \n  \n    Text: Add a UITextcomponent to display text. The properties you can set are the same as in a TextShape component. See text.\n  \n\n\n\n\n\n  \n    Text input box: Add a UIInputText to have an input box where players can type in text with their keyboards or their mobile devices.\n  \n  \n    Scrollable rectangle: Add a UIScrollRect to have an area that can be filled with content. The rectangle can optionally have a slider if the content exceeds the rectangle area. Players can drag this slider to explore the contents of the rectangle.\n  \n\n\nPositioning\n\nAll UI components have several fields you can set to determine the position of the component on the screenspace.\n\n\n  \n    hAlign horizontal alignment relative to the parent. Possible values: left, right, center.\n  \n  \n    vAlign horizontal alignment relative to the parent. Possible values: top, bottom, center.\n  \n  \n    positionX, positionY: the position of the top-left corner of the component, relative to the parent. By default, to the top-left corner of its parent. If the hAlign or vAlign properties are set, then positionX and positionY offset the UI component relative to the position of these alignment properties.\n  \n\n\n\n  Tip: When measuring from the top, the numbers for positionY should be negative. Example: to position a component leaving a margin of 20 pixels with respect to the parent on the top and left sides, set positionX to 20 and positionY to -20.\n\n\n\n  \n    paddingLeft, paddingRight, paddingTop, paddingBottom: padding space to leave empty around. To set these fields in pixels, write the value as a number. To set these fields as a percentage of the parent’s measurements, write the value as a string that ends in “%”, for example 10 %\n  \n  \n    with, height: Set the size of the component in the screen. To set these fields in pixels, write the value as a number. To set these fields as a percentage of the parent’s measurements, write the value as a string that ends in “%”, for example 10 %\n  \n\n\nconst canvas = new UICanvas()\n\nconst message = new UIText(canvas)\nmessage.value = \"Close UI\"\nmessage.fontSize = 15\nmessage.width = 120\nmessage.height = 30\nmessage.vAlign = \"bottom\"\nmessage.positionX = -80\n\n\nTo determine the z position of UI elements, the UI uses the parenting hierarchy of the components. So, if a component is a child of another, it will appear in front of the other.\n\nUse parent elements for organizing\n\nCertain UI elements are there to help you organize how you place other elements.\n\n\n\nFor this, you can use the UIContainerStack and the UIContainerRect.\n\nBoth these shapes have properties to set their color, and line thickness.\n\nconst canvas = new UICanvas()\n\nconst inventoryContainer = new UIContainerStack(canvas)\ninventoryContainer.adaptWidth = true\ninventoryContainer.width = \"40%\"\ninventoryContainer.positionY = 100\ninventoryContainer.positionX = 10\ninventoryContainer.color = Color4.White()\ninventoryContainer.hAlign = \"left\"\ninventoryContainer.vAlign = \"top\"\ninventoryContainer.stackOrientation = UIStackOrientation.VERTICAL\n\n\nContainer components also have following properties:\n\n\n  \n    adaptWidth adaptHeight: Set on parent components. If these are set to true, the width and height wrap the child components (plus padding). If these are true, width and height values are ignored\n  \n  \n    stackOrientation: The UIContainerStack component has this property to set if the stack will expand vertically or horizontally.\n  \n\n\nScrollable rectangles\n\nYou can also add UI elements into a UIScrollRect. If these rectangles have more content in them that what fits in their width or height, a slider will appear on the margins, that players can interact with to explore this content.\n\nScrollable rectangles can be horizontal or vertical, or both.\n\nconst canvas = new UICanvas()\n\nconst scrollableContainer = new UIScrollRect(canvas)\nscrollableContainer.width = \"50%\"\nscrollableContainer.height = \"50%\"\nscrollableContainer.backgroundColor = Color4.Gray()\nscrollableContainer.isVertical = true\nscrollableContainer.onChanged = new OnChanged(() =&gt; {\n  log(\"scrolled to \", scrollableContainer.positionY)\n})\n\n\nScrolling values are always normalized from 0 to 1. You can set the scrolling value manually via the valueX and valueY properties.\n\nThe onChanged property lets you run a function whenever the value of the scrollbar changes.\n\nSet transparency\n\nYou can make a UI element partly transparent by setting its opacity property to a value that’s less than 1.\n\nconst canvas = new UICanvas()\n\nconst rect = new UIContainerRect(canvas)\nrect.width = \"100%\"\nrect.height = \"100%\"\nrect.color = Color4.Blue()\nrect.opacity = 0.5\n\n\nSetting an element’s opacity also affects all of its children. If you don’t want its children to be transparent, for example you want the background to be transparent but not the text on it, you can set the color with a hex string that has four values, one of them being the alpha channel.\n\nText\n\nThe UIText component lets you add text. It has properties that are similar to the TextShape component. See text.\n\n\n  value: the string to display\n  color: Color4 for the text color\n  fontSize: font size\n  font: font to use\n  lineSpacing : space between lines of text\n  lineCount: how many max lines of text\n  textWrapping: if text automatically occupies more lines\n  outlineWidth, outlineColor: add an outline to the text\n  shadowBlur, shadowOffsetX, shadowOffsetY, shadowColor: Add a shadow to the text\n\n\nFonts are set as a Font object. Font objects are initiated with a value from the Fonts enum, which contains all supported fonts. By default, all text components use LiberationSans font.\n\nconst canvas = new UICanvas()\n\nconst myText = new UIText(canvas)\nmyText.value = \"Hello\"\nmyText.font = new Font(Fonts.SanFrancisco)\nmyText.fontSize = 20\nmyText.positionX = \"15px\"\nmyText.color = Color4.Blue()\n\n\n\n  TIP: If using VS studio or some other IDE, type Font. and you should see a list of suggestions with all of the available fonts.\n\n\nYou can share a same instanced Font object accross multiple UIText components.\n\nconst sfFont = new Font(Fonts.SanFrancisco)\n\nconst myText = new UIText(canvas)\nmyText.value = \"Hello\"\nmyText.font = sfFont\n\nconst myText2 = new UIText(canvas)\nmyText2.value = \"World\"\nmyText2.font = sfFont\n\n\nMultiline text\n\nUIText components by default adapt their width to the length of the provided string. To make a text span multiple lines, set the textWrapping property to true and adaptWidth to false, and also specify the desired width.\n\nconst canvas = new UICanvas()\n\nconst myText = new UIText(canvas)\nmyText.value =\n  \"Hello World, this message is quite long and won't fit in a single line. I hope that's not a problem.\"\nmyText.fontSize = 20\nmyText.adaptWidth = false\nmyText.textWrapping = true\nmyText.width = 100\n\n\nAlternatively, you can add line breaks into the string, using \\n.\n\nconst canvas = new UICanvas()\n\nconst myText = new UIText(canvas)\nmyText.value =\n  \"Hello World,\\nthis message is quite long and won't fit in a single line.\\nI hope that's not a problem.\"\nmyText.fontSize = 20\n\n\nImages from an image atlas\n\nYou can use an image atlas to store multiple images and icons in a single image file. You then display rectangular parts of this image file in your UI based on pixel positions, pixel width, and pixel height inside the source image.\n\nBelow is an example of an image atlas with multiple icons arranged into a single file.\n\n\n\nThe UIImage component has the following fields to crop a sub-section of the original image:\n\n\n  sourceTop: the y coordinate, in pixels, of the top of the selection\n  sourceLeft: the x coordinate, in pixels, of the left side of the selection.\n  sourceWidth: the width, in pixels, of the selected area\n  sourceHeight: the height, in pixels, of the selected area\n\n\nWhen constructing a UIImage component, you must pass a Texture component as an argument. Read more about Texture components in materials.\n\nlet imageAtlas = \"images/image-atlas.jpg\"\nlet imageTexture = new Texture(imageAtlas)\n\nconst canvas = new UICanvas()\n\nconst playButton = new UIImage(canvas, imageTexture)\nplayButton.sourceLeft = 26\nplayButton.sourceTop = 128\nplayButton.sourceWidth = 128\nplayButton.sourceHeight = 128\n\nconst startButton = new UIImage(canvas, imageTexture)\nstartButton.sourceLeft = 183\nstartButton.sourceTop = 128\nstartButton.sourceWidth = 128\nstartButton.sourceHeight = 128\n\nconst exitButton = new UIImage(canvas, imageTexture)\nexitButton.sourceLeft = 346\nexitButton.sourceTop = 128\nexitButton.sourceWidth = 128\nexitButton.sourceHeight = 128\n\nconst expandButton = new UIImage(canvas, imageTexture)\nexpandButton.sourceLeft = 496\nexpandButton.sourceTop = 128\nexpandButton.sourceWidth = 128\nexpandButton.sourceHeight = 128\n\n\nYou can change the texture being used by an existing UIImage component, set the data field.\n\nplayButton.data = imageTexture2\n\n\nClicking UI elements\n\nAll UI elements have an isPointerBlocker property, that determines if they can be clicked. If this value is false, the pointer should ignore them and respond to whatever is behind the element.\n\nClickable UI elements also have an OnClick property, that lets you add a function to execute every time it’s clicked.\n\nconst canvas = new UICanvas()\n\nconst clickableImage = new UIImage(canvas, new Texture(\"icon.png\"))\nclickableImage.name = \"clickable-image\"\nclickableImage.width = \"92px\"\nclickableImage.height = \"91px\"\nclickableImage.sourceWidth = 92\nclickableImage.sourceHeight = 91\nclickableImage.isPointerBlocker = true\nclickableImage.onClick = new OnClick(() =&gt; {\n  // DO SOMETHING\n})\n\n\n\n\n\n  Note: To click on a UI component, players must first unlock the cursor from the view control. They do this by clicking the right mouse button or hitting Esc.\n\n\n\n  Tip: If you want to add text over a button, keep in mind that the text needs to have the isPointerBlocker property set to false, otherwise players might be clicking the text instead of the button.\n\n\nInput text\n\nInput boxes can be added to the UI to provide a place to type in text. You add a text box with an UIInputText component. Players must first click on this box before they can write into it.\n\nconst canvas = new UICanvas()\n\nconst textInput = new UIInputText(canvas)\ntextInput.width = \"80%\"\ntextInput.height = \"25px\"\ntextInput.vAlign = \"bottom\"\ntextInput.hAlign = \"center\"\ntextInput.fontSize = 10\ntextInput.placeholder = \"Write message here\"\ntextInput.placeholderColor = Color4.Gray()\ntextInput.positionY = \"200px\"\ntextInput.isPointerBlocker = true\n\ntextInput.onTextSubmit = new OnTextSubmit((x) =&gt; {\n  const text = new UIText(textInput)\n  text.value = \"&lt;USER-ID&gt; \" + x.text\n  text.width = \"100%\"\n  text.height = \"20px\"\n  text.vAlign = \"top\"\n  text.hAlign = \"left\"\n})\n\n\nHere are some of the main properties you can set:\n\n\n  \n    focusedBackground: You can change the background color to indicate that the input box is currently selected. Use this field to set an alternative color.\n  \n  \n    placeholder: Set placeholder text to display on the box by default.\n  \n  \n    placeholderColor: Make the placeholder a different color, to tell it apart. You’ll usually want to make it a paler shade of the color of text that the player writes.\n  \n\n\nWhen the player interacts with the component, you can use the following events to trigger the execution of code:\n\n\n  OnFocus(): The player clicked on the UI component and has a cursor on it.\n  OnBlur(): The player clicked away and the cursor is gone.\n  OnChanged(): The player typed or deleted something to change the string on the component.\n  OnTextSubmit(): The player hit the Enter key to submit this string.\n\n\ntextInput.onChanged = new OnChanged((data: { value: string }) =&gt; {\n  inputTextState = data.value\n})\n\n\nOpen the UI\n\nYou can have the code of your scene make the the UI visible when specific events occurs, for example at the end of a game to display the final score.\n\nTo do this, simply set the visible property of the main UICanvas component that wraps the UI to true or false.\n\nIf the UI is clickable, or has clickable parts, you should also set the isPointerBlocker property to true or false, so that the player can freely click in the world space when the UI is not on the way.\n\nThe following code adds a cube to the world-space of the scene that opens the UI when clicked.\n\nconst uiTrigger = new Entity()\nconst transform = new Transform({\n  position: new Vector3(5, 1, 5),\n  scale: new Vector3(0.3, 0.3, 0.3),\n})\nuiTrigger.addComponent(transform)\n\nuiTrigger.addComponent(\n  new OnPointerDown(() =&gt; {\n    canvas.visible = true\n    canvas.isPointerBlocker = true\n  })\n)\n\nuiTrigger.addComponent(new BoxShape())\nengine.addEntity(uiTrigger)\n\n\nPlayers can close the UI by clicking the icon on the top-right corner. Note that when closing the UI in this way, they won’t see any more UI components appear in your scene, even if the code sets them to visible.\n\nIt’s a good practice to add a button on your UI elements for closing them in a way that doesn’t prevent other UI components from being visible in the future.\n\nYou might also want to close the UI automatically when a specific event occurs, for example when a new match of a game starts.\n\nTo do this, simply set the visible property of the main UIScreenSpace component that wraps the UI to false.\n\nIf the UI is clickable, or has clickable parts, you should also set the isPointerBlocker property to false, so that the player can freely click in the world space.\n\nconst canvas = new UICanvas()\n\nconst close = new UIImage(canvas, new Texture(\"icon.png\"))\nclose.name = \"clickable-image\"\nclose.width = \"120px\"\nclose.height = \"30px\"\nclose.sourceWidth = 92\nclose.sourceHeight = 91\nclose.vAlign = \"bottom\"\nclose.isPointerBlocker = true\nclose.onClick = new OnClick(() =&gt; {\n  log(\"clicked on the close image\")\n  canvas.visible = false\n  canvas.isPointerBlocker = false\n})\n\n````"
        }
        
      
    
  
    
      
        ,
        
        "development-guide-special-types": {
          "id": "development-guide-special-types",
          "title": "Special types",
          "categories": "development-guide",
          "url": " /development-guide/special-types/",
          "content": "Vectors\n\nDecentraland uses vectors to represent paths, points in space, and directions. Vectors can also be used to define rotation orientations, as a friendlier alternative to quaternions. Vector2, Vector3 and Vector4 are each defined as different classes, containing a different number of dimensions.\n\nVector objects contain a series of handy methods that you can call to avoid having to deal with most vector math operations.\n\nBelow are a few lines showing the syntax for some basic operations with vectors.\n\n// Instance a vector object\nlet myVector = new Vector3(3, 1, 5)\n\n// Edit one of its values\nmyVector.x = 5\n\n// Call functions from the vector instance\nlet normalizedVector = myVector.normalize()\n\n// Call functions from the vector class\nlet distance = Vector3.Distance(myVector1, myVector2)\n\nlet midPoint = Vector3.lerp(myVector1, myVector2, 0.5)\n\n\n3D vectors are also included in the fields of several components. For example, the Transform component contains Vector3 values for the position and scale of the entity.\n\nShortcuts for writing direction vectors\n\nThe following shortcuts exist for defining generic vectors:\n\n\n  Vector3.Zero() returns (0, 0, 0)\n  Vector3.Up() returns (0, 1, 0)\n  Vector3.Down() returns (0, -1, 0)\n  Vector3.Left() returns (-1, 0, 0)\n  Vector3.Right() returns (1, 0, 0)\n  Vector3.Forward() returns (0, 0, 1)\n  Vector3.Backward() returns (0, 0, -1)\n\n\nScalars\n\nA scalar is nothing more than a number. For that reason, it doesn’t make much sense to instantiate a Scalar object to store data. The functions in the Scalar class however exposes several handy functions (similar to those in Vector classes), that can be used on numbers.\n\n// Call functions from the Scalar class\nlet random = Scalar.RandomRange(1, 100)\n\nlet midPoint = Scalar.lerp(number1, number2, 0.5)\n\nlet clampedValue = Scalar.Clamp(myInput, 0, 100)\n\n\nQuaternions\n\nQuaternions are used to store rotation information for the Transform component. A Quaternion is composed of four numbers between -1 and 1: x, y, z, w.\n\n// Instance a quaternion object\nlet myQuaternion = new Quaternion(0, 0, 0, 1)\n\n// Edit one of its values\nmyQuaternion.x = 1\n\n// Call functions from the quaternion instance\nlet quaternionAsArray = myQuaternion.asArray()\n\n// Call functions from the quaternion class\nlet quaternionFromEuler = Quaternion.FromEulerAnglesRef(90, 0, 0)\n\nlet midPoint = Quaternion.Slerp(myQuaternion1, myQuaternion2, 0.5)"
        }
        
      
    
  
    
      
        ,
        
        "development-guide-click-events": {
          "id": "development-guide-click-events",
          "title": "Button events",
          "categories": "development-guide",
          "url": " /development-guide/click-events/",
          "content": "Decentraland accepts events from pointer clicks, a primary button and a secondary button.\n\nClicks can be done either with a mouse, a touch screen, a VR controller or some other device, these all generate the same type of event.\n\nThe primary and secondary buttons map respectively to the E and F key on a keyboard.\n\n\n  Note: Entities that don’t have a shape component, or that have their shape’s visible field set to false don’t respond to pointer events.\n\n\nPointer event components\n\nOnPointerDown\n\nThe best way to handle pointer and button down events is to add an OnPointerDown component to an entity.\n\nThe component requires that you pass it a function as a main argument. This function declares what to do in the event of a button down event while the player points at the entity.\n\nconst myEntity = new Entity()\nmyEntity.addComponent(new BoxShape())\n\nmyEntity.addComponent(\n  new OnPointerDown((e) =&gt; {\n    log(\"myEntity was clicked\", e)\n  })\n)\n\n\n\n  Tip: To keep your code easier to read, the function in the OnPointerDown can consist of just a call to a separate function that contains all of the logic.\n\n\nThe OnPointerDown component has a second optional parameter, this parameter is an object that can include multiple properties about the event. These properties are explained in greater detail in the next few sub-sections.\n\n\n  button: Which key to listen for, from the ActionButton enum:\n    \n      ActionButton.POINTER (left mouse click on PC)\n      ActionButton.PRIMARY (E on PC)\n      ActionButton.SECONDARY(F on PC)\n    \n  \n  hoverText: Hint text to display on the UI when pointing at the entity.\n  distance: Maximum click distance.\n\n\nOnPointerUp\n\nAdd an OnPointerUp component to track when a player releases the mouse button, the primary or the secondary button while pointing at the entity.\n\nLike the OnPointerDown, the OnPointerUp component requires a callback function that declares what to do in the event of a button up event while pointing at the entity.\n\nThis component also takes a second argument that supports the same additional fields as teh OnPointerDown component.\n\nconst myEntity = new Entity()\nmyEntity.addComponent(new BoxShape())\n\nmyEntity.addComponent(\n  new OnPointerUp((e) =&gt; {\n    log(\"pointer up\", e)\n  })\n)\n\n\nSpecific button events\n\nThe OnPointerDown and OnPointerUp components can respond to the following different buttons:\n\n\n  POINTER (left mouse click on PC)\n  PRIMARY (E on PC)\n  SECONDARY(F on PC)\n\n\nYou can configure the components by setting the button field in the second argument of the component initializer.\n\nIf no button is specified, ActionButton.ANY is used as the default. This detects events from any of the available buttons on these components.\n\nconst myEntity = new Entity()\nmyEntity.addComponent(new BoxShape())\n\nmyEntity.addComponent(\n  new OnPointerDown(\n    (e) =&gt; {\n      log(\"myEntity was clicked\", e)\n    },\n    { button: ActionButton.POINTER }\n  )\n)\n\n\nHint messages\n\nWhen a player hovers the cursor over an item with an OnPointerDown or OnPointerUp component, the cursor changes shape to hint to the player that the entity is interactive.\n\nYou can also display a toast message in the UI that lets the player know what happens when interacting with the entity.\n\nmyEntity.addComponent(\n  new OnPointerDown(\n    (e) =&gt; {\n      log(\"myEntity clicked\", e)\n    },\n    {\n      button: ActionButton.PRIMARY,\n      showFeedback: true,\n      hoverText: \"open\",\n    }\n  )\n)\n\n\nIn the example above, the second argument of the OnPointerDown component has an object with the following arguments:\n\n\n  button: What button to respond to\n  showFeedback: Boolean to turn the feedback on or off. It’s true by default.\n  hoverText: String to display in the UI while the player points at the entity. By default, this string spells Interact, unless showFeedback is false.\n\n\n[IMAGE]\n\n\n  TIP: The hoverText string should describe the action that happens when interacting. For example Open, Activate, Grab, Select. These strings should be as short as possible, to avoid stealing too much focus from the player.\n\n\nThe hoverText of an OnPointerUp component is only displayed while the player is already holding down the corresponding key and pointing at the entity.\n\nIf an entity has both an OnPointerDown and an OnPointerUp component, the hint for the OnPointerDown is shown while the button is not being pressed. The hint switches to the one from the OnPointerUp only when the button is pressed and remains pressed.\n\nmyEntity.addComponent(\n  new OnPointerDown(\n    (e) =&gt; {\n      log(\"myEntity clicked\", e)\n    },\n    { button: ActionButton.PRIMARY, showFeedback: true, hoverText: \"Drag\" }\n  )\n)\n\nmyEntity.addComponent(\n  new OnPointerUp(\n    (e) =&gt; {\n      log(\"myEntity released\", e)\n    },\n    { button: ActionButton.PRIMARY, showFeedback: true, hoverText: \"Drop\" }\n  )\n)\n\n\n[IMAGE or GIF?]\n\nMax click distance\n\nBy default, entities are only clickable when the player is within a close range of the entity, at a maximum distance of 10 meters. You can optionally configure the maximum distance through the distance parameter of the OnPointerDown and OnPointerUp components.\n\nmyEntity.addComponent(\n  new OnPointerDown(\n    (e) =&gt; {\n      log(\"myEntity clicked\", e)\n    },\n    {\n      button: ActionButton.PRIMARY,\n      showFeedback: true,\n      hoverText: \"Activate\",\n      distance: 8,\n    }\n  )\n)\n\n\nThe example above sets the maximum distance to 8 meters.\n\nEvent arguments\n\nThe pointer down event and the pointer up event objects are implicitly passed as parameters of the functions in the OnPointerDown and OnPointerUp components, respectively. This event object contains various properties that might be useful for the function. See Properties of button events for more details.\n\nconst myEntity = new Entity()\nmyEntity.addComponent(new BoxShape())\n\nmyEntity.addComponent(\n  new OnPointerDown(\n    (e) =&gt; {\n      log(\"Click distance: \" + e.length)\n    },\n    { button: ActionButton.PRIMARY }\n  )\n)\n\n\nMultiple buttons on an entity\n\nYou may want to make an entity respond to different buttons in different ways. Each entity can only have one OnPointerDown component, and one OnPointerUp component, but you can use ActionButton.ANY and then tell them apart within the function.\n\nCheck the buttonId field from the event data. The value of this field returns a number, which maps to the values in the ActionButton array, for example by POINTER maps to 0, PRIMARY to 1, SECONDARY to 2, etc.\n\nconst myEntity = new Entity()\nmyEntity.addComponent(new BoxShape())\n\nmyEntity.addComponent(\n  new OnPointerDown(\n    (e) =&gt; {\n      if (e.buttonId == 0) {\n        log(\"Clicked pointer\")\n      } else if (e.buttonId == 1) {\n        log(\"Pressed primary button\")\n      } else if (e.buttonId == 2) {\n        log(\"Pressed secondary button\")\n      }\n    },\n    { button: ActionButton.ANY }\n  )\n)\n\n\nPlayers will see a single label when hovering over the entity, so make sure it’s clear that there are multiple ways to interact with it.\n\nProperties of button events\n\nThe events from OnPointerDown and OnPointerUp components, as well as all the global button event objects, contain the following parameters:\n\n\n  origin: Origin point of the ray, as a Vector3\n  direction: Direction vector of the ray, as a normalized Vector3 that points in the same direction.\n  buttonId: ID of the button that triggered the event (POINTER, PRIMARY or SECONDARY)\n  \n    hit: (Optional) Object describing the entity that was clicked on. If the click didn’t hit any specific entity, this field isn’t present. The hit object contains the following parameters:\n\n    \n      length: Length of the ray in meters, as a number\n      hitPoint: The intersection point between the ray and the entity’s mesh, as a Vector3\n      meshName: The name of the mesh, if applicable, as a string\n      worldNormal: The normal of the hit, in world space, as a Vector3\n      entityId: The ID of the entity, if applicable, as a string\n    \n  \n\n\nDifferentiate meshes inside a model\n\nOften, .glTF 3D models are made up of multiple meshes, that each have an individual internal name. All button events events include the information of what specific mesh was clicked, so you can use this information to trigger different click behaviors in each case.\n\nTo see how the meshes inside the model are named, you must open the 3D model with an editing tool, like Blender for example.\n\n\n\n\n  Tip: You can also learn the name of the clicked mesh by logging it and reading it off console.\n\n\nYou access the meshName property as part of the hit object, that’s returned by the click event.\n\nIn the example below we have a house model that includes a mesh named firePlace. We want to turn on the fireplace only when its corresponding mesh is clicked.\n\nhouseEntity.addComponent(\n  new OnPointerDown(\n    (e) =&gt; {\n      log(\"button A Down\", e.hit.meshName)\n      if (e.hit.meshName === \"firePlace\") {\n        // light fire\n        fireAnimation.play()\n      }\n    },\n    { button: ActionButton.POINTER, showFeeback: false }\n  )\n)\n\n\n\n  Note: Since the OnPointerDown component belongs to the whole entity, the on-hover feedback would be seen when hovering over any part of the entity. In this case, any part of the house, not just the fireplace. For that reason, we set the showFeedback argument of the OnPointerDown component to false, so that no on-hover feedback is shown. For a better player experience, it’s recommended to instead have the fireplace as a separate entity and maintain the on-hover feedback.\n\n\nGlobal button events\n\nThe BUTTON_DOWN and BUTTON_UP events are fired whenever the player presses or releases an input controller button.\n\nThese events are triggered every time that the buttons are pressed or released, regardless of where the player’s pointer is pointing at, as long as the player is standing inside the scene’s boundaries.\n\nIt also tracks keys used for basic avatar movement whilst in the scene.\n\nInstance an Input object and use its subscribe() method to initiate a listener that’s subscribed to one of the button events. Whenever the event is caught, it executes a provided function.\n\nThe subscribe() method takes four arguments:\n\n\n  eventName: The type of action, this can be either \"BUTTON_DOWN\" or \"BUTTON_UP\"\n  \n    buttonId: Which button to listen for.\nThe following buttons can be tracked for both BUTTON_DOWN and BUTTON_UP events:\n\n    - `POINTER` (left mouse click on PC)\n- `PRIMARY` (_E_ on PC)\n- `SECONDARY`(_F_ on PC)\n- `JUMP`(_space bar_ on PC)\n- `FORWARD`(_W_ on PC)\n- `LEFT`(_A_ on PC)\n- `RIGHT`(_D_ on PC)\n- `BACK`(_S_ on PC)\n- `WALK`(_Shift_ on PC)\n- `ACTION_3`(_1_ on PC)\n- `ACTION_4`(_2_ on PC)\n- `ACTION_5`(_3_ on PC)\n- `ACTION_6`(_4_ on PC)\n    \n  \n  useRaycast: Boolean to define if raycasting will be used. If false, the button event will not contain information about any hit objects that align with the pointer at the time of the event. Avoid setting this field to true when information about hit objects is not required, as it involves extra calculations.\n  fn: The function to execute each time the event occurs.\n\n\n\n  Note: Other keys on the PC keyboard aren’t tracked for future cross-platform compatibility, as this limited set of keys can be mapped to a joystick. For detecting key-strokes when writing text, check the UIInputBox.\n\n\n// Instance the input object\nconst input = Input.instance\n\n// button down event\ninput.subscribe(\"BUTTON_DOWN\", ActionButton.POINTER, false, (e) =&gt; {\n  log(\"pointer Down\", e)\n})\n\n// button up event\ninput.subscribe(\"BUTTON_UP\", ActionButton.POINTER, false, (e) =&gt; {\n  log(\"pointer Up\", e)\n})\n\n\nThe example above logs messages and the contents of the event object every time the pointer button is pushed down or released.\n\nThe event objects of both the BUTTON_DOWN and the BUTTON_UP contain various useful properties. See Properties of button events for more details.\n\n\n  Note: The code for subscribing an input event only needs to be executed once, the subscribe() method keeps polling for the event. Don’t add this into a system’s update() function, as that would register a new listener on every frame.\n\n\nDetect hit entities\n\nIf the third argument of the subscribe() function (useRaycast)is true, and the player is pointing at an entity that has a collider, the event object includes a nested hit object. The hit object includes information about the collision and the entity that was hit.\n\nRaycasting is not available when detecting basic movement keys. It’s only available when tracking the following buttons:\n\n\n  POINTER\n  PRIMARY\n  SECONDARY\n  ACTION_3\n  ACTION_4\n  ACTION_5\n  ACTION_6\n\n\nThe ray of a global button event only detects entities that have a collider mesh. Primitive shapes have a collider mesh on by default, 3D models need to have one built into them.\n\n\n  Tip: See Colliders for details on how to add collider meshes to a 3D model.\n\n\ninput.subscribe(\"BUTTON_DOWN\", ActionButton.POINTER, true, (e) =&gt; {\n  if (e.hit) {\n    let hitEntity = engine.entities[e.hit.entityId]\n    hitEntity.addComponent(greenMaterial)\n  }\n})\n\n\nThe example above checks if any entities were hit, and if so it fetches the entity and applies a material component to it.\n\nThe event data returns a string for the entityId. If you want to reference the actual entity by that ID to affect it in some way, use engine.entities[e.hit.entityId].\n\n\n  Note: We recommend that when possible you use the approach of adding an OnPointerDown component to each entity you want to make interactive, instead of using a global button event. The scene’s code isn’t able to hint to a player that an entity is interactive when hovering on it unless the entity has an OnPointerDown, OnPointerUp, or OnClick component.\n\n\nTracking player movements\n\nIn real-time multiplayer games where the timing of player movements is critical, you may want to keep track of each player’s position using a 3rd party server as the source of truth. You can improve response time by listening to the button in advance and predict their effects in your server before the avatar has shifted position.\n\nThis approach helps compensate for network delays, but is sure to result in discrepancies, so you should also regularly poll the player’s current position to make corrections. Balancing these predictions and corrections may require plenty of fine-tuning.\n\nRay Obstacles\n\nButton events cast rays that only interact with the first entity on their path, as long as the entity is closer than its distance limit.\n\nFor an entity to be intercepted by the ray of a button event, the entity’s shape must either have a collider mesh, or the entity must have a component related to button events (OnPointerDown, OnPointerUp or OnClick).\n\nIf another entity’s collider is standing on the way of the entity that the player wants to click, the player won’t be able to click the entity that’s behind, unless the entity that’s in-front has a shape with its isPointerBlocker property set to false.\n\nlet myEntity = new Entity()\nlet box = new BoxShape()\nbox.isPointerBlocker = false\nbox.visible = false\nmyEntity.addComponent(box)\nengine.addEntity(myEntity)\n\n\nOnHover Component\n\nAdd OnPointerHoverEnter and OnPointerHoverExit components to an entity to run a callback function every time that the player’s cursor starts or stops pointing at the entity.\n\nYou can use this to hint that something is interactable in some custom way, like showing a glowing highlight around the entity, playing a subtle sound, etc. It could also be used for specific gameplay mechanics.\n\nmyEntity.addComponent(\n  new OnPointerHoverEnter((e) =&gt; {\n    log(\"Started Pointing at entity\")\n  })\n)\n\nmyEntity.addComponent(\n  new OnPointerHoverExit((e) =&gt; {\n    log(\"Stopped Pointing at entity\")\n  })\n)\n\n\nOn the OnPointerHoverEnter component, you can set a maximum distance, to only trigger the callback when the player is near the entity.\n\nmyEntity.addComponent(\n  new OnPointerHoverEnter(\n    (e) =&gt; {\n      log(\"Started Pointing at entity\")\n    },\n    {\n      distance: 8,\n    }\n  )\n)\n\n\n\n  TIP: Note that all entities with an OnPointerDown component by default show a UI hint when hovered over. You can disable this UI hint by setting the showFeeback property on the OnPointerDown component to false.\n\n\nOnClick Component - DEPRECATED\n\nAs an alternative to OnPointerDown, you can use the OnClick component. This component only tracks button events from the POINTER, not from the primary or secondary buttons.\n\nYou declare what to do in the event of a click by writing a function in the OnClick component.\n\nconst myEntity = new Entity()\nmyEntity.addComponent(new BoxShape())\n\nmyEntity.addComponent(\n  new OnClick((e) =&gt; {\n    log(\"myEntity clicked\")\n  })\n)\n\n\nThe OnClick component passes less event information than the OnPointerDown component, it lacks the click distance or the mesh name, for example.\n\n\n\n\n  Note: Entities that don’t have a shape component, or that have their shape’s visible field set to false can’t be clicked.\n\n\nButton state\n\nYou can check for the button’s current state (up or down) using the Input object.\n\nlet buttonState = input.isButtonPressed(ActionButton.POINTER)\n\n\nIf the pointer button is currently being held down, the statement above returns the value true, otherwise it returns false.\n\nYou can check for the states of the PRIMARY and SECONDARY buttons in the same way, providing ActionButton.PRIMARY or ActionButton.SECONDARY as arguments for the isButtonPressed() function.\n\nYou can implement this in a system’s update() function to check the button state regularly.\n\n// Instance the input object\nconst input = Input.instance\n\nclass ButtonChecker implements ISystem {\n  update() {\n    if (input.isButtonPressed(ActionButton.POINTER)) {\n      log(\"pointer button down\")\n    } else {\n      log(\"pointer button up\")\n    }\n  }\n}\n\nengine.addSystem(new ButtonChecker())"
        }
        
      
    
  
    
      
        ,
        
        "development-guide-3d-model-animations": {
          "id": "development-guide-3d-model-animations",
          "title": "Handle animations",
          "categories": "development-guide",
          "url": " /development-guide/3d-model-animations/",
          "content": "3D models in .glTF and .glb format can include as many animations as you want in them. Animations tell the mesh how to move, by specifying a series of keyframes that are laid out over time, the mesh then blends from one pose to the other to simulate continuous movement.\n\nMost 3D model animations are skeletal animations. These animations simplify the complex geometry of the model into a “stick figure”, linking every vertex in the mesh to the closest bone in the skeleton. Modelers adjust the skeleton into different poses, and the mesh stretches and bends to follow these movements.\n\nAs an alternative, vertex animations animate a model without the need of a skeleton. These animations specify the position of each vertex in the model directly. Decentraland supports these animations as well.\n\nSee Animations for details on how to create animations for a 3D model. Read Shape components for instructions on how to import a 3D model to a scene.\n\n\n  Tip: Animations are usually better for moving something in place, not for changing the position of an entity. For example, you can set an animation to move a character’s feet in place, but to change the location of the entity it’s best to use the Transform component. See Positioning entities for more details.\n\n\nCheck a 3D model for animations\n\nNot all glTF files include animations. To see if there are any available, you can do the following:\n\n\n  If using VS Code(recommended), install the GLTF Tools extension and view the contents of a glTF file there.\n  Open the Babylon Sandbox site and drag the glTF file (and any .jpg or .bin dependencies) to the browser.\n  Open the .glTF file with a text editor and scroll down till you find “animations”:.\n\n\n\n  Tip: In skeletal animations, an animation name is often comprised of its armature name, an underscore and its animation name. For example myArmature_animation1.\n\n\nAutomatic playing\n\nIf a 3d model includes any animations, the default behavior is that the first of these is always played on a loop.\n\nTo avoid this behavior, add an Animator component to the entity that has the model, and then handle the playing of animations explicitly. If an Animator component is present in the entity, all animations default to a stopped state, and need to be manually played.\n\nHandle animations explicitly\n\nAn Animator component is used to access all the animations of the entity and can be used to explicitly tell the entity to play or stop an animation. Each animation is handled by an AnimationState object.\n\n\n\n// Create entity\nlet shark = new Entity()\n\n// Add a 3D model to it\nshark.addComponent(new GLTFShape(\"models/shark.gltf\"))\n\n// Create animator component\nlet animator = new Animator()\n\n// Add animator component to the entity\nshark.addComponent(animator)\n\n// Instance animation clip object\nconst clipSwim = new AnimationState(\"swim\")\n\n// Add animation clip to Animator component\nanimator.addClip(clipSwim)\n\n// Add entity to engine\nengine.addEntity(shark)\n\n\nYou can also achieve the same with less statements:\n\n// Create and add animator component\nshark.addComponent(new Animator())\n\n// Instance and add a clip\nshark.getComponent(Animator).addClip(new AnimationState(\"swim\"))\n\n\nYou can retrieve an AnimationState object from an Animator component with the getClip() function.\n\n// Create and get a clip\nlet clipSwim = animator.getClip(\"swim\")\n\n\nThe AnimationState object doesn’t store the actual transformations that go into the animation, that’s all in the .glTF file. Instead, the AnimationState object has a state that keeps track how far it has advanced along the animation.\n\nFetch an animation\n\nIf you don’t have a pointer to refer to the clip object directly, you can fetch a clip from the Animator by name using getClip().\n\n// Create and add a clip\nshark.getComponent(Animator).addClip(new AnimationState(\"swim\"))\n\n// Fetch the clip\nshark.getComponent(Animator).getClip(\"swim\")\n\n\n\n\nPlay an animation\n\nWhen an AnimationState is created, it starts as paused by default.\n\nThe simplest way to play or pause it is to use the play() and pause() methods of the AnimationState.\n\n// Create animation clip\nconst clipSwim = new AnimationState(\"swim\")\n\n// Start playing the clip\nclipSwim.play()\n\n// Pause the playing of the clip\nclipSwim.pause()\n\n\nThe play() function on an AnimationState object has one optional parameter:\n\n\n  reset: If true, it always plays the animation from the start. Default: false.\n\n\nclipSwim.play(true)\n\n\nThe following table summarizes how play() behaves, using different values for the reset property:\n\n\n  \n    \n       \n      reset = false (default)\n      reset = true\n    \n  \n  \n    \n      Currently playing\n      Has no effect.\n      Plays from the start.\n    \n    \n      Paused\n      Resumes from last frame played.\n      Plays from the start.\n    \n    \n      Finished (Non-looping)\n      Plays from the start.\n      Plays from the start.\n    \n  \n\n\nYou can also play an animation from the Animator component of an entity.\n\nshark.getComponent(Animator).play(clipSwim)\n\n\nWhen calling the play() function on the Animator component, there are two parameters to set:\n\n\n  clip: An AnimationState object to play\n  reset:(optional) If true, it always plays the animation plays from the start. Default: false.\n\n\nLooping animations\n\nBy default, animations are played in a loop that keeps repeating the animation forever.\n\nChange this setting by setting the looping property in the AnimationState object.\n\n// Create animation clip\nconst biteClip = new AnimationState(\"bite\")\n\n// Set loop to false\nbiteClip.looping = false\n\n// Start playing the clip\nbiteClip.play()\n\n\nIf looping is set to false, the animation plays just once and then stops.\n\nReset an animation\n\nWhen an animation finishes playing or is paused, the 3D model remains in the last posture it had.\n\nTo stop an animation and set the posture back to the first frame in the animation, use the stop() function of the AnimationState object.\n\nclipSwim.stop()\n\n\nTo play an animation from the start, regardless of what frame the animation is currently in, set the reset property on the play() function to true.\n\nclipSwim.play(true)\n\n\n\n  Note: Resetting the posture is an abrupt change. If you want to make the model transition smoothly tinto another posture, you can either:\n\n\n- apply an animation with a `weight` property of 0 and gradually increase the `weight`\n- create an animation clip that describes a movement from the posture you want to transition from to the default posture you want.\n\n\nHandle multiple animations\n\nIf a 3D model has multiple animations packed into it, a single Animator component can deal with all of them.\n\nAnimations exist in layers in an Animator component. If two animations are in the same layer, only one of them can play at a time. Starting one will stop the other. If two animations exist on separate layers, they can play at the same time, given that their weight values add up, or if they each control different bones or vertexes from the model.\n\nlet shark = new Entity()\nshark.addComponent(new GLTFShape(\"models/shark.gltf\"))\n\n// Create animator component\nlet animator = new Animator()\n\n// Add animator component to the entity\nshark.addComponent(animator)\n\n// Crete animation state objects\nconst clipSwim = new AnimationState(\"swim\", { layer: 0 })\nconst biteClip = new AnimationState(\"bite\", { layer: 1 })\n\n// Add animation state objects to the Animator component\nshark.getComponent(Animator).addClip(clipSwim)\nshark.getComponent(Animator).addClip(biteClip)\n\nclipSwim.play()\nbiteClip.play()\n\nengine.addEntity(shark)\n\n\nIn the example above, two animations are handled by separate AnimationState objects, and they are then both assigned to the same Animator component.\n\n\n  Note: If the layer of an animation isn’t specified, it’s assigned to layer 0.\n\n\nEach bone in an animation can only be affected by one animation at a time, unless these animations have a weight that adds up to a value of 1 or less.\n\nIf one animation only affects a character’s legs, and another only affects a character’s head, then they can be played at the same time without any issue. But if they both affect the character’s legs, then you must either only play one at a time, or play them with lower weight values.\n\nIf in the above example, the bite animation only affects the shark’s mouth, and the swim animation only affects the bones of the shark’s spine, then they can both be played at the same time if they’re on separate layers.\n\nAnimation speed\n\nChange the speed at which an animation is played by changing the speed property. The value of the speed is 1 by default.\n\n// Create animation clip\nconst clipSwim = new AnimationState(\"swim\")\n\n// Set speed to twice as fast\nclipSwim.speed = 2\n\n// Start playing the clip\nclipSwim.play()\n\n\nSet the speed lower than 1 to play it slower, for example to 0.5 to play it at half the speed. Set it higher than 1 to play it faster, for example to 2 to play it at double the speed.\n\nAnimation weight\n\nThe weight property allows a single model to carry out multiple animations on different layers at once, calculating a weighted average of all the movements involved in the animation. The value of weight determines how much importance that animation will be given in the average.\n\nBy default, weight is equal to 1, it can’t be any higher than 1.\n\n// Create animation clip\nconst clipSwim = new AnimationState(\"swim\")\n\n// Set weight\nclipSwim.weight = 0.5\n\n// Start playing the clip\nclipSwim.play()\n\n\nThe weight value of all active animations in an entity should add up to 1 at all times. If it adds up to less than 1, the weighted average will be using the default position of the armature for the remaining part of the calculation.\n\nconst clipSwim = new AnimationState(\"swim\")\nclipSwim.weight = 0.2\n\nanimator.addClip(clipSwim)\n\nclipSwim.play()\n\n\nFor example, in the code example above, we’re playing the swim animation, that only has a weight of 0.2. This swimming movement will be quite subtle: only 20% of the intensity that the animation defines. The remaining 80% of the calculation takes values from the default posture of the armature.\n\nThe weight property can be used in interesting ways, for example the weight property of swim could be set in proportion to how fast the shark is swimming, so you don’t need to create multiple animations for fast and slow swimming.\n\nYou could also change the weight value gradually when starting and stopping an animation to give it a more natural transition and to avoid jumps from the default pose to the first pose in the animation.\n\n\n  Note: The added weight value of all animations that are acting on a 3D model’s bone can’t be more than 1. If more than one animation is affecting the same bones at the same time, they need to have their weight set to values that add to less than 1.\n\n\nSet clip parameters in bulk\n\nUse the setParams() function of the AnimationState object to set multiple parameters at once.\n\nYou can configure the following parameters:\n\n\n  playing: Boolean to determine if the animation is currently being played.\n  looping: Boolean to determine if the animation is played in a continuous loop.\n  speed: A number that determines how fast the animation is played.\n  layer: The layer of the animation. To play multiple animations at once, they must be on separate layers in the Animator component. By default, animations are added to layer 0.\n  weight: Used to blend animations using weighted average.\n\n\nconst clipSwim = new AnimationState(\"swim\")\n\nclipSwim.setParams({\n  playing: true,\n  looping: true,\n  speed: 2,\n  layer: 1,\n  weight: 0.5,\n})\n\n\nAnimations on shared shapes\n\nYou can use a same instance of a GLTFShape component on multiple entities to save resources. If each entity has both its own Animator component and its own AnimationState objects, then they can each be animated independently.\n\n//create entities\nlet shark1 = new Entity()\nlet shark2 = new Entity()\n\n// create reusable shape component\nlet sharkShape = new GLTFShape(\"models/shark.gltf\")\n\n// Add the same GLTFShape instance to both entities\nshark1.addComponent(sharkShape)\nshark2.addComponent(sharkShape)\n\n// Create separate animator components\nlet animator1 = new Animator()\nlet animator2 = new Animator()\n\n// Add separate animator components to the entities\nshark1.addComponent(animator1)\nshark2.addComponent(animator2)\n\n// Instance separate animation clip objects\nconst clipSwim1 = new AnimationState(\"swim\")\nconst clipSwim2 = new AnimationState(\"swim\")\n\n// Add animation clips to Animator components\nanimator1.addClip(clipSwim1)\nanimator2.addClip(clipSwim2)\n\nengine.addEntity(shark1)\nengine.addEntity(shark2)\n\n\n\n  Note: If you define a single AnimationState object instance and add it to multiple Animator components from different entities, all entities using the AnimationState instance will be animated together at the same time."
        }
        
      
    
  
    
      
        ,
        
        "development-guide-move-entities": {
          "id": "development-guide-move-entities",
          "title": "Move entities",
          "categories": "development-guide",
          "url": " /development-guide/move-entities/",
          "content": "To move, rotate or resize an entity in your scene, change the position, rotation and scale values stored in an entity’s Transform component incrementally, frame by frame. This can be used on primitive shapes (cubes, spheres, planes, etc) as well as on 3D models (glTF).\n\nYou can easily perform these incremental changes by moving entities a small amount each time the update() function of a system is called.\n\n\n  Tip: You can use the helper functions in the utils library to achieve most of the tasks described in this doc. The code shown in these examples is handled in the background by the library, so in most cases it only takes a single line of code to use them.\n\n\nMove\n\nThe easiest way to move an entity is to use the translate() function to change the position value stored in the Transform component.\n\nexport class SimpleMove implements ISystem {\n  update() {\n    let transform = myEntity.getComponent(Transform)\n    let distance = Vector3.Forward().scale(0.1)\n    transform.translate(distance)\n  }\n}\n\nengine.addSystem(new SimpleMove())\n\nconst myEntity = new Entity()\nmyEntity.addComponent(new Transform())\nmyEntity.addComponent(new BoxShape())\n\nengine.addEntity(myEntity)\n\n\nIn this example we’re moving an entity by 0.1 meters per frame.\n\nVector3.Forward() returns a vector that faces forward and measures 1 meter in length. In this example we’re then scaling this vector down to 1/10 of its length with scale(). If our scene has 30 frames per second, the entity is moving at 3 meters per second in speed.\n\n\n\nRotate\n\nThe easiest way to rotate an entity is to use the rotate() function to change the values in the Transform component incrementally, and run this as part of the update() function of a system.\n\nThe rotate() function takes two arguments:\n\n\n  The direction in which to rotate (as a Vector3)\n  The amount to rotate, in euler degrees (from 0 to 360)\n\n\nexport class SimpleRotate implements ISystem {\n  update() {\n    let transform = myEntity.getComponent(Transform)\n    transform.rotate(Vector3.Left(), 3)\n  }\n}\n\nengine.addSystem(new SimpleRotate())\n\nconst myEntity = new Entity()\nmyEntity.addComponent(new Transform())\nmyEntity.addComponent(new BoxShape())\n\nengine.addEntity(myEntity)\n\n\n\n  Tip: To make an entity always rotate to face the player, you can add a Billboard component.\n\n\n\n\nRotate over a pivot point\n\nWhen rotating an entity, the rotation is always in reference to the entity’s center coordinate. To rotate an entity using another set of coordinates as a pivot point, create a second (invisible) entity with the pivot point as its position and make it a parent of the entity you want to rotate.\n\nWhen rotating the parent entity, its children will be all rotated using the parent’s position as a pivot point. Note that the position of the child entity is in reference to that of the parent entity.\n\n// Create entity you wish to rotate\nconst myEntity = new Entity()\nmyEntity.addComponent(new BoxShape())\n\n// Create the pivot entity\nconst pivot = new Entity()\n\n// Position the pivot entity on the pivot point of the rotation\npivot.addComponent(\n  new Transform({\n    position: new Vector3(3, 2, 3),\n  })\n)\n\n// add pivot entity\nengine.addEntity(pivot)\n\n// Set pivot as the parent\nmyEntity.setParent(pivot)\n\n// Position child in reference to parent\nmyEntity.addComponent(\n  new Transform({\n    position: new Vector3(0, 0.5, 0.5),\n  })\n)\n\n// Define a system that updates the rotation on every frame\nexport class PivotRotate implements ISystem {\n  update() {\n    let transform = pivot.getComponent(Transform)\n    transform.rotate(Vector3.Left(), 3)\n  }\n}\n\n// Add the system\nengine.addSystem(new PivotRotate())\n\n\nNote that in this example, the system is rotating the pivot entity, that’s a parent of the door entity.\n\n\n\n\n  Note: Child entities should not be explicitly added to the engine, as they are already added via their parent entity.\n\n\nAdjust movement to delay time\n\nSuppose that the player visiting your scene is struggling to keep up with the pace of the frame rate. That could result in the movement appearing jumpy, as not all frames are evenly timed but each moves the entity in the same amount.\n\nYou can compensate for this uneven timing by using the dt parameter to adjust the scale the movement.\n\nexport class SimpleMove implements ISystem {\n  update(dt: number) {\n    let transform = myEntity.getComponent(Transform)\n    let distance = Vector3.Forward.scale(dt * 3)\n    transform.translate(distance)\n  }\n}\n// (...)\n\n\nThe example above keeps movement at approximately the same speed as the movement example above, even if the frame rate drops. When running at 30 frames per second, the value of dt is 1/30.\n\nYou can also smoothen rotations in the same way by multiplying the rotation amount by dt.\n\nMove between two points\n\nIf you want an entity to move smoothly between two points, use the lerp (linear interpolation) algorithm. This algorithm is very well known in game development, as it’s really useful.\n\nThe lerp() function takes three parameters:\n\n\n  The vector for the origin position\n  The vector for the target position\n  The amount, a value from 0 to 1 that represents what fraction of the translation to do.\n\n\nconst originVector = Vector3.Zero()\nconst targetVector = Vector3.Forward()\n\nlet newPos = Vector3.Lerp(originVector, targetVector, 0.6)\n\n\nThe linear interpolation algorithm finds an intermediate point in the path between both vectors that matches the provided amount.\n\nFor example, if the origin vector is (0, 0, 0) and the target vector is (10, 0, 10):\n\n\n  Using an amount of 0 would return (0, 0, 0)\n  Using an amount of 0.3 would return (3, 0, 3)\n  Using an amount of 1 would return (10, 0, 10)\n\n\nTo implement this lerp() in your scene, we recommend creating a custom component to store the necessary information. You also need to define a system that implements the gradual movement in each frame.\n\n@Component(\"lerpData\")\nexport class LerpData {\n  origin: Vector3 = Vector3.Zero()\n  target: Vector3 = Vector3.Zero()\n  fraction: number = 0\n}\n\n// a system to carry out the movement\nexport class LerpMove implements ISystem {\n  update(dt: number) {\n    let transform = myEntity.getComponent(Transform)\n    let lerp = myEntity.getComponent(LerpData)\n    if (lerp.fraction &lt; 1) {\n      transform.position = Vector3.Lerp(lerp.origin, lerp.target, lerp.fraction)\n      lerp.fraction += dt / 6\n    }\n  }\n}\n\n// Add system to engine\nengine.addSystem(new LerpMove())\n\nconst myEntity = new Entity()\nmyEntity.addComponent(new Transform())\nmyEntity.addComponent(new BoxShape())\n\nmyEntity.addComponent(new LerpData())\nmyEntity.getComponent(LerpData).origin = new Vector3(1, 1, 1)\nmyEntity.getComponent(LerpData).target = new Vector3(8, 1, 3)\n\nengine.addEntity(myEntity)\n\n\n\n\nRotate between two angles\n\nTo rotate smoothly between two angles, use the slerp (spherical linear interpolation) algorithm. This algorithm is very similar to a lerp, but it handles quaternion rotations.\n\nThe slerp() function takes three parameters:\n\n\n  The quaternion angle for the origin rotation\n  The quaternion angle for the target rotation\n  The amount, a value from 0 to 1 that represents what fraction of the translation to do.\n\n\n\n  Tip: You can pass rotation values in euler degrees (from 0 to 360) by using Quaternion.Euler().\n\n\nconst originRotation = Quaternion.Euler(0, 90, 0)\nconst targetRotation = Quaternion.Euler(0, 0, 0)\n\nlet newRotation = Quaternion.Slerp(originRotation, targetRotation, 0.6)\n\n\nTo implement this in your scene, we recommend storing the data that goes into the Slerp() function in a custom component. You also need to define a system that implements the gradual rotation in each frame.\n\n@Component(\"slerpData\")\nexport class SlerpData {\n  originRot: Quaternion = Quaternion.Euler(0, 90, 0)\n  targetRot: Quaternion = Quaternion.Euler(0, 0, 0)\n  fraction: number = 0\n}\n\n// a system to carry out the rotation\nexport class SlerpRotate implements ISystem {\n  update(dt: number) {\n    let slerp = myEntity.getComponent(SlerpData)\n    let transform = myEntity.getComponent(Transform)\n    if (slerp.fraction &lt; 1) {\n      let rot = Quaternion.Slerp(\n        slerp.originRot,\n        slerp.targetRot,\n        slerp.fraction\n      )\n      transform.rotation = rot\n      slerp.fraction += dt / 5\n    }\n  }\n}\n\n// Add system to engine\nengine.addSystem(new SlerpRotate())\n\nconst myEntity = new Entity()\nmyEntity.addComponent(new Transform())\nmyEntity.addComponent(new BoxShape())\n\nmyEntity.addComponent(new SlerpData())\nmyEntity.getComponent(SlerpData).originRot = Quaternion.Euler(0, 90, 0)\nmyEntity.getComponent(SlerpData).targetRot = Quaternion.Euler(0, 0, 0)\n\nengine.addEntity(myEntity)\n\n\n\n  Note: You could instead represent the rotation with Vector3 values and use a Lerp() function, but that would imply a conversion from Vector3 to Quaternion on each frame. Rotation values are internally stored as quaternions in the Transform component, so it’s more efficient to work with quaternions.\n\n\n\n\nChange scale between two sizes\n\nIf you want an entity to change size smoothly and without changing its proportions, use the lerp (linear interpolation) algorithm of the Scalar object.\n\nOtherwise, if you want to change the axis in different proportions, use Vector3 to represent the origin scale and the target scale, and then use the lerp function of the Vector3.\n\nThe lerp() function of the Scalar object takes three parameters:\n\n\n  A number for the origin scale\n  A number for the target scale\n  The amount, a value from 0 to 1 that represents what fraction of the scaling to do.\n\n\nconst originScale = 1\nconst targetScale = 10\n\nlet newScale = Scalar.Lerp(originScale, targetScale, 0.6)\n\n\nTo implement this lerp in your scene, we recommend creating a custom component to store the necessary information. You also need to define a system that implements the gradual scaling in each frame.\n\n@Component(\"lerpData\")\nexport class LerpSizeData {\n  origin: number = 0.1\n  target: number = 2\n  fraction: number = 0\n}\n\n// a system to carry out the movement\nexport class LerpSize implements ISystem {\n  update(dt: number) {\n    let transform = myEntity.getComponent(Transform)\n    let lerp = myEntity.getComponent(LerpSizeData)\n    if (lerp.fraction &lt; 1) {\n      let newScale = Scalar.Lerp(lerp.origin, lerp.target, lerp.fraction)\n      transform.scale.setAll(newScale)\n      lerp.fraction += dt / 6\n    }\n  }\n}\n\n// Add system to engine\nengine.addSystem(new LerpSize())\n\nconst myEntity = new Entity()\nmyEntity.addComponent(new Transform())\nmyEntity.addComponent(new BoxShape())\n\nmyEntity.addComponent(new LerpSizeData())\nmyEntity.getComponent(LerpSizeData).origin = 0.1\nmyEntity.getComponent(LerpSizeData).target = 2\n\nengine.addEntity(myEntity)\n\n\n\n\nMove at irregular speeds between two points\n\nWhile using the lerp method, you can make the movement speed non-linear. In the previous example we increment the lerp amount by a given amount each frame, but we could also use a mathematical function to increase the number exponentially or in other measures that give you a different movement pace.\n\nYou could also use a function that gives recurring results, like a sine function, to describe a movement that comes and goes.\n\n@Component(\"lerpData\")\nexport class LerpData {\n  origin: Vector3 = Vector3.Zero()\n  target: Vector3 = Vector3.Zero()\n  fraction: number = 0\n}\n\nexport class LerpMove implements ISystem {\n  update(dt: number) {\n    let transform = myEntity.getComponent(Transform)\n    let lerp = myEntity.getComponent(LerpData)\n    lerp.fraction += (dt + lerp.fraction) / 10\n    transform.position = Vector3.Lerp(lerp.origin, lerp.target, lerp.fraction)\n  }\n}\n\n// Add system to engine\nengine.addSystem(new LerpMove())\n\n\nThe example above is just like the linear lerp example we’ve shown before, but the fraction field is increased in a non-linear way, resulting in a curve moves the entity by greater increments on each frame.\n\n\n\nFollow a path\n\nA Path3 object stores a series of vectors that describe a path. You can have an entity loop over the list of vectors, performing a lerp movement between each.\n\nconst point1 = new Vector3(1, 1, 1)\nconst point2 = new Vector3(8, 1, 3)\nconst point3 = new Vector3(8, 4, 7)\nconst point4 = new Vector3(1, 1, 7)\n\nconst myPath = new Path3D([point1, point2, point3, point4])\n\n@Component(\"pathData\")\nexport class PathData {\n  origin: Vector3 = myPath.path[0]\n  target: Vector3 = myPath.path[1]\n  fraction: number = 0\n  nextPathIndex: number = 1\n}\n\nexport class PatrolPath implements ISystem {\n  update(dt: number) {\n    let transform = myEntity.getComponent(Transform)\n    let path = myEntity.getComponent(PathData)\n    if (path.fraction &lt; 1) {\n      transform.position = Vector3.Lerp(path.origin, path.target, path.fraction)\n      path.fraction += dt / 6\n    } else {\n      path.nextPathIndex += 1\n      if (path.nextPathIndex &gt;= myPath.path.length) {\n        path.nextPathIndex = 0\n      }\n      path.origin = path.target\n      path.target = myPath.path[path.nextPathIndex]\n      path.fraction = 0\n    }\n  }\n}\n\nengine.addSystem(new PatrolPath())\n\nconst myEntity = new Entity()\nmyEntity.addComponent(new Transform())\nmyEntity.addComponent(new BoxShape())\nmyEntity.addComponent(new PathData())\n\nengine.addEntity(myEntity)\n\n\nThe example above defines a 3D path that’s made up of four 3D vectors. We also define a custom PathData component, that includes the same data used by the custom component in the lerp example above, but adds a nextPathIndex field to keep track of what vector to use next from the path.\n\nThe system is very similar to the system in the lerp example, but when a lerp action is completed, it sets the target and origin fields to new values. If we reach the end of the path, we return to the first value in the path."
        }
        
      
    
  
    
      
        ,
        
        "development-guide-content-intro": {
          "id": "development-guide-content-intro",
          "title": "Overview",
          "categories": "development-guide",
          "url": " /development-guide/content-intro/",
          "content": "Decentraland is made up of parcels of LAND, each 16 meters by 16 meters. A scene is an experience that is built on one or several parcels.\n\nScenes are displayed one next to the other and players can freely walk from one to the other. Each scene is its own contained little world, items from one scene can’t extend out into another scene, and the code for each scene is sandboxed from all others.\n\nThere are two tools you can use for creating interactive Decentraland scenes:\n\n\n  \n    The Builder: a simple drag and drop editor. No coding required, everything is visual and many default items are at your disposal to use.\n  \n  \n    The Decentraland SDK: write code to create your scene. This gives you much greater freedom and is a lot more powerful.\n  \n\n\nThe Builder uses the Decentraland SDK under the hood, generating the required code without you ever needing to look at it. You can start a scene with the Builder, and then export it to continue working on it with the SDK.\n\n\n  Note: If a scene is created by or modified by the SDK, you can’t import it into the Builder. You can only go from the Builder to the SDK, not in the other direction.\n\n\nThe Builder\n\nOpen the Builder and try it out!\n\nTake a look at our video tutorials\n\nOr read the documentation\n\nThe SDK\n\nFollow the SDK 101 tutorial for a quick crash course.\n\nTake a look at the escape room video tutorial series.\n\nOr read the documentation\n\nShortcuts\n\n\n  \n    \n      \n      Coding scenes\n      An overview of the tools and the essential concepts surrounding the SDK.\n    \n  \n  \n    \n      \n      Component and object reference\n      A complete reference of the default components and other available objects, with their functions.\n    \n  \n  \n    \n      \n      Scene examples\n      Several code examples to get you started, and inspire your creations.\n    \n  \n\n\nSeveral libraries are built upon the Decentraland SDK to help you build faster, see the full list in the Awesome Repository\n\nSDK Scene examples\n\n\n  \n    \n      \n      Hypno wheels\n    \n  \n  \n    \n      \n      Hummingbirds\n    \n  \n  \n    \n      \n      Gnark patrolling\n    \n  \n\n\nSee scene examples for more scene examples.\n\nAlso see tutorials for detailed instructions for building scenes like these.\n\nOther useful information\n\n\n  Design constraints for games\n  3D modeling\n  Scene limitations"
        }
        
      
    
  
    
      
        ,
        
        "development-guide-sdk-101": {
          "id": "development-guide-sdk-101",
          "title": "SDK 101",
          "categories": "development-guide",
          "url": " /development-guide/SDK-101/",
          "content": "The Decentraland SDK is a powerful tool that lets you create scenes by writing code.\n\nInstall the CLI\n\nTo get started, install the Command Line Interface (CLI).\n\nThe CLI allows you to compile and preview your scene locally. After testing your scene locally, you can use the CLI to upload your content.\n\n\n  Note: Install the following dependencies before you install the CLI:\n\n  \n    Node.js (version 8 or later)\n  \n\n\nTo install the CLI, run the following command in your command line tool of choice:\n\nnpm install -g decentraland\n\n\nRead Installation guide for more details about installing the CLI.\n\nCreate your first scene\n\nCreate a new scene by going to an empty folder and running the following command line command:\n\ndcl init\n\nThe dcl init command will prompt you about what kind of project to create. Select Scene.\n\nPreview the 3D scene in your browser by running the following command in that same folder:\n\ndcl start\n\n\nRead more about the scene preview in preview a scene\n\nEdit the scene\n\nOpen the src/game.ts file from your scene folder with the source code editor of your choice.\n\n\n  Tip: We recommend using a source code editor like Visual Studio Code or Atom. An editor like this helps you by marking syntax errors, autocompleting while you write and even showing smart suggestions that depend on context. Also click on an object to see the full definition of its class.\n\n\n/// --- Set up a system ---\n\nclass RotatorSystem {\n  // this group will contain every entity that has a Transform component\n  group = engine.getComponentGroup(Transform)\n\n  update(dt: number) {\n    // iterate over the entities of the group\n    for (let entity of this.group.entities) {\n      // get the Transform component of the entity\n      const transform = entity.getComponent(Transform)\n\n      // mutate the rotation\n      transform.rotate(Vector3.Up(), dt * 10)\n    }\n  }\n}\n\n// Add a new instance of the system to the engine\nengine.addSystem(new RotatorSystem())\n\n/// --- Spawner function ---\n\nfunction spawnCube(x: number, y: number, z: number) {\n  // create the entity\n  const cube = new Entity()\n\n  // set a transform to the entity\n  cube.addComponent(new Transform({ position: new Vector3(x, y, z) }))\n\n  // set a shape to the entity\n  cube.addComponent(new BoxShape())\n\n  // add the entity to the engine\n  engine.addEntity(cube)\n\n  return cube\n}\n\n/// --- Spawn a cube ---\n\nconst cube = spawnCube(5, 1, 5)\n\ncube.addComponent(\n  new OnClick(() =&gt; {\n    cube.getComponent(Transform).scale.z *= 1.1\n    cube.getComponent(Transform).scale.x *= 0.9\n\n    spawnCube(Math.random() * 8 + 1, Math.random() * 8, Math.random() * 8 + 1)\n  })\n)\n\n\nChange anything you want from this code, for example change the x position of the first cube entity that’s spawned. If you kept the preview running in a browser tab, you should now see the changes show in the preview.\n\nDownload this 3D model of an avocado from the scene’s GitHub repo in glTF format. link.\n\n\n\nCreate a new folder under your scene’s directory named /models. Extract the downloaded file and place all of its contents in that folder. Note that there are several files that make up the 3D model, all of them must be in the same path.\n\nAt the end of your scene’s code, add the following lines:\n\nlet avocado = new Entity()\navocado.addComponent(new GLTFShape(\"models/avocado.gltf\"))\navocado.addComponent(\n  new Transform({\n    position: new Vector3(3, 1, 3),\n    scale: new Vector3(10, 10, 10),\n  })\n)\nengine.addEntity(avocado)\n\n\nYou can also download the finished scene from its GitHub repo.\n\nCheck your scene preview once again to see that the 3D model is now there too.\n\n\n\nThe lines you just added create a new entity, give it a shape based on the 3D model you downloaded, and set its position and scale.\n\nNote that the avocado you added rotates, just like all other entities in the scene. That’s because the RotatorSystem system that was defined in the default code of this scene is iterating over every entity in the scene and rotating it.\n\nRead coding-scenes for a high-level understanding of how Decentraland scenes function.\n\nSee the Development guide section for more instructions about adding content to your scene.\n\nPublish your scene\n\nOnce you’re done creating the scene and want to upload it to your LAND, see publishing.\n\nMore Tutorials\n\nRead our tutorials or view or video tutorials for detailed instructions for building basic scenes.\n\nTo see our official example scenes, with links to their code, see scene examples.\n\nEngage with other developers\n\nVisit Discord, join a lively discussion about what’s possible and how!\n\nTo debug any issues, we encourage that you post issues to the SDK Support category Decentraland Forum.\n\nYou can also post to Stack Overflow, using the tags decentraland or decentraland-ecs.\n\nYou can also ask in Discord. In the Support section, the #sdk channel is for questions regarding code, the #builder-and-3d channel is for questions regarding 3D models and art. #code-contribution is for discussing PRs to the SDK codebase.\n\nThe Utils library\n\nThe Decentraland ESC Utils library includes a number of helper methods that make it easier to carry out a lot of common use cases.\n\nTo use any of the helpers provided by the Utils library:\n\n\n  \n    Install it as an npm package. Run this command in your scene’s project folder:\n\n    npm install @dcl/ecs-scene-utils -B\n    \n  \n  \n    Run one of the following for the scene to build the necessary files inside the library’s folder:\n\n    dcl build\n    \n\n    or\n\n    dcl start\n    \n  \n  \n    Import the library into the scene’s script. Add this line at the start of your game.ts file, or any other TypeScript files that require it:\n\n    import * as utils from \"@dcl/ecs-scene-utils\"\n    \n  \n  \n    In your TypeScript file, write utils. and let the suggestions of your IDE show the available helpers.\n  \n\n\nRead the full documentation of the ECS Utils library here\n\n3D Art Assets\n\nA good experience will have great 3D art to go with it. If you’re keen on creating those 3D models yourself, you’re encouraged to, see the 3D Modeling section of our docs for more info. But if you prefer to focus on the coding or game design side of things, you don’t need to create your own assets!\n\nHere are a few tips to get great 3D models that you can use in a Decentraland scene:\n\n\n  Build a scene in the Decentraland Builder and export it, together with all its assets, to keep working on it with the SDK.\n  Download all the 3D assets available in the Builder from this repo\n  SketchFab\n  Clara.io\n  Archive3D\n  SketchUp 3D Warehouse\n  Thingiverse (3D models made primarily for 3D printing, but adaptable to Virtual Worlds)\n  ShareCG\n\n\n\n  Note: Models must be in the supported .gltf or .glb formats, and must have a number of triangles, textures and materials that adhere to the scene limitations. If getting models from a third party site, pay attention to the licence restrictions that the content you download has.\n\n\nOther useful information\n\n\n  Awesome Repository\n  ECS Utils library\n  Design constraints for games\n  3D modeling\n  Scene limitations"
        }
        
      
    
  
    
      
        ,
        
        "development-guide-text": {
          "id": "development-guide-text",
          "title": "Text shapes",
          "categories": "development-guide",
          "url": " /development-guide/text/",
          "content": "Add text to a scene using the TextShape component. This text sits in a position\n\nText in Decentraland supports all utf8 characters, this includes oriental and special characters.\n\n\n  Note: This component is useful for in-world labels and UIs that exist in the 3D space of the scene, not for the player’s 2D HUD UI.\n\n\nThe TextShape component is mutually exclusive with other shape components like primitive shapes and glTF 3D models, see Shape components for more details.\n\nTo add text as a label on an existing entity, you create a second entity that has the TextShape component and set it as a child of the other entity.\n\nCreate a text component\n\nThe following example shows how to create a TextShape component and add it to an entity.\n\nconst myEntity = new Entity()\nconst myText = new TextShape(\"Hello World!\")\nmyEntity.addComponent(myText)\n\n\n\n  Note: If the entity with the text component is a child of another entity, then it will be affected by the parent’s scale. If the parent is scaled unevenly, this will result in the text also being stretched or compressed.\n\n\nChange the text value\n\nWhen creating a new text component, you assign it a string to display. This string is stored in the value field.\n\nIf you want to change the string displayed by the component, you can do so at any time by changing the value field.\n\nmyEntity.getComponent(TextShape).value = \"new string\"\n\n\nBasic text properties\n\nThe TextShape component has several properties that can be set to style the text. Below are some of the most common:\n\n\n  font: Font object. Font objects are initiated with a value from the Fonts enum, which contains all supported fonts. By default uses LiberationSans.\n  fontSize: number.\n  color: Color3 object. Color3 objects store an RBG color as three numbers from 0 to 1.\n\n\n\n\n\n  opacity: number. Set it to less than 1 to make the text translucid.\n\n\nconst myText = new TextShape(\"Hello World!\")\nmyText.fontSize = 30\nmyText.color = Color3.Blue()\nmyText.font = new Font(Fonts.SansSerif)\n\n\nFonts\n\nBy default, text in Decenrtaland uses the font LiberationSans. To use another font, you need to instance a new Font object and assign it to the font property of the TextShape object.\n\nWhen instancing a Font, you need to pass it a value from the Fonts enum. This enum is a list that contains all the supported fonts.\n\nconst myText = new TextShape(\"Hello World!\")\nmyText.font = new Font(Fonts.SansSerif)\n\n\nThe following fonts are currently supported:\n\n\n  LiberationSans\n  SansSerif\n  SansSerif_Bold\n  SansSerif_Heavy\n  SansSerif_Semibold\n\n\n\n  TIP: If using VS studio or some other IDE, type Font. and you should see a list of suggestions with all of the available fonts.\n\n\nYou can share a same instanced Font object accross multiple TextShape components.\n\nconst sfFont = new Font(Fonts.SansSerif)\n\nconst myText = new TextShape(\"Hello World!\")\nmyText.font = sfFont\n\nconst myText2 = new TextShape(\"Bye World!\")\nmyText2.font = sfFont\n\n\nText alignment and padding properties\n\nThe TextShape component creates a text box that has a size, padding, etc.\n\n\n  hTextAlign: string. Either left, right or center (default).\n  vTextAlign: string. Either top, bottom or center (default).\n  width: number. The width of the text box.\n  height: number. The height of the text box.\n  resizeToFit: boolean. If true, the font size is adjusted to fit as large as possible in the text box.\n  paddingTop: number. Space between the text and the outline of the text box.\n  paddingRight: number. Space between the text and the outline of the text box.\n  paddingBottom: number. Space between the text and the outline of the text box.\n  paddingLeft: number. Space between the text and the outline of the text box.\n  zIndex: number. Useful for when multiple flat entities occupy the same space, it determines which one to show in front.\n\n\n\n  Tip: If a text is meant to float in space, it’s a good idea to add a Billboard component so that the text rotates to always face the player and be legible.\n\n\nText shadow and outline properties\n\nThe text has no shadow by default, but you can set the following values to give it a shadow-like effect.\n\n\n  shadowBlur: number\n  shadowOffsetX: number\n  shadowOffsetY: number\n  shadowColor: Color3 object. Color3 objects store an RBG color as three numbers from 0 to 1.\n\n\nmyEntity.addComponent(new TextShape(\"Text with shadow\"))\nmyEntity.getComponent(TextShape).shadowColor = Color3.Gray()\nmyEntity.getComponent(TextShape).shadowOffsetY = 1\nmyEntity.getComponent(TextShape).shadowOffsetX = -1\n\n\nEvery letter can also have an outline in a different color surrounding its perimeter.\n\n\n  outlineWidth: number. How many pixels wide the text outline will be, in all directions. By default 0, which makes it invisible.\n  outlineColor: Color3 object. Color3 objects store an RBG color as three numbers from 0 to 1.\n\n\nMultiple lines\n\nIf you want your text to span multiple lines, use \\n as part of the string. The following example has two separate lines of text:\n\nmyEntity.addComponent(new TextShape(\"This is one line. \\nThis is another line\"))\n\n\nYou can also set up the following properties related to texts with multiple lines:\n\n\n  lineCount: number. How many lines of text to fit into the textbox as a maximum. By default 1. The textWrapping property must be true to use more than one line.\n  lineSpacing: string. How much space between each line.\n\n\nClicking text\n\nTextShape components aren’t clickable by default.\n\nIf you want to place a text label over a button, the text will not allow you to click the button behind it. In these cases, you can set the isPickable field of the TextShape to false.\n\nmyEntity.addComponent(new TextShape(\"Text\"))\nmyEntity.getComponent(TextShape).isPickable = false"
        }
        
      
    
  
    
      
        ,
        
        "development-guide-scene-files": {
          "id": "development-guide-scene-files",
          "title": "Files in a scene",
          "categories": "development-guide",
          "url": " /development-guide/scene-files/",
          "content": "After creating a new scene using the CLI, the scene folder will have a series of files with default content.\n\nDefault files in a local scene\n\nScenes include the following files:\n\n\n  src/game.ts: The entry point of the scene.\n  scene.json: The manifest that contains metadata for the scene.\n  package.json and package-lock.json: Specify the versions of all dependencies of the scene.\n  tsconfig.json: Typescript configuration file.\n  .dclignore: Lists what files in your project not to deploy to IPFS.\n\n\ngame.ts\n\nThis is the entry point to your scene’s code. You could fit your entire scene’s logic into this file, although for clarity in most cases we recommend spreading out your code over several other .ts files and importing them into game.ts.\n\nIn most cases, you’ll only need to edit this file to create your scene. It contains the code that generates an entity tree, which is what end users of your parcel will see.\n\nBelow is a basic example of a game.ts file:\n\n// Create a component group to track entities with Transform components\nlet group = engine.getComponentGroup(Transform)\n\n// Create a system\nexport class RotatorSystem {\n  // The update() function runs on every frame.\n  update() {\n    // Cycle over the entities in the component group\n    for (let entity of group.entities) {\n      const transform = entity.getComponent(Transform)\n      transform.rotation.y += 2\n    }\n  }\n}\n\n// Create an entity\nconst cube = new Entity()\n\n// Add a cube shape to the entity\ncube.addComponent(new BoxShape())\n\n// Add a transform component to the entity\ncube.addComponent(\n  new Transform({\n    position: new Vector3(5, 0, 5),\n  })\n)\n\n// Add the entity to the engine\nengine.addEntity(cube)\n\n// Add the system to the engine\nengine.addSystem(new RotatorSystem())\n\n\nscene.json\n\nThe scene.json file is a JSON formatted manifest for a scene in the world. A scene can span a single or multiple LAND parcels. The scene.json manifest describes what objects exist in the scene, a list of any assets needed to render it.\n\ncontact information for the parcel owner, and security settings. For more information and an example of a\nscene.json file, please visit the Decentraland specification proposal.\n\nAll of this metadata is optional for previewing the scene locally, but part of it is needed for deploying. You can change this information manually at any time.\n\npackage.json\n\nThis file provides information to NPM that allows it to identify the project, as well as handle the project’s dependencies. Decentraland scenes need two packages:\n\n\n  decentraland-api: allows the scene to communicate with the world engine.\n  typescript: used to compile the file game.ts to javascript.\n\n\npackage-lock.json\n\nThis file lists the versions of all the other dependencies of the project. These versions are locked, meaning that the compiler will use literally the same minor release listed here.\n\nYou can change any package version manually by editing this file.\n\ntsconfig.json\n\nDirectories containing a tsconfig.json file are root directories for TypeScript Projects. The tsconfig.json file specifies the root files and options required to compile your project from TypeScript into JavaScript.\n\n\n  You can use another tool or language instead of TypeScript, so long as your scripts are contained within a single Javascript file (scene.js). All provided type declarations are made in TypeScript, and other languages and transpilers are not officially supported.\n\n\nRecommended file locations\n\nKeep in mind that when you deploy your scene to Decentraland, any assets or external libraries that are needed to use your scene must be either packaged inside the scene folder or available via a remote server.\n\nAnything that is meant to run in the player’s client must located inside the scene folder. You shouldn’t reference files or libraries that are installed elsewhere in your local machine, because they won’t be available to the deployed scene.\n\nWe suggest using these folder names consistently for storing the different types of assets that your scene might need:\n\n\n  3d models: /models\n  Videos: /videos\n  Sound files: /sounds\n  Image files for textures (except for glTF models): /materials\n  .ts definitions for components /src/components\n  .ts definitions for systems /src/systems\n\n\n\n  Note: Supporting files for glTF models, like their texture image files or .bin files, should always be placed in the same folder as the model’s .gltf or .glb file.\n\n\n\n  Note: We recommend using always lower case names for all folders and file names, to avoid possible issues.\n\n\nThe dclignore file\n\nAll scenes include a .dclignore file, this file specifies what files in the scene folder to ignore when deploying a scene to Decentraland.\n\nFor example, you might like to keep the Blender files for the 3D models in your scene inside the scene folder, but you want to prevent those files from being deployed to Decentraland. In that case, you could add *.blend to .dclignore to ignore all files with that extension.\n\n\n  \n    \n      What to ignore\n      Example\n      Description\n    \n  \n  \n    \n      Specific files\n      BACKUP.ts\n      Ignores a specific file\n    \n    \n      Folders\n      drafts/\n      Ignores entire contents of a folder and its subfolders\n    \n    \n      Extensions\n      *.blend\n      Ignores all files with a given extension\n    \n    \n      Name sections\n      test*\n      Ignores all files with names that match the query. In this case, that start with test"
        }
        
      
    
  
    
      
        ,
        
        "builder-smart-items": {
          "id": "builder-smart-items",
          "title": "Smart items",
          "categories": "builder",
          "url": " /builder/smart-items/",
          "content": "Smart items are Builder items that come with their own built-in interactive behavior.\n\nThey often have fields that can be configured, like a text field in a sign post. They also can trigger actions on other items, for example a button smart item can call a door smart item to open it.\n\nSmart items can be easily told apart in the item catalogue because their preview image has a purple background and a star logo on them.\n\n\n\nConfigure an item\n\nTo configure a smart item select it in your scene and a contextual menu opens on the right, showing all the configurable fields.\n\nDifferent smart items have different fields that can be configured, depending on what makes sense for each.\n\n\n\nCall an action on another item\n\nMany smart items can trigger actions on other smart items.\n\nFor example, a button smart item has a When Clicked field. In this field you can add an action from another item, for example the Open action of a door.\n\n\n\nTrigger multiple actions in a single field. By clicking the plus sign you can add multiple actions to be triggered together.\n\nRemove actions by clicking the three dots next to an action and selecting Delete to remove it.\n\nIn these fields you can also call actions on the same smart item that’s doing the triggering.\n\nSpecial smart items\n\nSome smart items have unique characteristics that make them very handy for common scenarios:\n\n\n  \n    Invisible wall: An invisible cube that stops the player from walking through it. This item can be enabled or disabled by any other smart item, when disabled it will let players walk through it.\n  \n  \n    Trigger area: An invisible cube that can trigger actions from other smart items when the player enters or leaves the area it covers. This item can be enabled or disabled by other smart items, when disabled it won’t trigger any actions.\n  \n  \n    Click area: An invisible cube that can be clicked by players to trigger actions on any other smart items. This item can be enabled or disabled by any other smart item, when disabled it won’t be clickable. You can also set the text that players see when pointing their cursor at it.\n  \n  \n    Ambient sound: A sound source that plays a series of predefined ambient sounds. It can be set to always play or to only do so when activated by other smart items. It can also be set to play once or loop.\n  \n  \n    Arrow: Show a hint arrow, pointing at something that the player should interact with. This item can be enabled or disabled by other smart items, when disabled the arrow is invisible.\n  \n  \n    Message: A 3d sign that starts minimized and can be expanded by players to be read.\n  \n\n\nThe Tools smart item is a super versatile collection of tools that can act upon other items. Drag one of these into a scene, then call its actions from any other smart item. You only need one instance of this item, use it as many times as you want or even use it to call its own actions recursively.\n\n\n  \n    Move Item: Smoothly move an item from one position to another. It can act on any item in the scene, smart or not. Choose relative positions to specify how much to move it from where it is, or absolute positions to move it to specific coordinates in the scene, regardless of where it was before.\n\n    \n      Note: All measurements are in meters, consider that one parcel is 16x16 meters. If using absolute positions, all coordinates are measured from the bottom-left corner of the scene.\n    \n  \n  \n    Rotate Item: Smoothly rotate an item from one position to another. It can act on any item in the scene, smart or not. Choose relative rotations to specify how much to rotate it from where it is, or absolute rotations to rotate it to a specific direction, regardless of where it was facing.\n  \n  \n    Scale Item: Smoothly transition an item from one scale to another. You can also scale it in different proportions for each axis. It can act on any item in the scene, smart or not.\n  \n  \n    Delay: Wait a given amount of seconds before triggering an action in a smart item.\n  \n  \n    Interval: Trigger an action in a smart item regularly, every given amount of seconds.\n\n    \n      Note: Once an interval action starts repeating an action, it can’t be stopped.\n    \n  \n  \n    Print Message: Display a text message on the player’s screen for a given amount of seconds. The message can be just for the player that triggered the action, or for all players in the scene.\n  \n\n\n\n  Tip: You can call as many actions as you want in succession, using the When transition finished field in the Move Item, Rotate Item and Scale Item actions.\n\n\nMultiplayer\n\nAlmost all smart items have multiplayer behavior, so that all players in the scene share the same experience as the items change state. If player A opens a door, player B also sees that door open. If player C then walks into the scene while the other players are still there, she will see the door as already open too.\n\nHowever, if there are no players near the scene, then the scene is restored to its default state. So if all players leave, but then player A comes back, she will find the door closed (if that was the default state of the door).\n\nMake sure you design your scene so that the actions of one player don’t sabotage the scene for others that come later. For example, if the scene is a puzzle game, you can use a delay action on a tools smart item to make all the items in the scene reset to their initial state a few seconds after the puzzle is solved.\n\nIf there’s a key in your scene that’s essential for progressing, it’s possible for a player to pick it up and run off, blocking other players from advancing. One possible way to prevent this scenario is to have a trigger area on the scene’s exit door that calls the drop action on the key, so that it returns to its place of origin.\n\nTroubleshooting\n\n\n  An item in my scene should be clickable, but can’t be clicked.\n\n\nMake sure that it’s not being obstructed by something else. You can’t click through other items. Some items have a collider mesh that has a simplified geometry that may be obstructing your item, even though its visible shape doesn’t seem to be doing it. Try moving the item to see what happens.\n\nCustom smart items\n\nBesides the default collection of smart items that come with the Builder, you can develop your own to import into your Builder account and use freely. This requires writing code using the SDK. See smart items for instructions."
        }
        
      
    
  
    
      
        ,
        
        "builder-manage-scenes": {
          "id": "builder-manage-scenes",
          "title": "Manage Builder scenes",
          "categories": "builder",
          "url": " /builder/manage-scenes/",
          "content": "Export a scene\n\nWhile editing a scene, press the Download scene icon to download the contents of the scene as a .zip file. In the scene selector screen, you can also press the three dots icon and select Download scene.\n\n\n\nYou can then share this scene with another Builder user, or edit the scene with more freedom by using the Decentraland SDK.\n\nSee SDK 101 if you’re not yet familiar with coding with the Decentraland SDK.\n\nImport a scene\n\nIn the scene selector screen, press Import scene, then drag one or several .zip files from exported Builder scenes and press Import.\n\nIf a scene is too large to import, try this:\n\n\n  Decompress the scene .zip file.\n  Look for the builder.json inside the uncompressed folder. Compress that single file into a new .zip file.\n  Import this new .zip file.\n\n\n\n  Note: You can only import scenes that have been built with the Builder. You can’t import a scene that was built with the SDK or modified with it.\n\n\nDelete a scene\n\nIn the scene selector screen, press the three dots icon and select Delete scene.\n\nScene storage\n\nIf your Builder account is accessed via an in-browser wallet, like Metamask or Dapper, all of your existing scenes are saved and updated to a cloud storage that you can access from any other device where you’re logged in.\n\nIf you don’t have your account connected to an in-browser wallet, your scenes are stored in the browser’s cache storage. They won’t be available if you log in from another device. Be careful not to clear the browser’s storage, as you will lose your scenes. We advise exporting your scenes to keep a backup in your local disk."
        }
        
      
    
  
    
      
        ,
        
        "builder-import-items": {
          "id": "builder-import-items",
          "title": "Import custom items",
          "categories": "builder",
          "url": " /builder/import-items/",
          "content": "You can import your own 3D models into the Builder. This allows you to pick models from a wide selection of free sources on the internet, or to create your own custom models.\n\nUpload a model\n\nAll custom items are stored in user-created asset packs. Each asset pack holds one or many assets.\n\nTo create a new asset pack:\n\n\n  Open the editor for any scene and click New Asset Pack at the bottom of the item catalogue, or the plus sign at the top of the categories list.\n  Drag a 3D model file into the window, or multiple files at once.\n  Press Import assets.\n  Name each asset, and potentially add tags to better identify them.\n  Name the asset pack and press Create Asset Pack.\n\n\nNow you’ll see a new folder in the items catalogue with your new asset pack, and you can use your new assets in any scene, just like the default items.\n\nOnce created, a custom asset pack is be available in every scene you edit as long as you log in with the same account.\n\nSupported models\n\nAll 3D models need to be in .glTF or .glb format. You can convert other formats into these formats with various different editors and tools. See 3D modeling for recommendations and tips.\n\nAll materials in the models need to be either basic material or PBR, and all textures need to be in sizes that are powers of two (ex: 256, 512). See Scene limitations for details.\n\nIf a 3D model relies on external files besides the .gltf file (like .bin or .png files) compress all the relevant files for the 3D model into a .zip file. Then import only this .zip file into the Builder.\n\nAll 3D model files must occupy less than 5mb to be imported into the Builder. Larger files aren’t supported.\n\nFree libraries for 3D models\n\nInstead of building your own 3D models, you can also download them from several free or paid libraries.\n\nTo get you started, below is a list of libraries that have free or relatively inexpensive content:\n\n\n  SketchFab\n  Clara.io\n  Archive3D\n  SketchUp 3D Warehouse\n  Thingiverse (3D models made primarily for 3D printing, but adaptable to Virtual Worlds)\n  ShareCG\n\n\n\n  Note: Pay attention to the license restrictions that the content you download has.\n\n\nNote that in several of these sites, you can choose what format to download the model in. Always choose .glTF format if available. If not available, you must convert them to .glTF before you can use them in a scene. For that, we recommend importing them into Blender and exporting them with one of the available .glTF export add-ons.\n\nColliders\n\nYou might find that when running a preview the player can walk through your imported 3D models. This is likely because the models are missing a collider mesh to define a collision geometry. See colliders for more details and instructions.\n\n\n  Tip: Instead of editing the model to add a collider mesh, a simpler alternative is to an Invisible wall smart item with approximately the same shape to stand in its place.\n\n\nAnimations\n\nIf an imported model includes animations, the first animation that’s packed into the model will be played in a loop.\n\nNote that you don’t have any control over when the animation starts or stops, or which one is played in case of several animations.\n\nIf there are multiple players in the scene, they may be seeing the animation out of sync from each other.\n\nSmart items\n\nYou can also import your own custom smart items that have built-in interactive behavior, following the same steps as for uploading a model. See smart items."
        }
        
      
    
  
    
      
        ,
        
        "builder-export": {
          "id": "builder-export",
          "title": "Export as code",
          "categories": "builder",
          "url": " /builder/export/",
          "content": "You can start a scene with the Builder, and then make it more interactive by writing code with the SDK (Software Development Kit).\n\nThe Builder uses the Decentraland SDK under the hood, generating the required code without you ever needing to look at it. If you export the scene, then you can alter its code directly.\n\nTo export a scene, open the scene and click the export icon.\n\n\n\nThis will export the scene as a .zip file. This zip file will contain all of the required code and supporting files to run the scene, including 3D models, sound files, etc.\n\nSee SDK 101 if you’re not yet familiar with coding with the Decentraland SDK.\n\nWorkflow\n\nStart your scene in the Builder, and only export it when you’re sure you won’t be making any more changes to it from the Builder.\n\nOnce you modify your scene with the SDK, you can’t import those changes back into the Builder. You can only go from the Builder to the SDK, not in the other direction.\n\n\n  Note: If you attempt to reimport the scene into the Builder, the only file in the project folder that is considered is the builder.json file, that was generated when exporting from the Builder. Any changes you did to other files, like game.ts, are ignored when importing.\n\n\nAlternatively, you can keep all SDK changes in a neat section of your code, and manually paste these into newly exported versions of the Builder scene as you iterate it.\n\nSmart items\n\nIf the scene contains smart items, each smart item is exported as a separate folder that contains all the supporting code, 3D models, sound files, etc. These smart item folders are named using the smart item’s hash, for example 1fc96600-3d45-45f6-b364-86aa8cd15587.\n\nYou can modify the code for a smart item by changing the item’s item.ts file. Keep in mind that this will change all of the instances of that smart item in the scene.\n\nRotating a scene\n\nWhen exporting a scene, it’s always exported with the default orientation.\n\nYou may need to rotate the scene so that it better fits your land, especially for the case of scenes that are not square. The easiest way to do this is to edit the scene’s src/game.ts file to rotate the scene entity. This entity is a parent to everything else in the scene, so all the items in the scene will rotate with it.\n\nSince the scene entity rotates around the 0,0 point of the scene (the bottom-left corner), you will also need to shift the scene entity so that it aligns with the scene again.\n\nThe following example rotates a 2x1 scene so that it fits a 1x2 space. It rotates the whole scene 90 degrees, and then shifts it one parcel to the right to re-center the scene:\n\nconst _scene = new Entity(\"_scene\")\nengine.addEntity(_scene)\nconst transform = new Transform({\n  position: new Vector3(0, 0, 16),\n  rotation: Quaternion.Euler(0, 90, 0),\n  scale: new Vector3(1, 1, 1),\n})\n_scene.addComponentOrReplace(transform)\n\n\nSee Entity positioning for more details on how to move and rotate items."
        }
        
      
    
  
    
      
        ,
        
        "builder-builder-101": {
          "id": "builder-builder-101",
          "title": "Builder 101",
          "categories": "builder",
          "url": " /builder/builder-101/",
          "content": "The Builder is a simple visual editor tool that lets you create and publish Decentraland scenes.\n\nThe Builder is an on-line tool. It runs on the browser, you don’t need to install anything, simply visit builder.decentraland.org.\n\nScene size\n\nScenes in Decentraland occupy one or several adjacent LAND parcels. Each LAND parcel measures 16x16 meters.\n\nTo build something to deploy to LAND parcels you own, make sure the shape of the scene matches the shape of where you want it deployed.\n\n\n  Note: The Builder currently can only create rectangular-shaped scenes. To create an irregularly-shaped scene, you must use the SDK.\n\n\nYou can edit the size of an existing scene by clicking the pencil icon next to the scene name and then changing the number or rows and columns.\n\n\n\nSet the ground\n\nThe scene’s ground can use various different textures. You can find these in the different themed asset packs in the item menu.\n\nTo apply a ground, just click on the desired ground in the item menu, it will replace all the floor tiles in the scene, regardless of how many parcels are in the scene.\n\n\n\nAdd items\n\nNavigate the themed asset pack categories on the menu on the right to find different items that you can place on your scene. There’s a great variety!\n\nTo place an item:\n\n\n  Click and drag the item to a specific location in the scene.\n  Click on the item in the menu, it will appear in a random location in the scene.\n\n\nPosition items\n\nClick and drag a selected item to move it freely around the scene at ground level.\n\n\n\nTo move an item with more precision, use the Move tool, on the top menu. Each arrow lets you move the item in a single axis at a time. With this tool you can also position things above the ground level.\n\nTo rotate an item, select the Rotate tool on the top menu. A gizmo appears on the selected item, and you can use each of the hoops to rotate the item on one axis at a time.\n\nTo make an item larger or smaller, select the scale item on the top menu, then click on the center of the gizmo and drag in or out. This tool also lets you stretch an item in a single axis to change its proportions, to do this click on one of the axis of the gizmo and drag it.\n\n\n  Tip: To have greater precision while moving, rotating or scaling an item, press and hold the Shift key while making adjustments.\n\n\nTo delete an item from the scene, select it and click the Delete tool.\n\nTo duplicate an item, select it and click the Duplicate tool. The new item will be perfectly overlapping the original.\n\nTo select multiple items at the same time, press and hold the Control key while selecting them. You can then move, rotate, scale, duplicate or delete all of them in a single action.\n\nScene boundaries and limitations\n\nAll items need to stay inside the parcels that make up the scenes. If something extends out of the LAND parcels, that would be overlapping with a neighboring scene, which isn’t allowed.\n\nIf an item extends outside the parcels, it will be marked in red. The Builder won’t allow you to publish the scene until this is fixed.\n\n\n\nNote that 3d models have bounding boxes that surround them. Sometimes, even though the actual visible shape of the model is all inside the scene, the corners of this box extend out of bounds. This scenario is also considered out of bounds and must be fixed.\n\nIf you imported a custom 3D model that has bounding boxes that extend far beyond the model itself, it’s a good practice to edit the model to make sure the bounding boxes extend out as little as possible. See Meshes.\n\nTo keep scenes in Decentraland lightweight, you are limited to a maximum amount of textures, triangles, etc. See scene limitations.\n\nPreview\n\nTo test your scene and experience it like a player, click the eye icon on the top-right corner. This will open a scene preview, where you can move around the scene and interact with interactive items.\n\n\n\nTo exit the preview and return to editing the scene, press the ‘Esc’ key to free the cursor, then click the X icon on the top-right.\n\nName the scene\n\nClick the pencil icon next to the scene name to provide a name and an optional description for the scene.\n\nThis name is visible to players exploring your scene, it appears right beneath the minimap. Make sure the scene has a name that makes sene and gives players useful context.\n\nPublish your scene\n\nOnce you’re happy with the scene, press Publish.\n\n\n  \n    Select Scene pool to make your scene available for land owners that might want to publish it in their land.\n  \n  \n    Select My Land if you own land, or have been given deploy permissions by an owner. Then select the parcels where you want it deployed in the map. Parcels where you are allowed to deploy are shown in pink.\n  \n\n\n\n  Tip: Use the rotate arrows on the top-left to rotate your scene so that its shape fits the available parcels, or to ensure its front faces the right way.\n\n\nOnce your scene has been published, you can keep making changes to it and then press Update to publish these changes.\n\nOther useful information\n\n\n  Design constraints for games\n  3D modeling\n  Scene limitations"
        }
        
      
    
  
    
      
        ,
        
        "development-guide-sounds": {
          "id": "development-guide-sounds",
          "title": "Sounds",
          "categories": "development-guide",
          "url": " /development-guide/sounds/",
          "content": "Sound is a great way to provide feedback to player actions and events, background sounds can also give your scene more context and improve the player’s immersion into it.\n\n\n  Note: Keep in mind that sounds are only heard by players who are standing within the parcels that make up the scene where the sound was generated, even if they would otherwise be in hearing range. Players can also turn off sounds on their settings.\n\n\nSupported sound formats vary depending on the browser, but it’s recommended to use .mp3.\n\n.wav files are also supported but not generally recommended as they are significantly larger.\n\nPlay sounds\n\nTo play a sound, you need the following:\n\n\n  An Entity to use for the sound location.\n  An AudioSource component, added to that entity.\n  An AudioClip object, referenced by that component.\n\n\n// Create entity\nconst cube = new Entity()\n\n// Create AudioClip object, holding audio file\nconst clip = new AudioClip(\"sounds/carnivalrides.mp3\")\n\n// Create AudioSource component, referencing `clip`\nconst source = new AudioSource(clip)\n\n// Add AudioSource component to entity\ncube.addComponent(source)\n\n// Play sound\nsource.playing = true\n\n\nWhen creating an AudioClip object, you need to provide the path to the location of the sound file.\n\nThe sound file must be inside the project folder. In the example above, the audio file is located in a sounds folder, which is located at root level of the scene project folder.\n\n\n  Tip: We recommend keeping your sound files separate in a /sounds folder inside your scene.\n\n\nEach entity can only have a single AudioSource component, that can only have a single AudioClip. This limitation can be easily overcome by including multiple invisible entities, each with their own sound.\n\nIf you set the playing property of an AudioSource component to false, the file is stopped. This means that if you later set playing to true again, the sound file will begin from the start again.\n\nLooping\n\nTo keep a sound playing in a continuous loop, set the loop field of the AudioSource component to true before you start playing it.\n\nsource.loop = true\nsource.playing = true\n\n\nLooping sounds is especially useful for adding background music or other background sounds.\n\nYou can use the playOnce() function to play a sound once from start to finish.\n\nsource.playOnce()\n\n\nSet volume\n\nYou can set the volume property of the AudioSource component to change the volume of a sound.\n\nThe volume can be a number from 0 to 1.\n\nsource.volume = 0.5\n\n\n\n  Note: Of course, the volume of a sound is also affected by the distance from the audio source.\n\n\nReuse sound objects\n\nA great way to save processing power is to use a same AudioClip object on many AudioSource components.\n\nSuppose you have a large amount of balls bouncing around in your scene, and you want to hear a thump sound every time two of them collide. You can add an AudioSource component to each ball, and use a single AudioClip object on all of these.\n\n\n\nStreaming sound\n\nYou can stream audio from a URL. This is useful to play music directly from an internet radio, or stream a conference into your scene.\n\nThe audio in the source must be in one of the following formats: .mp3, ogg, or aac. The source must also be an https URL (http URLs aren’t supported), and the source should have CORS policies (Cross Origin Resource Sharing) that permit externally accessing it. If this is not the case, you might need to set up a server to act as a proxy and expose the stream in a valid way.\n\nTo add sound into your scene, simply add an entity with an AudioStream component:\n\nconst streamSource = new Entity()\nstreamSource.addComponent(\n  new AudioStream(\n    \"https://icecast.ravepartyradio.org/ravepartyradio-192.mp3\"\n  )\n)\nengine.addEntity(streamSource)\n\n\n\n  Note: The streamed sound isn’t positional, it will be heard at a consistent volume throughout your entire scene. If a player steps out of the scene, they will not hear the streaming at all.\n\n\nSet the volume of the AudioStream component by changing its volume property.\n\nSwitch the AudioStream component on or off by setting its playing property to true or false."
        }
        
      
    
  
    
      
        ,
        
        "development-guide-materials": {
          "id": "development-guide-materials",
          "title": "Materials via code",
          "categories": "development-guide",
          "url": " /development-guide/materials/",
          "content": "Materials\n\nMaterials can be applied to entities that use primitive shapes (cube, sphere, plane, etc) by setting them as a component.\n\nYou can either set a Material or a BasicMaterial component. Each entity can only have one of these. Both components have several fields that allow you to configure the properties of the material, add a texture and set the texture’s mapping.\n\nYou can’t add material components to glTF models. glTF models include their own materials that are implicitly imported into a scene together with the model.\n\nWhen importing a 3D model with its own materials, keep in mind that not all shaders are supported by the Decentraland engine. Only standard materials and PBR (physically based rendering) materials are supported. See external 3D model considerations for more details.\n\nCreate and apply a material\n\nThe following example creates a material, sets some of its fields to give it a red color and metallic properties, and then applies the material to an entity that also has a boxShape component.\n\n//Create entity and assign shape\nconst myEntity = new Entity()\nmyEntity.addComponent(new BoxShape())\n\n//Create material and configure its fields\nconst myMaterial = new Material()\nmyMaterial.albedoColor = Color3.Blue()\nmyMaterial.metallic = 0.9\nmyMaterial.roughness = 0.1\n\n//Assign the material to the entity\nmyEntity.addComponent(myMaterial)\n\n\nSee component reference) for a full list of all the fields that can be configured in a Material of BasicMaterial component.\n\nBasic materials\n\nInstead of the Material component, you can define a material through the BasicMaterial entity. This creates materials that are shadeless and are not affected by light. This is useful for creating user interfaces that should be consistently bright, it can also be used to give your scene a more minimalist look.\n\nconst myMaterial = new BasicMaterial()\n\n\n\n  Note: Basic materials have some property names that are different from those in normal materials. For example it uses texture instead of albedoTexture.\n\n\nMaterial colors\n\nGive a material a plain color. In a BasicMaterial component, you set the color field. In a Material component, you set the albedoColor field. Albedo colors respond to light and can include shades on them.\n\nAll color fields are either of type Color3 or Color4. Color3 holds three values, for Red, Green and Blue. Each of these numbers is between 0 and 1. Color4 holds those same three values and a fourth value for Alpha, also between 0 and 1, where 0 is completely transparent and 1 is completely opaque.\n\nmyMaterial.albedoColor = new Color3(0.5, 0, 0.5)\n\n\n\n  Note: If you set any color in albedoColor to a value higher than 1, it will appear as emissive, with more intensity the higher the value. So for example, new Color3(15, 0, 0) produces a very bright red glowing color.\n\n\nYou can also pick predetermined colors using the following functions of the Color3 object:\n\nlet red = Color3.Red()\n\nlet green = Color3.Green()\n\nlet blue = Color3.Blue()\n\nlet black = Color3.Black()\n\nlet white = Color3.White()\n\nlet purple = Color3.Purple()\n\nlet magenta = Color3.Magenta()\n\nlet yellow = Color3.Yellow()\n\nlet gray = Color3.Gray()\n\nlet teal = Color3.Teal()\n\n\nYou can otherwise pick a random color using the following function:\n\n// Pick a random color\nlet green = Color3.Random()\n\n\nIf you prefer to specify a color using hexadecimal values, as is often done in JavaScript web development, you can do so using the .FromHexString() function\n\nlet gray = Color3.FromHexString(\"#CCCCCCC\")\n\n\nThe Color3 object also includes a lot of other functions to add, substract, compare, lerp, or convert the format of colors.\n\nYou can also edit the following fields in a Material component to fine-tune how its color is percieved:\n\n\n  emissiveColor: The color emitted from the material.\n  ambientColor: AKA Diffuse Color in other nomenclature.\n  reflectionColor: The color reflected from the material.\n  reflectivityColor: AKA Specular Color in other nomenclature.\n\n\nChange a color gradually\n\nChange a color gradually with linear interpolation between two colors, using the .Lerp() function.\n\n// This variable will store the ratio between both colors\nlet colorRatio = 0\n\n// Define colors\nconst red = Color3.Red()\nconst yellow = Color3.Yellow()\n\n// Create material\nconst myMaterial = new Material()\n\n// This system changes the value of colorRatio every frame, and sets a new color on the material\nexport class ColorSystem implements ISystem {\n  update(dt: number) {\n    myMaterial.albedoColor = Color3.Lerp(red, yellow, colorRatio)\n    if (colorRatio &lt; 1) {\n      colorRatio += 0.01\n    }\n  }\n}\n\n// Add the system to the engine\nengine.addSystem(ColorSystem)\n\n\nThe example above changes the color of a material from red to yellow, incrementally shifting it on every frame.\n\nUsing textures\n\nReference an image file as a texture by creating a Texture component. You can then reference this texture component in the fields of both Material and BasicMaterial components.\n\nIn a Material component, you can set the albedoTexture field to a texture image. Albedo textures respond to light and can include shades on them.\n\n//Create entity and assign shape\nconst myEntity = new Entity()\nmyEntity.addComponent(new BoxShape())\n\n//Create texture\nconst myTexture = new Texture(\"materials/wood.png\")\n\n//Create a material\nconst myMaterial = new Material()\nmyMaterial.albedoTexture = myTexture\n\n//Assign the material to the entity\nmyEntity.addComponent(myMaterial)\n\n\nWhile creating a texture, you can also pass additional parameters:\n\n\n  samplingMode: Determines how pixels in the texture are stretched or compressed when rendered\n  wrap: Determines how a texture is tiled onto an object (see Texture Wrapping)\n\n\nlet smokeTexture = new Texture(\"textures/smoke-puff3.png\", {\n  wrap: 0,\n})\n\n\nTextures from an external URL\n\nYou can point the texture of your material to an external URL instead of an internal path in the scene project.\n\nconst myTexture = new Texture(\n  \"https://wearable-api.decentraland.org/v2/collections/community_contest/wearables/cw_tuxedo_tshirt_upper_body/thumbnail\"\n)\n\nconst myMaterial = new Material()\nmyMaterial.albedoTexture = myTexture\n\n\nThe URL must start with https, http URLs aren’t supported. The site where the image is hosted should also have CORS policies (Cross Origin Resource Sharing) that permit externally accessing it.\n\nTextures on basic materials\n\nIn a BasicMaterial component, you can set the texture field to an image texture. This will render a texture that isn’t affected by lighting.\n\n//Create entity and assign shape\nconst myEntity = new Entity()\nmyEntity.addComponent(new BoxShape())\n\n//Create texture\nconst myTexture = new Texture(\"materials/wood.png\")\n\n//Create material and configure its fields\nconst myMaterial = new BasicMaterial()\nmyMaterial.texture = myTexture\n\n//Assign the material to the entity\nmyEntity.addComponent(myMaterial)\n\n\nMulti-layered textures\n\nIt also allows you to use several image files as layers to compose more realistic textures, for example including a bumpTexture and a refractionTexture.\n\n//Create entity and assign shape\nconst myEntity = new Entity()\nmyEntity.addComponent(new BoxShape())\n\n//Create texture\nconst myTexture = new Texture(\"materials/wood.png\")\n\n//Create second texture\nconst myBumpTexture = new Texture(\"materials/woodBump.png\")\n\n//Create material and configure its fields\nconst myMaterial = new Material()\nmyMaterial.albedoTexture = myTexture\nmyMaterial.bumpTexture = myBumpTexture\n\n//Assign the material to the entity\nmyEntity.addComponent(myMaterial)\n\n\nIn the example above, the image for the material is located in a materials folder, which is located at root level of the scene project folder.\n\n\n  Tip: We recommend keeping your texture image files separate in a /materials folder inside your scene.\n\n\n\n  Tip: A material can have multiple layers of texture, you can see what these are on a source code editor by clicking . and letting the autocomplete menu show you the list.\n\n\nTexture wrapping\n\nIf you want the texture to be mapped to specific scale or alignment on your entities, then you need to configure uv properties on the shape components.\n\nYou set u and v coordinates on the 2D image of the texture to correspond to the vertices of the shape. The more vertices the entity has, the more uv coordinates need to be defined on the texture, a plane for example needs to have 8 uv points defined, 4 for each of its two faces.\n\n//Create material and configure fields\nconst myMaterial = new BasicMaterial()\nlet myTexture = new Texture(\"materials/atlas.png\", { wrap: 1, samplingMode: 0 })\nmyMaterial.texture = myTexture\n\n//Create shape component\nconst plane = new PlaneShape()\n\n// map the texture to each of the four corners of the plane\nplane.uvs = [\n  0, 0.75,\n\n  0.25, 0.75,\n\n  0.25, 1,\n\n  0, 1,\n\n  0, 0.75,\n\n  0.25, 0.75,\n\n  0.25, 1,\n\n  0, 1,\n]\n\n//Create entity and assign shape and material\nconst myEntity = new Entity()\nmyEntity.addComponent(plane)\nmyEntity.addComponent(myMaterial)\n\n\nThe following example includes a function that simplifies the setting of uvs. The setUVs function defined here receives a number of rows and columns as parameters, and sets the uvs so that the texture image is repeated a specific number of times.\n\nconst myMaterial = new BasicMaterial()\nlet myTexture = new Texture(\"materials/atlas.png\", { wrap: 1, samplingMode: 0})\nmyMaterial.texture = myTexture\n\nconst myPlane = new Entity()\nconst plane = new PlaneShape()\nmyPlane.addComponent(plane)\n\nengine.addEntity(myPlane)\nmyPlane.addComponent(myMaterial)\nplane.uvs = setUVs(3, 3)\n\nfunction setUVs(rows: number, cols: number) {\n  return [\n    // North side of unrortated plane\n    0, //lower-left corner\n    0,\n\n    cols, //lower-right corner\n    0,\n\n    cols, //upper-right corner\n    rows,\n\n    0, //upper left-corner\n    rows,\n\n    // South side of unrortated plane\n    cols, // lower-right corner\n    0,\n\n    0, // lower-left corner\n    0,\n\n    0, // upper-left corner\n    rows,\n\n    cols, // upper-right corner\n    rows,\n  ]\n}\n\n\nFor setting the UVs for a BoxShape component, the same structure applies. Each of the 6 faces of the cube takes 4 values, one for each corner. All of these 24 values are listed as a single array.\n\nYou can also define how the texture is tiled if the mapping spans more than the dimensions of the texture image. The Texture component lets you configure the wrapping mode by setting the wrap field. The wrapping mode can be CLAMP, WRAP or MIRROR.\n\n\n  CLAMP: The texture is only displayed once in the specified size. The rest of the surface of the mesh is left transparent.\n  WRAP: The texture is repeated as many times as it fits in the mesh, using the specified size.\n  MIRROR: As in wrap, the texture is repeated as many times as it fits, but the orientation of these repetitions is mirrored.\n\n\n\n  Note: The wrap property must be set when instancing the texture, after that it’s a read-only property.\n\n\nlet myTexture = new Texture(\"materials/atlas.png\", { wrap: 2 })\n\n\nThe example above sets the wrapping mode to MIRROR.\n\n\n  Note: Uv properties are currently only available on PlaneShape and on BoxShape components.\n\n\nTexture scaling\n\nWhen textures are stretched or shrinked to a different size from the original texture image, this can sometimes create artifacts. In a 3D environment, the effects of perspective cause this naturally. There are various texture filtering algorithms that exist to compensate for this in different ways. The Texture object uses the bilinear algorithm by default, but it lets you configure it to use the nearest neighbor or trilinear algorithms instead by setting the samplingMode property.\n\nconst myTexture = new Texture(\"materials/myTexture.png\", { samplingMode: 1 })\n\n\nThe example above uses a nearest neighbor algorithm. This setting is ideal for pixel art style graphics, as the contours will remain sharply marked as the texture is seen larger on screen instead of being blurred.\n\nAvatar Portraits\n\nTo display a thumbnail image of any player, create an AvatarTexture, passing the address of an existing player. This creates a texture from a 256x256 image of the player, showing head and shoulders. The player is displayed wearing the set of wearables that the current server last recorded.\n\nlet myTexture = new AvatarTexture(\"0xAAAAAAAAAAAAAAAAA\")\nconst myMaterial = new Material()\nmyMaterial.albedoTexture = myTexture\n\n\nTransparent materials\n\nTo make a material with a plain color transparent, simply define the color as a Color4, and set the 4th value to something between 0 and 1. The closer to 1, the more opaque it will be.\n\nlet transparentRed = Color4(1, 0, 0, 0.5)\n\n\nTo make a material with texture transparent:\n\n\n  Set an image in alphaTexture.\n\n\n\n  Note: This must be a single-channel image. In this image use the color red to determine what parts of the real texture should be transparent.\n\n\n\n  \n    Optionally set the transparencyMode to: - OPAQUE: No transparency at all - ALPHATEST: Each pixel is either completely opaque or completely transparent, based on a threshold. - ALPHABLEND: Intermediate values are possible based on the value of each pixel.\n  \n  \n    If you set the transparencyMode to ALPHATEST, you can fine tune the threshold used to determine if each pixel is transparent or not. Set the alphaTest property between 0 and 1. By default its value is 0.5.\n  \n\n\nconst myTexture = new Texture(\"materials/texture.png\")\nconst alphaTexture = new Texture(\"materials/alpha.png\")\n\n// Material with ALPHABLEND\nconst myMaterial = new Material()\nmyMaterial.albedoTexture = myTexture\nmyMaterial.alphaTexture = alphaTexture\n\n// Material with ALPHATEST\nconst myMaterial2 = new Material()\nmyMaterial2.albedoTexture = myTexture\nmyMaterial2.alphaTexture = alphaTexture\nmyMaterial.transparencyMode = 1 // ALPHATEST\nmyMaterial.alphaTest = 0.3\n\n\nCasting no shadows\n\nTo prevent a material from casting shadows over other objects, both Material and BasicMaterial have a castShadows property that you can set to false. This property is always true by default.\n\nlet noShadowMaterial = new Material()\nnoShadowMaterial.albedoColor = Color4.White()\nnoShadowMaterial.castShadows = false\n\n\nReuse materials\n\nIf multiple entities in your scene use a same material, there’s no need to create an instance of the material component for each. All entities can share one same instance, this keeps your scene lighter to load and prevents you from exceeding the maximum amount of materials per scene.\n\n//Create entities and assign shapes\nconst box = new BoxShape()\nconst myEntity = new Entity()\nmyEntity.addComponent(box)\nconst mySecondEntity = new Entity()\nmySecondEntity.addComponent(box)\nconst myThirdEntity = new Entity()\nmyThirdEntity.addComponent(box)\n\n//Create material and configure fields\nconst myMaterial = new Material()\nmyMaterial.albedoColor = Color3.Blue()\n\n//Assign same material to all entities\nmyEntity.addComponent(myMaterial)\nmySecondEntity.addComponent(myMaterial)\nmyThirdEntity.addComponent(myMaterial)\n\n\nVideo playing\n\nTo stream video from a URL into a material, or play a video from a file stored in the scene, see video playing.\n\nThe video is used as a texture on a material, you can set any of the other properties of materials to alter how the video screen looks."
        }
        
      
    
  
    
      
        ,
        
        "development-guide-second-layer": {
          "id": "development-guide-second-layer",
          "title": "Second Layer Blockchain",
          "categories": "development-guide",
          "url": " /development-guide/second-layer/",
          "content": "About second layer solutions\n\nAny transaction that affects the blockchain takes time to complete, and costs gas. Both these things are obstacles to making blockchain gaming popular, because players usually don’t have the patience to wait that long for their actions to take effect, and aren’t willing to spend money on many transactions as they play.\n\nA common workaround is to keep most of the game-play off-chain, and only carry out blockchain transactions for key events, like earning a game item or registering a high score.\n\nHowever, another way to overcome these limitations, as well as other scalability issues that are inherent to blockchains, is to rely on a second layer blockchain, also called a side-chain.\n\nA second layer is another blockchain that sits as an intermediary between a decentralized app and the main chain. This layer is more lightweight and can therefore provide faster responses and at a much lower gas cost.\n\nInstead of making transactions directly into the main chain, transactions are done on the side chain, and then it’s the duty of the side-chain to eventually sync these changes with the main chain.\n\nThe side-chain is able to provide faster responses because it’s a smaller network with less nodes. The transactions that are carried out in the second layer are initially less secure, but they are eventually committed to the main chain in bulks, and all of the security checks of the main chain can be enforced there.\n\nThe side-chain is also able to lower individual transaction costs significantly because it groups many transactions into a single one when syncing with the main chain. So the gas that would need to be paid for one transaction on the main chain can be divided over several thousand transactions.\n\nAlso, when syncing with the main chain, several redundant transactions can be avoided entirely, further reducing transaction costs. For example, if Alice transfers 1 ETH to Bob, and then Bob transfers 1 ETH to Carol, then those two transactions can be simplified into one, by registering that Alice transfers directly to Carol.\n\nDecentraland has a partnership with Polygon, who provide their own side-chain on Ethereum. Their side-chain can be used by scenes to support fast and very cheap transactions.\n\nAdd Polygon support to a scene\n\nTo easily make use of MANA on Polygon’s side-chain in your scene, use the l2-utils library. This library includes simple functions to allow players in your scene to make transactions with MANA on Polygon’s network, check the player’s current balance of MANA on Polygon, and transfer MANA between mainchain and Polygon.\n\nPlayers don’t need to switch networks on their browser wallets to operate on Polygon’s network, since these are handled via metatransactions.\n\nTry the Polygon Testnet\n\nIn order to use Polygon’s Matic Testnet, you should first have:\n\n\n  \n    Ether in Ropsten network. You can obtain it for free from various external faucets like this one.\n  \n  \n    MANA in Ropsten network. You can obtain it for free here MANA faucet.\n  \n\n\nThen you must configure your Metamask account to include the Matic Testnet.\n\nTo do this:\n\n\n  Switch networks on Metamask by clicking on the name of the current network and selecting Custom RPC at the bottom of the dropdown.\n  Fill in ‘Matic Testnet’ as Network name and https://rpc-mumbai.matic.today as New RPC URL and the same value as Block Explorer URL. For Symbol set MATIC\n  Click ‘Save’ to add this new network to Metamask.\n\n\n\n  Note: Learn more about how to set up Matic on their Documentation page"
        }
        
      
    
  
    
      
        ,
        
        "development-guide-display-a-certified-nft": {
          "id": "development-guide-display-a-certified-nft",
          "title": "Display an NFT in a scene",
          "categories": "development-guide",
          "url": " /development-guide/display-a-certified-nft/",
          "content": "You can display a 2D NFT (Non-Fungible Token) that you own in your Decentraland scenes.\n\nThe NTF’s image and other data is taken from an API, based on the token’s contract and id. Any NFTs that are supported on OpenSea can also be displayed in an NFT picture frame in Decentraland.\n\nThe picture frame is displayed adjusting to the dimensions of the NFT image. If the image’s dimensions are 512 X 512 pixels, the frame keeps its original size. If the image has different dimensions, the frame will be resized and stretched to match these dimensions.\n\n\n  Tip: If you want to stretch or resize the image from what’s generated by default, you can change the scale property in the entity’s Transform component.\n\n\nAdd an NFT\n\nAdd an NFTShape component to an entity to display a 2D token in your scene.\n\nconst entity = new Entity()\nconst shapeComponent = new NFTShape(\n  \"ethereum://0x06012c8cf97BEaD5deAe237070F9587f8E7A266d/558536\"\n)\nentity.addComponent(shapeComponent)\nentity.addComponent(\n  new Transform({\n    position: new Vector3(4, 1.5, 4),\n  })\n)\nengine.addEntity(entity)\n\n\nThe NFTShape component must be instanced with a parameter that includes the following:\n\n\n  The contract of the token (for example, the CryptoKitties contract)\n  The id of the specific token you own\n\n\nThe example above fetches an NFT with the contract address 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d, and the specific identifier 558536. The corresponding asset asset can be found in OpenSea at https://opensea.io/assets/0x06012c8cf97BEaD5deAe237070F9587f8E7A266d/558536.\n\nCustomize the frame\n\nBy default, the image will have a purple background and have a frame with a pulsating emissive texture around it. You can set the following properties to better match the style of the NFT and the scene:\n\n\n  color: Determines the back side of the model, and also the background of the image in case the NFT image has transparency.\n  style: Selects a frame model from an enum of several predetermined options.\n\n\nconst shapeComponent = new NFTShape(\n  \"ethereum://0x06012c8cf97BEaD5deAe237070F9587f8E7A266d/558536\",\n  {\n    color: Color3.Green(),\n    style: PictureFrameStyle.Gold_Edges,\n  }\n)\n\n\n\n\nHere’s the full list of supported frame styles:\n\n\n  Classic\n  Baroque_Ornament\n  Diamond_Ornament\n  Minimal_Wide\n  Minimal_Grey\n  Blocky\n  Gold_Edges\n  Gold_Carved\n  Gold_Wide\n  Gold_Rounded\n  Metal_Medium\n  Metal_Wide\n  Metal_Slim\n  Metal_Rounded\n  Pins\n  Minimal_Black\n  Minimal_White\n  Tape\n  Wood_Slim\n  Wood_Wide\n  Wood_Twigs\n  Canvas\n  None\n\n\n\n  Tip: Using Visual Studio Code (or another IDE), see the whole list by typing PictureFrameStyle. and waiting for the smart suggestions display the list of options. Use PictureFrameStyle.Noneto display the plain NFT as is, with no frame or background color.\n\n\nOpen an NFT UI\n\nOpen a prebuilt UI that displays the name, owner, and description of an NFT. It also includes the NFT’s current price and price of last sale if applicable, and a button that links to the NFT’s page on OpenSea, where more information is available and it can be purchased.\n\n\n\nOpen this UI by calling the function `openNFTDialog(), passing it the NFT’s contract and id, just like with the NFT shape. The UI must be opened as a result of a button event, to prevent abusive spamming. The button event doesn’t necessarily need to be on the same picture frame or on an NFTShape.\n\nTo open this UI, add the following:\n\nmyPictureFrame.addComponent(\n  new OnPointerDown((e) =&gt; {\n    openNFTDialog(\n      \"ethereum://0x06012c8cf97BEaD5deAe237070F9587f8E7A266d/558536\"\n    )\n  })\n)\n\n\nThe UI will include the description that’s available on the NFT, you can also include additional custom text to the UI. To add custom text, simply include the text as a second argument on the openNFTDialog() function.\n\nmyPictureFrame.addComponent(\n  new OnPointerDown((e) =&gt; {\n    openNFTDialog(\n      \"ethereum://0x06012c8cf97BEaD5deAe237070F9587f8E7A266d/558536\",\n      \"This NFT is mine and I'm really proud of owning it.\"\n    )\n  })\n)"
        }
        
      
    
  
    
      
        ,
        
        "development-guide-shape-components": {
          "id": "development-guide-shape-components",
          "title": "Shape components",
          "categories": "development-guide",
          "url": " /development-guide/shape-components/",
          "content": "Three dimensional scenes in Decentraland are based on the Entity-Component model, where everything in a scene is an entity, and each entity can include components that shape its characteristics and functionality.\n\nThe rendered shape of an entity is determined by what component it uses. Each entity can have only one shape component assigned to it.\n\n\n\nPrimitive shapes\n\nSeveral basic shapes, often called primitives, can be added to an entity.\n\nThe following primitive shape components are available:\n\n\n  BoxShape\n  SphereShape\n  PlaneShape\n  CylinderShape\n  ConeShape\n\n\nEach of these components has certain fields that are specific to that shape, for example the cylinder shape has arc, radiusTop, radiusBottom, etc.\n\nTo apply a component to an entity, you can instance a new component and assign it all in one operation:\n\nmyEntity.addComponent(new SphereShape())\n\n\nOr you can first create the component instance and then assign it to the entity.\n\nlet sphere = new SphereShape()\nmyEntity.addComponent(sphere)\n\n\nPrimitive shapes don’t include materials. To give it a color or a texture, you must assign a material component to the same entity.\n\n3D models\n\nFor more complex shapes, you can build a 3D model in an external tool like Blender and then import them in .glTF or .glb (binary .glTF). glTF (GL Transmission Format) is an open project by Khronos providing a common, extensible format for 3D assets that is both efficient and highly interoperable with modern web technologies.\n\nTo add an external model into a scene, add a GLTFShape component to an entity and set its src to the path of the glTF file containing the model.\n\nmyEntity.addComponent(new GLTFShape(\"models/House.gltf\"))\n\n\nSince the src field is required, you must give it a value when constructing the component.\n\nIn the example above, the model is located in a models folder at root level of the scene project folder.\n\n\n  Tip: We recommend keeping your models separate in a /models folder inside your scene.\n\n\nglTF models can include their own embedded textures, materials, colliders and animations. See 3D models for more information on this.\n\nKeep in mind that all models, their shaders and their textures must be within the parameters of the scene limitations.\n\nFree libraries for 3D models\n\nInstead of building your own 3d models, you can also download them from several free or paid libraries.\n\nTo get you started, below is a list of libraries that have free or relatively inexpensive content:\n\n\n  Assets from the Builder\n  Google Poly\n  SketchFab\n  Clara.io\n  Archive3D\n  SketchUp 3D Warehouse\n  Thingiverse (3D models made primarily for 3D printing, but adaptable to Virtual Worlds)\n  ShareCG\n  CGTrader\n\n\n\n  Note: Pay attention to the license restrictions that the content you download has.\n\n\nNote that in several of these sites, you can choose what format to download the model in. Always choose .glTF format if available. If not available, you must convert them to glTF before you can use them in a scene. For that, we recommend importing them into Blender.\n\nCollisions\n\nEntities that have collisions enabled occupy space and block a player’s path, entities without collisions can be walked through by a player`s avatar.\n\nCollision settings currently don’t affect how other entities interact with each other, entities can always overlap. Collision settings only affect how the entity interacts with the player’s avatar.\n\nDecentraland currently doesn’t have a physics engine, so if you want entities to fall, crash or bounce, you must code this behavior into the scene.\n\nEntities don’t use collisions by default. Depending on the type of the shape component it has, collisions are enabled as follows:\n\n\n  \n    For primitive shapes (boxes, spheres, planes etc), you enable collisions by setting the withCollisions field of the shape component to true.\n\n    This example defines a box entity that can’t be walked through.\n\n    let box = new BoxShape()\nbox.withCollisions = true\nmyEntity.addComponent(box)\n    \n\n    \n      Note: Planes only block movement in one direction.\n    \n  \n  \n    To use collisions in a glTF shape, you can either:\n\n    \n      Overlay an invisible entity with a primitive shape and the withCollisions field set to true.\n      Edit the model in an external tool like Blender to include a collider object. The collider must be named x_collider, where x is the name of the model. So for a model named house, the collider must be named house_collider.\n    \n  \n\n\nA collider is a set of geometric shapes or planes that define which parts of the model are collided with. This allows for much greater control and is a lot less demanding on the system, as the collision object is usually a lot simpler (with less vertices) than the original model.\n\nSee 3D models for more details on how to add colliders to a 3D model.\n\nPointer blocking\n\nAll shapes block player button events by default, so that for example a player can’t click through a wall, or pick something up that is locked inside a chest.\n\nYou can however disable this behavior on any shape, no matter if it’s a primitive or an imported 3D model.\n\nTo do so, set the isPointerBlocker property of the shape component to false.\n\nlet box = new BoxShape()\nbox.isPointerBlocker = false\nmyEntity.addComponent(box)\n\n\nBy using this property, you could for example have an invisible wall that players can’t walk through, but that does allow them to click on items on the other side of the wall.\n\nMake invisible\n\nYou can make an entity invisible by setting the visible field in its shape component. Doing this is especially useful when using the shape as a collider.\n\nAll components for primitive shape and 3D models are visible by default.\n\nconst myEntity = new Entity()\nmyEntity.addComponent(new BoxShape())\nmyEntity.getComponent(BoxShape).visible = false\n\n\nIf an entity is invisible, its collider can block a player’s path, but it can’t be clicked. To make an entity that’s both invisible and clickable, keep the visible property set to true, and instead give it a material with 100% transparency.\n\nOptimize 3D models\n\nTo ensure that 3D models in your scene load faster and take up less memory, follow these best practices:\n\n\n  Save your models in .glb format, which is a lighter version of .gltf.\n  If you have multiple models that share the same textures, export your models with textures in a separate file. That way multiple models can refer to a single texture file that only needs to be loaded once.\n  If you have multiple entities using the same 3D model, instance a single GLTFShape component and assign that same one to the entities that will use it.\n  If your scene has entities that appear and disappear, it might be a good idea to pool these entities and keep them already defined but removed from the engine until needed. This will help them appear faster, the trade-off is that they will occupy memory when not in use. See entities and components\n\n\nReuse shapes\n\nIf multiple entities in your scene use a same primitive or 3D model, there’s no need to create an instance of the shape component for each. All entities can share one same instance.\n\nThis keeps your scene lighter to load and prevents you from exceeding the maximum amount of bodies per scene.\n\n\n  Note: Reused shapes are added to the triangle count of the scene. So it is possible to exceed the triangle limit by reusing shapes.\n\n\n// Create shape component\nconst house = new GLTFShape(\"models/House.gltf\")\n\n// Create entities\nconst myEntity = new Entity()\nconst mySecondEntity = new Entity()\nconst myThirdEntity = new Entity()\n\n// Assign shape component to entities\nmyEntity.addComponent(house)\nmySecondEntity.addComponent(house)\nmyThirdEntity.addComponent(house)\n\n\nEach entity that shares a shape can apply different scales, rotations or even materials (in the case of primitives) without affecting how the other entities are being rendered.\n\nEntities that share a 3D model instance can also have animations that run independently of each other. Each must have a separate Animator component, with separate AnimationState objects to keep track of what part of the animation is currently being played. See 3D model animations"
        }
        
      
    
  
    
      
        ,
        
        "development-guide-entity-positioning": {
          "id": "development-guide-entity-positioning",
          "title": "Set Entity positions",
          "categories": "development-guide",
          "url": " /development-guide/entity-positioning/",
          "content": "You can set the position, rotation and scale of an entity by using the Transform component. This can be used on any entity, which can also a primitive shape component (cube, sphere, plane, etc) or a 3D model component (GLTFShape).\n\n\n\n// Create a new entity\nconst ball = new Entity()\n\n// Add a transform component to the entity\nball.addComponent(new Transform())\nball.getComponent(Transform).position.set(5, 1, 5)\nball.getComponent(Transform).scale.set(2, 2, 2)\n\n\nFor brevity, you can also create a Transform entity and give it initial values in a single statement, passing it an object that can optionally include position, rotation and scale properties.\n\nmyEntity.addComponent(\n  new Transform({\n    position: new Vector3(5, 1, 5),\n    rotation: new Quaternion(0, 0, 0, 0),\n    scale: new Vector3(2, 2, 2),\n  })\n)\n\n\nTo move, rotate or resize an entity in your scene, change the values on this component incrementally, frame by frame. See Move entities for more details and best practices. You can also use the helper functions in the utils library to achieve this more easily.\n\nPosition\n\nposition is a 3D vector, it sets the position of the entity’s center on all three axes, stored as a Vector3 object.\n\n// Create transform with a predefined position\nlet myTransform = new Transform({ position: new Vector3(1, 0, 1) })\n\n// Set each axis individually\nmyTransform.position.x = 3\nmyTransform.position.y = 1\nmyTransform.position.z = 3\n\n// Set the position with three numbers (x, y, z)\nmyTransform.position.set(3, 1, 3)\n\n// Set the position with an object\nmyTransform.position = new Vector3(5, 1, 5)\n\n\n\n  Note: When setting the value of the position with an object, you can either use a Vector3 object, or any other object with x, y and z fields.\n\n\nWhen setting a position, keep the following considerations in mind:\n\n\n  \n    The numbers in a position vector represent meters (unless the entity is a child of a scaled entity).\n  \n  \n    A scene that is made up of a single parcel measures 16m x 16m. The center of the scene (at ground level) is at x:8, y:0, z:8. If the scene is made up of multiple parcels, then the center will vary depending on their arrangement.\n  \n  \n    x:0, y:0, z:0 refers to the South-West corner of the scene’s base parcel, at ground level.\n\n    \n      Tip: When viewing a scene preview, a compass appears in the (0,0,0) point of the scene with labels for each axis as reference.\n    \n\n    \n      Tip: Take your left hand, your index finger (pointing forward) is the z axis, your middle finger (pointing sideways) is the x axis, and your thumb (pointing up) is the y axis.\n    \n\n    \n      Note: You can change the base parcel of a scene by editing the base attribute of scene.json.\n    \n  \n  \n    If an entity is a child of another, then x:0, y:0, z:0 refers to the center of its parent entity, wherever it is in the scene.\n  \n  \n    Every entity in your scene must be positioned within the bounds of the parcels it occupies at all times. If an entity leaves these boundaries, it will raise an error.\n\n    \n      Tip: When viewing a scene in preview mode, entities that are out of bounds are highlighted in red.\n    \n  \n  \n    Your scene is also limited in height. The more parcels that make up the scene, the higher you’re allowed to build. See scene limitations for more details.\n  \n\n\nRotation\n\nrotation is stored as a quaternion, a system of four numbers, x, y, z and w.\n\n// Create transform with a predefined rotation in Quaternions\nlet myTransform = new Transform({ rotation: new Quaternion(0, 0, 0, 1) })\n\n// Set rotation with four numbers (x, y, z, w)\nmyTransform.rotation.set(0, 0, 1, 0)\n\n// Set rotation with a quaternion\nmyTransform.rotation = new Quaternion(1, 0, 0, 0)\n\n\nYou can also set the rotation field with Euler angles, the more common x, y and z notation with numbers that go from 0 to 360 that most people are familiar with. To use Euler angles, use one of the following notations:\n\n// Create transform with a predefined rotation in Euler angles\nlet myTransform = new Transform({ rotation: Quaternion.Euler(0, 90, 0) })\n\n// Use the .setEuler() function\nmyTransform.rotation.setEuler(0, 90, 180)\n\n// Set the `eulerAngles` field\nmyTransform.rotation.eulerAngles = new Vector3(0, 90, 0)\n\n\nWhen using a 3D vector to represent Euler angles, x, y and z represent the rotation in that axis, measured in degrees. A full turn requires 360 degrees.\n\n\n  Note: If you set the rotation using Euler angles, the rotation value is still stored internally as a quaternion.\n\n\nWhen you retrieve the rotation of an entity, it returns a quaternion by default. To obtain the rotation expressed as in Euler angles, get the .eulerAngles field:\n\nmyEntity.getComponent(Transform).rotation.eulerAngles\n\n\nAdd Rotations\n\nAnother option is to perform a rotate operation on an existing transform, which adds to its current rotation. The rotate operation takes a vector that indicates a direction, and a number of degrees to rotate. In the following example, we’re tilting an entity 15 degrees along the X axis, which adds to whatever rotation it initially had:\n\nmyTransform.rotate(new Vector3(1, 0, 0), 15)\n\n\nThe rotate operation is useful when dealing with an entity that’s rotated in multiple axis, for example both X and Y. The following example sets an original rotation in the Y axis, and then rotates the Transform along the X axis:\n\nmyTransform.rotation.setEuler(0, 90, 0)\nmyTransform.rotate(new Vector3(1, 0, 0), 15)\n\n\nNote that this produces a different result than if you simply set the initial rotation to (15, 90, 0). In the example, the rotation along the X axis doesn’t occur along the original X axis of the Transform, but instead it occurs along the tilted X axis that results from the initial rotation.\n\nFace the player\n\nAdd a Billboard component to an entity so that it always rotates to face the player.\n\nBillboards were a common technique used in 3D games of the 90s, where most entities were 2D planes that always faced the player. The same idea can also be used to rotate a 3D model.\n\nlet box = new Entity()\nbox.addComponent(new BoxShape())\nbox.addComponent(\n  new Transform({\n    position: new Vector3(5, 1, 5),\n  })\n)\nbox.addComponent(new Billboard())\nengine.addEntity(box)\n\n\nYou can choose which axis to rotate as a billboard. For example, if the Billboard of a cube only rotates in the Y axis, it will follow the player when moving at ground level, but the player will be able to look at it from above or from below.\n\nThe three optional parameters when creating a Billboard component are booleans that refer to the x, y, and z axis. They are all true by default.\n\n// rotate on all three axis\nlet FullBillboard = new Billboard())\n\n// rotate only in the X axis\nlet XBillboard = new Billboard(true, false ,false)\n\n// rotate only in theY axis\nlet YBillboard = new Billboard(false, true ,false)\n\n// rotate only in the Z axis\nlet ZBillboard = new Billboard(false, false ,true)\n\n\nTip: To rotate an entity so that it follows the player around while at ground level, give it Y axis rotation.\n\nBillboards are also very handy to add to text entities, since it makes them always legible.\n\nThe rotation value of the entity’s Transform component doesn’t change as the billboard follows players around.\n\nIf an entity has both a Billboard component and Transform component with rotation values, players will see the entity rotating as a billboard. If the billboard doesn’t affect all axis, the remaining axis will be rotated according to the Transform component.\n\n\n  Note: If there are multiple players present at the same time, each will see the entities with billboard mode facing them.\n\n\nFace a set of coordinates\n\nYou can use lookAt() on the Transform component to orient an entity fo face a specific point in space by simply passing it that point’s coordinates. This is a way to avoid dealing with the math for calculating the necessary angles.\n\n// Create a transform\nlet myTransform = new Transform()\n\n// Rotate to face the coordinates (4, 1, 2)\nmyTransform.lookAt(new Vector3(4, 1, 2))\n\n\nThis field requires a Vector3 object as a value, or any object with x, y and z attributes. This vector indicates the coordinates of the position of the point in the scene to look at.\n\nThe lookAt() function has a second optional argument that sets the global direction for up to use as reference. For most cases, you won’t need to set this field.\n\nScale\n\nscale is also a 3D vector, stored as a Vector3 object, including the scale factor on the x, y and z axis. The shape of the entity scaled accordingly, whether it’s a primitive or a 3D model.\n\nYou can either use the set() operation to provide a value for each of the three axis, or use setAll() to provide a single number and maintain the entity’s proportions as you scale it.\n\nThe default scale is 1, so assign a value larger to 1 to stretch an entity or smaller than 1 to shrink it.\n\nYou can either set each dimension individually, or use the set operation to set all dimensions.\n\n// Create a transform with a predefined scale\nlet myTransform = new Transform({ scale: new Vector3(2, 2, 2) })\n\n// Set each dimension individually\nmyTransform.scale.x = 1\nmyTransform.scale.y = 5\nmyTransform.scale.z = 1\n\n// Set the whole scale with one expression  (x, y, z)\nmyTransform.scale.set(1, 5, 1)\n\n// Set the scale with a single number to maintain proportions\nmyTransform.scale.setAll(2)\n\n// Set the scale with an object\nmyTransform.scale = new Vector3(1, 1, 1.5)\n\n\nWhen setting the value of the scale with an object, you can either use a Vector3 object, or any other object with x, y and z fields.\n\nInherit transformations from parent\n\nWhen an entity is nested inside another, the child entities inherit components from the parents. This means that if a parent entity is positioned, scaled or rotated, its children are also affected. The position, rotation and scale values of children entities don’t override those of the parents, instead these are compounded.\n\nIf a parent entity is scaled, all position values of its children are also scaled.\n\n// Create entities\nconst parentEntity = new Entity()\nconst childEntity = new Entity()\n\n// Set one as the parent of the other\nchildEntity.setParent(parentEntity)\n\n// Create a transform for the parent\nlet parentTransform = new Transform({\n  position: new Vector3(3, 1, 1),\n  scale: new Vecot3(0.5, 0.5, 0.5),\n})\n\nparentEntity.addComponent(parentTransform)\n\n// Create a transform for the child\nlet childTransform = new Transform({\n  position: new Vector3(0, 1, 0),\n})\n\nchildEntity.addComponent(childTransform)\n\n// Add entities to the engine\nengine.addEntity(parentEntity)\n\n\nYou can use an invisible entity with no shape component to wrap a set of other entities. This entity won’t be visible in the rendered scene, but can be used to group its children and apply a transform to all of them.\n\n\n  Note: Child entities should not be explicitly added to the engine, as they are already added via their parent entity.\n\n\nAttach an entity to an avatar\n\nTo fix an entity’s position to an avatar, add an AttachToAvatar component to the entity.\n\n\n\nthis.addComponentOrReplace(\n  new AttachToAvatar({\n    avatarId: '0xAAAAAAAAAAAAAAAAA',\n    anchorPointId: AttachToAvatarAnchorPointId.NameTag,\n  })\n)\n\n\nWhen creating an AttachToAvatar component, you must pass an object with the following data:\n\n\n  avatarId: The ID of the player to attach to. This is the same as the player’s Ethereum address, for those players connected with an Ethereum wallet.\n  anchorPointId: What anchor point on the avatar to attach the entity.\n\n\nThe following anchor points are available on the player:\n\n\n  \n    NameTag: Floats right above the player’s name tag, isn’t affected by the player’s animations.\n\n    \n      Note: The name tag height is dynamically adjusted based on the height of the wearables a player has on. So a player wearing a tall hat will have their name tag a little bit higher than others.\n    \n  \n  \n    Position: The player’s overall position.\n\n    \n      Note: The height of this anchor point currently may vary between the local player’s avatar and other players, this is subject to change in future versions. The NameTag anchor point should be more reliable.\n    \n  \n\n\n\n\n\n  Note: Future SDK versions will include alternative anchor points on the avatar that will accompany the avatar animations.\n\n\nEntity rendering is locally determined on each instance of the scene. Attaching an entity on one player doesn’t make it visible to everyone seeing that player.\n\n\n  Note: Entities attached to an avatar must stay within scene bounds to be rendered. If a player walks out of your scene, any attached entities stop being rendered until the player walks back in. Smart wearables don’t have this limitation.\n\n\nThe AttachToAvatar component overwrites the Transform component, a single entity can’t have both an AttachToAvatar and a Transform component at the same time.\n\nIf you need to position an entity with an offset from the anchor point on the avatar, or a different rotation or scale, attach a parent entity to the anchor point. You can then set the visible model on a child entity to that parent, and give this child its own Transform component to describe its shifts from the anchor point.\n\nlet parent = new Entity()\n\nparent.addComponentOrReplace(\n  new AttachToAvatar({\n    avatarId: '0xAAAAAAAAAAAAAAAAA',\n    anchorPointId: AttachToAvatarAnchorPointId.NameTag,\n  })\n)\nengine.addEntity(parent)\n\nlet child = new Entity()\nchild.addComponent(new ConeShape())\nchild.addComponent(\n  new Transform({\n    rotation: Quaternion.Euler(0, 0, 180),\n    scale: new Vector3(0.2, 0.2, 0.2),\n    position: new Vector3(0, 0.4, 0),\n  })\n)\nchild.setParent(parent)\n\n\nObtain the avatarId\n\nTo attach an entity to an avatar, you must provide the user’s ID in the field avatarId. There are various ways to obtain this data.\n\n\n  Note: For those players connected with an Ethereum wallet, their userId is the same as their Ethereum address.\n\n\n\n  Fetch the local player’s userId via getUserData().\n\n\nimport { getPlayerData } from \"@decentraland/Players\"\n\nexecuteTask(async () =&gt; {\n  let data = await getUserData()\n  log(data.userId)\n})\n\n\n\n  Fetch the userId for all other nearby players via getConnectedPlayers()\n\n\nimport { getConnectedPlayers } from \"@decentraland/Players\"\n\nexecuteTask(async () =&gt; {\n  let players = await getConnectedPlayers()\n  players.forEach((player) =&gt; {\n    log(\"player is nearby: \", player.userId)\n  })\n})\n\n\nSee other ways to fetch other user’s IDs in Get Player Data.\n\nAttach to player using Attachable (deprecated)\n\nNote: This method for attaching entities to the player is deprecated. Use the AttachToAvatar component instead.\n\nSet an entity as a child of the Attachable.FIRST_PERSON_CAMERA object to fix the entity to the player and follow the player’s movements.\n\nconst followTheCamera = new Entity()\nfollowTheCamera.addComponent(new BoxShape())\nfollowTheCamera.addComponent(\n  new Transform({\n    position: new Vector3(0, 0.5, 3),\n  })\n)\nengine.addEntity(followTheCamera)\nfollowTheCamera.setParent(Attachable.FIRST_PERSON_CAMERA)\n\n\nIf the attached entity has a Transform component, it will be positioned relative to the player’s position, and keep that relative position as the player moves or rotates.\n\nTo fix an entity’s rotation only in the x axis to the player, set an entity as a child of the Attachable.AVATAR object. The entity will then rotate with the player when looking around at ground level, but it won’t accompany the player’s rotation when looking up or down.\n\nconst followAvatar = new Entity()\nfollowAvatar.addComponent(new BoxShape())\nfollowAvatar.addComponent(\n  new Transform({\n    position: new Vector3(0, 0.5, 3),\n  })\n)\nengine.addEntity(followAvatar)\nfollowAvatar.setParent(Attachable.AVATAR)\n\n\n\n  Note: To set an entity as a child of Attachable.FIRST_PERSON_CAMERA or Attachable.AVATAR, you need to first add the entity to the engine. If you attempt to set the entity as child of the player before adding it to the engine, it will raise an error.\n\n\nBoth Attachable.FIRST_PERSON_CAMERA and Attachable.AVATAR behave similarly, but have subtle differences:\n\nWith Attachable.FIRST_PERSON_CAMERA:\n\n\n  The entity is at eye-level of the player\n  In 1st person: Entity rotates on all axis, staying in a fixed position on the camera.\n  In 3rd person: Entity rotates on only the y axis with the camera\n\n\nWith Attachable.AVATAR:\n\n\n  The entity is arm or waist level of the player\n  1st person: Entity rotates on only the y axis with the camera\n  3rd person: Entity rotates on only the y axis with the camera\n\n\nThis gif illustrates the difference in 1st person. The pink entity uses Attachable.AVATAR, the white object uses Attachable.FIRST_PERSON_CAMERA.\n\n\n\nIf several players are in the same scene, they will each experience the entity as attached to themselves. They will not see the entity attached to other players.\n\nFor example, in a multiplayer scene where players can pick up boxes and move them around, the recommended approach is to make boxes that are being carried by other players invisible. So that only players that are currently carrying a box see them attached to themselves.\n\nScene boundaries\n\nAll entities in your scene must fit within the scene boundaries, as what’s outside those boundaries is parcels of land that are owned by other players.\n\nWhen running a preview of your scene, any entities outside the scene’s parcels are colored red and their colliders are removed. When deployed to Decentraland, any entities outside the parcels will not be rendered at all by the engine.\n\nThe position of entities in your scene is constantly being checked as they move, if an entity leaves the scene and then returns it will be removed and then rendered normally again.\n\nA grid on the scene’s ground shows the limits of the scene, which by default rage from 0 to 16 on the x and z axis, and up to 20 on the y axis. You’re free to place entities underground, below 0 on the y axis.\n\n\n  Tip: If your scene needs more parcels, you can add them in the project’s scene.json file. See Scene metadata for instructions. Once added, you should see the grid extend to cover the additional parcels.\n\n\nIt’s important to note that the entire 3D model must be within the scene’s bounds. This includes the model’s bounding box. Some 3D models may have bounding boxes that unnecessarily extend beyond the meshes themselves, and it can sometimes be tricky to tell when this happens. When an entity extends beyond the scene’s boundaries, in the preview you’ll see a cube that marks these bounding boxes. The entire cube must fit within your scene.\n\n\n\nIf an entity’s cube extends beyond the shape of its meshes, you might need to edit the 3D model in an external editor to reduce these margins, or to bake the rotation and scale of the meshes in the model."
        }
        
      
    
  
    
      
        ,
        
        "development-guide-component-groups": {
          "id": "development-guide-component-groups",
          "title": "Component groups",
          "categories": "development-guide",
          "url": " /development-guide/component-groups/",
          "content": "Each component group keeps track of a list of entities that have all the required components.\n\n\n\nThe engine automatically updates this list every time that:\n\n\n  A new entity is added to the engine\n  An entity is removed from the engine\n  An entity in the engine adds a new component\n  An entity in the engine removes a component\n\n\n\n  Note: Only entities that are added to the engine are eligible for component groups. Entities that have been created but not added to the engine, or that have been removed from the engine, aren’t listed in any group.\n\n\nAfter the group is created, you don’t need to add or remove entities manually from it, the engine takes care of that.\n\nconst myGroup = engine.getComponentGroup(Transform)\n\n\nSystems typically iterate over the entities in these groups in their update method, performing the same operations on each. Having a predefined group of valid entities is a great way to save resources, specially for functions that run on every frame like update(). If on every frame your system would have to iterate over every single entity in the scene looking for the ones it needs, that would be very time consuming.\n\nYou can access the entities in a component group in the following way: if the group name is myGroup, calling myGroup.entities returns an array containing all the entities in it.\n\nconst myGroup = engine.getComponentGroup(Transform)\n\nfor (let entity of myGroup.entities) {\n  log(entity.uuid)\n}\n\n\n\n  Note: Keep in mind that component groups take up space in the local memory of the player’s machine. Usually, the benefit in speed you get from having a group is a tradeoff that is well worth it. However, for cases where you’d have a large group that you don’t access all that often, it might be better to not have one.\n\n\nRequired components\n\nWhen creating a component group, specify what components need to be present in every entity that’s added to the group. You can list as many components as you want, the component group will only accept entities that have all of the listed components.\n\nconst myGroup = engine.getComponentGroup(Transform, Physics, NextPosition)\n\n\n\n  Tip: If your scene includes entities that have all the required components but that don’t need to be in your component group, create a custom component to act as a flag. This component doesn’t need to have any properties in it. Add this component to the entities that you want the component group to handle.\n\n\nUse component groups in a system\n\nconst myGroup = engine.getComponentGroup(Transform, Physics)\n\nexport class PhysicsSystem implements ISystem {\n  update() {\n    for (let entity of myGroup.entities) {\n      const position = entity.getComponent(Transform).Position\n      const vel = entity.getComponent(Physics).velocity\n      position.x += vel.x\n      position.y += vel.y\n      position.z += vel.z\n    }\n  }\n}\n\n\nIn the example above, PhysicsSystem iterates over the entities in myGroup as part of the update() function, that is executed on every frame of the game loop.\n\n\n  \n    If the scene has several ball entities, each with a Position and a Physics component, then they will be included in myGroup. PhysicsSystem will then update their position on every frame.\n  \n  \n    If your scene also has other entities like a hoop and a scoreBoard that only have a Physics component, then they won’t be in myGroup and won’t be affected by PhysicsSystem.\n  \n\n\n\n  Note: The engine.getComponentGroup() is an expensive function to process, it should never be used inside the update of a system, as that would create a new group on every frame. When regularly checking the entities in a group, refer to an already created group, as in the example above. Once created, compnent groups are updated as entities and components are added and removed from the engine, so there’s no need to redeclare or update these groups.\n\n\nDealing with the entities\n\nThe entities array of a component group contains elements of type IEntity, which is identical to Entity, but not recogized by Typescript as the same type. If a function expects an input of type Entity, you can simply force the argument’s type with as Entity.\n\nconst myGroup = engine.getComponentGroup(Billboard)\n\nfor (let entity of myGroup.entities) {\n  addLabel(entity as Entity)\n}\n\nfunction addLabel(entity: Entity) {\n  let label = new Entity()\n  label.setParent(entity)\n  label.addComponent(\n    new Transform({\n      position: new Vector3(0, 1, 0),\n      scale: new Vector3(0.5, 0.5, 0.5),\n    })\n  )\n  label.addComponent(new TextShape(entity.uuid))\n}\n\n\nAll entities\n\nYou can access the full list of entities that have been added to the engine, regardless of what components they have, through engine.entities.\n\nengine.entities\n\n\nChange a component group while iterating\n\nComponent groups are mutable. You shouldn’t modify the component group while you’re iterating over it, because that could have unwanted consequences.\n\nFor example, if you iterate over a component group to remove each entity from the engine, the act of removing an entity displaces the other entities in the array, which can lead to some entities being skipped.\n\nTo overcome this problem, use the following code to remove all entities from the engine:\n\nwhile (myGroup.entities.length) {\n  engine.removeEntity(myGroup.entities[0])\n}"
        }
        
      
    
  
    
      
        ,
        
        "releases-sdk-cli": {
          "id": "releases-sdk-cli",
          "title": "CLI Release notes",
          "categories": "releases, sdk",
          "url": " /releases/sdk/cli/",
          "content": "Loading..."
        }
        
      
    
  
    
      
        ,
        
        "design-experience-ux-ui-guide": {
          "id": "design-experience-ux-ui-guide",
          "title": "UX and UI guide for creators",
          "categories": "design-experience",
          "url": " /design-experience/ux-ui-guide/",
          "content": "It’s of vital importance to us that Decentraland content creators are free to make use of their creativity to its full extent. This is essential for Decentraland to become a rewarding place to explore. However, it’s also important to keep in mind that the scenes in Decentraland will be visited by a wide variety of users and we want to make the scenes accessible to all of them. Because of this, we can’t ignore the need to establish a unified design criteria, a guide that can guarantee that players will find themselves with a homogeneously intuitive and enjoyable experience, no matter what scene they’re on.\n\nIn this document we share Decentraland’s Design Values, with the objective of promoting what we consider are the best practices for designing the interface and experience for players. We hope that these criteria can serve as a starting point to build and/or improve the scenes that make up the Metaverse.\n\nDesign values\n\nAll scenes in Decentraland should be designed with these values in mind:\n\n\n  Welcoming: The player feels warmly welcome.\n  User-friendly: The UI is easy and fun to use – you should avoid reinventing the wheel\n  Easy to learn: Players find the UI familiar and intuitive. Patterns should be consistently used throughout the scene.\n  Providing guidance: The scene provides a helping hand. Text, motion, sound and graphics will lead and hint players in the right direction.\n  Reactive: Clear action-reaction to players’ input.\n  Minimalistic: Less is more. Players can focus their attention on what matters.\n  Interesting: The scene takes advantage of the things that make Decentraland unique and worthy of visiting.\n  Purposeful: Players have a strong reason to come back.\n  Enjoyable: Players enjoy how things look, sound and feel\n\n\nUser experience\n\nWhere to start?\n\nWhat is the objective of your scene? Is it to offer a beautiful landscape to contemplate and explore? Is it a museum? Is it a single player game? A competitive one? Or does it follow a linear storytelling flow?\n\nIt’s important to be well aware of this objective through every step of the design process, it should guide all of your decisions, all of which can profoundly affect the visitor’s experience.\n\nFor scenes that follow a linear flow, where each step depends on the previous, we recommend walling the scene and establishing one or multiple fixed entry points, to avoid players stumbling onto things in the wrong order. By the way, entry points are an excellent place to display a message to welcome the player and explain what their objective in the scene should be.\n\n\n    \n    In-world instructions\n\n\nIf the player’s experience in your scene isn’t meant to be linear, but you still need to provide some basic instructions to ensure they enjoy it fully, you can show instructions on a pop-up. It’s possible to display a popup on the player’s screen as soon as they enter, regardless of what direction they come from, and in that way make sure that players will always know the essentials.\n\n\n\t\n    Pop-up instructions\n\n\n\n  Note: Make sure the popup isn’t too intrusive and that it’s easy to close by clicking anywhere.\n\n\nA welcome message should communicate the following to the player:\n\n\n  The scene title\n  Welcome the player\n  End goal &amp; motivation for the player\n  Instructions/Next steps\n  (Optional) Controls. Mostly useful if your scene uses global button events. Otherwise, items themselves indicate how to use them when hovering over them.\n\n\nMotivation\n\nYou’ll likely want your visitors to keep coming back to your scene, think of ways in which you can motivate them to do so! Ask yourself “What would make a player want to return to my scene, or want to recommend it to a friend?”\n\nFor example, you can challenge them, giving them something to achieve that will be hard enough to take several attempts. You can also organize competitive multiplayer events, which are also an interesting opportunity to socialize. Make your scene a dynamic place where players feel that they enjoy spending time there!\n\nFeedback and Sound\n\nSound plays a double key role, don’t miss out on using it! On one hand it’s vital for generating immersion, many things that won’t feel real if they aren’t accompanied by sound. The other crucial thing sound is for is providing feedback to a player’s actions. If you rely only on visual cues, you can’t be certain that a player will be looking in the right direction to see the effects of their actions. Through using sound, you can ensure that they are aware that something happened. If you use visual and sound cues in combination, hearing the sound invites the player to look around for the visual cue, in case they didn’t see it.\n\nKeep in mind that some players might be playing with their sound turned off. If you’re using sound as a way to provide scene instructions or a key piece in the game mechanics, try to also provide something visual to hint in the same direction. For example, you could display text at the bottom of the UI to accompany these sounds, like subtitles in a movie.\n\nSmart items\n\nWe highly recommend that you read this blog post that shares valuable information about smart items that can aid in the usability and clarity of your scene.\n\nUser Interface\n\nThis section is aimed at helping you construct a narrative through the design of your scene that drives the player’s focus onto the elements that matter the most. Making good use of the tools described here can make their experience a lot more immersive and successful.\n\nWe can’t understate how valuable color, icons, motion and scale are for sending the right message across: everything in the scene conveys a meaning, remember that.\n\nLayout\n\nBe careful about placing your UI in screen regions that overlap with the default Decentraland UI elements. The default Decentraland UI, including minimap, chat, etc, is designed to only cover the left 25% of the screen. The rest of the screen real estate is a safe zone, free to use for content creators.\n\n\n\t\n\n\nThere are no restrictions for placing UI elements in the left 25% of the screen, but keep in mind that the explorer is continually making changes and improvements to its design. Any space that is not occluded in that region today could be covered in future versions.\n\n\n  Note: UI elements from scenes and smart wearables always appear on a layer behind the default Decentraland UI.\n\n\nAlways keep a grid in mind and use it as your main criteria when spatially organizing your UI. If you are working on a scene where a HUD is needed, you can start by putting all the consumables together (e.g. currency, food, life), and on the other side stockables such as tools or weapons. Try to be consistent about the grid metrics and padding. Make the feedback for every player action clear.\n\nColor\n\nIt’s important to choose a color palette, as this gives your scene an identity and also signals relationships and hierarchy between elements.\n\nWhen putting together a color palette, start out by selecting a main color, and optionally a secondary one. Then you should decide if you want the palette to be analogous, complementary, or triadic, etc, in relation to that main color.\n\n\n    \n    Chromatic color palette\n\n\n\n    \n    Strategies for combining colors properly\n\n\n\n  Tip: Free color palette generators we recommend: Coolors, Adobe Color CC, Colour Lovers, Color Hunt, Color by Hailpixel, Colour Code, Sip, Color Scheme Designer by Paletton, Cohesive Colors, Colr\n\n\nThe main color should be the most frequently used across your UI components. If your palette doesn’t have a secondary color, you can accent elements by combining the main color with black or white. Having a secondary color is not mandatory, but it helps emphasize and distinguish your scene UI elements. Secondary colors work best for highlights, selection controls (sliders and switches), links and headlines.\n\nRemember that each color has its own unique expressive qualities, take advantage of that to communicate messages through them. For example, red is often associated with negative connotations whilst green is associated with positive connotations.\n\n\n    \n    Using color the wrong way can be confusing\n\n\nYou can also use colors strategically to indicate state changes, for example changing the color of an element to indicate if it’s active or inactive.\n\n\n  Note: States communicate the status of UI elements. The states of an element should maintain a certain continuity, but they must have clear affordances and be easily distinguishable from other states and the surrounding layout.\n\n\n\n    \n    Using color for button states\n\n\nWarning! When selecting colors that will be shown in superposition, take special care of making sure that they are legible when used together. Here’s a fundamental rule: the colors of elements that are shown together should always have plenty of contrast between them. Be mindful that some players might be looking at their screens under suboptimal lighting conditions, which makes reading harder.\n\n\n    \n    Both icons can be distinguished, but the first one has better contrast. It becomes easier to read and requires less effort to understand.\n\n\nTypographic hierarchy\n\nTry to define at least a 3-type scale for Titles, Subtitles, and Body. Be careful with the use of color and font size. All font sizes should be 12 px or larger.\n\nIf you are going to place text that is displayed over imagery (or over the world), you will surely need to experiment with its legibility. In those cases, we suggest that you add a colored solid region, in a layer between the text and images, that way you can ensure that the text remains legible.\n\n\n    \n    Prioritize legibility\n\n\nIcons\n\nIcons synthesise information, helping you identify actions through images. They are an amazingly powerful tool for providing input that can be interpreted fast, as opposed to using text to label things, which demands more of the player’s attention and time. It’s also useful to show icons in combination with text, as this helps disambiguate their meanings.\n\n\n    \n    Use icons as a universal language\n\n\nMotion\n\nUse motion to provide feedback and lead the way when needed. Motion helps players focus their attention and helps maintain continuity as the UI changes.\n\n\n    \n    Use particles, scale, or fading margins to make things stand out\n\n\nWriting and content structure\n\nUI text can make interfaces more usable and gives players more confidence in their actions. Always make UI text as concise as possible. Players are there to play, not to read. Any text that seems too long won’t be read by most players.\n\nReceive your players with a Welcome Message and tell them the objective of the scene. Start by clarifying their goal in the scene, then the actions needed to achieve it. Then you can reveal information progressively as it’s needed, this way players won’t feel overwhelmed on the very beginning of the experience. As with graphic resources, try to use consistent words across your UI features and storytelling.\n\nSDK New Features - Coming Soon!\n\nObjects interactions\nNow it’s not possible for players to tell which objects are interactive and which aren’t, until they actually click or press buttons on them. We have been working on a new feature for creators to be able to show custom toast messages when aiming at an interactive object. This message conveys which input to use and may have custom text to describe the effects of interacting with it. We highly recommend that you use it when released, your scene will feel more natural and easy to use.\n\n3rd person camera\nWe’re currently experimenting with adding support for a 3rd person camera. You can try it out in the explorer by hitting the ‘V’ key. (Note, it’s not supported yet in a scene preview). You can start thinking of developing incredible new experiences or games that might be much more appealing thanks to a 3rd person camera!"
        }
        
      
    
  
    
      
        ,
        
        "development-guide-systems": {
          "id": "development-guide-systems",
          "title": "Systems",
          "categories": "development-guide",
          "url": " /development-guide/systems/",
          "content": "Decentraland scenes rely on systems to update the information stored in each entity’s components as the scene changes.\n\n\n\nsystems are what make scenes dynamic, they’re able to execute functions periodically on every frame of the scene’s game loop, changing what will be rendered.\n\nThe following example shows a basic system declaration:\n\n// Define the system\nexport class MoveSystem implements ISystem {\n  //Executed ths function on every frame\n  update() {\n    // Iterate over the entities in an component group\n    for (let entity of myEntityGroup.entities) {\n      let transform = entity.getComponent(Transform)\n      transform.translate(Vector3.Forward)\n    }\n  }\n}\n\n// Add system to engine\nengine.addSystem(new MoveSystem())\n\n\nIn the example above, the system MoveSystem executes the update() function of each frame of the game loop, changing position of every entity in the scene.\n\n\n  Note: You must add a System to the engine before its functions can be called.\n\n\nAll systems act upon entities, changing the values stored in the entity’s components.\n\n\n\n\n  Tip: As a simpler alternative to create custom systems, you can use the helpers in the utils library. The library creates systems in the background that handle common tasks like moving or rotating entities. In most cases, this library only requires a single line of code to apply these behaviors.\n\n\nYou can have multiple systems in your scene to decouple different behaviors, making your code cleaner and easier to scale. For example, one system might handle physics, another might make an entity move back and forth continuously, another could handle the AI of characters.\n\nMultiple systems can act on a single entity, for example a non-player character might move on its own based on its AI but also be affected by gravity when trying to walk from off a cliff.\n\nThe update method\n\nThe update() method is a boilerplate function you can extend to define the functionality of a system. It’s meant to be overwritten and interfaces with the engine in pre-established ways.\n\nThe update() method of a system is executed periodically, once per every frame of the game loop. This happens automatically, you don’t need to explicitly call this function from anywhere in your code.\n\nTypically, the update() method is where you add most of the logic implemented by the system.\n\nIn a Decentraland scene, you can think of the game loop as the aggregation of all the update() functions in your scene’s systems.\n\nLoop over a component group\n\nMost of the time, you won’t want a system’s update function to iterate over the entire set of entities in the scene, as this could be very costly in terms of processing power. To avoid this, you can create a component group to keep track of which are the relevant entities, and then have your system iterate over that list.\n\nFor example, your scene can have a PhysicsSystem that calculates the effect of gravity over the entities of your scene. Some entities in your scene, such as trees, are fixed, so it would make sense to avoid wasting energy in calculating the effects of gravity on these. You can then define a component group that keeps track of entities that aren’t fixed and then have PhysicsSystem only deal with the entities in this group.\n\n// Create component group\nconst movableEntities = engine.getComponentGroup(Physics)\n\n// Create system\nexport class PhysicsSystem implements ISystem {\n  update(dt: number) {\n    // Iterate over component group\n    for (let entity of movableEntities.entities) {\n      // Calculate effect of physics\n    }\n  }\n}\n\n\nHandle a single entity\n\nSome components and systems are meant for using only on one entity in the scene. For example, on an entity that stores a game’s score or perhaps on a gate of which there’s only one in the scene. To access one of those entities from a system, you don’t want to create a component group that holds just one single entity.\n\nIf you create the entity in the same file as you define the system, then you can simply refer to the entity or its components by name in the system’s functions.\n\nexport class UpdateScore implements ISystem {\n  update(dt: number) {\n    log(score.points)\n    // ...\n  }\n}\n\nconst game = new Entity()\nconst score = new Score()\ngame.addComponent(score)\nengine.addSystem(new UpdateScore(game))\n\n\nFor larger projects, we recommend that you keep system definitions on separate files from the instancing of entities. If you do that, then referring to the entity from the system is tougher, because you can’t just import the entity from game.ts to the module with the system.\n\nSince systems are also objects, you are free to add variables to them, and also to define a constructor function to pass values to these variables.\n\nexport class UpdateScore implements ISystem {\n  score: GameScore // the type is a custom component\n  constructor(scoreComponent) {\n    this.score = scoreComponent\n  }\n  update(dt: number) {\n    log(this.score.points)\n    // update values the score object\n  }\n}\n\n\nWhen instancing the system in the game.ts file, you must pass it a reference to the component:\n\nconst game = new Entity()\nconst score = new Score()\ngame.addComponent(score)\nengine.addSystem(new UpdateScore(game))\n\nengine.addSystem(new UpdateScore(score))\n\n\n\n  Note: You could store this data in a custom object instead of an custom component, for more simplicity.\n\n\nExecute when an entity is added\n\nonAddEntity() is another boilerplate function of every system that you can overwrite with your own code.\n\nEach time a new entity is added to the engine, this function is called once, passing the new entity as an argument.\n\nexport class mySystem implements ISystem {\n  onAddEntity(entity: Entity) {\n    // Code to run once\n  }\n}\n\n\nExecute when an entity is removed\n\nonRemoveEntity() is another boilerplate function of every system that you can overwrite with your own code.\n\nEach time an entity is removed from the engine, this function is called once, passing the removed entity as an argument.\n\nexport class mySystem implements ISystem {\n  onRemoveEntity(entity: Entity){}\n    // Code to run once\n  }\n}\n\n\nExecute when a system is activated\n\nThe activate() function is another boilerplate function that is executed once when the system is activated.\n\nexport class mySystem implements ISystem {\n  activate(){}\n    // Code to run once\n  }\n}\n\n\nThis can be useful when you have a system that must first carry out some initial steps, for example creating a set of materials of different colors that the update function of the system then switches between. The advantage of using the activate function instead of just executing these steps as soon as the scene starts, is that if your scene never uses the system, these steps won’t be executed.\n\nDelta time between frames\n\nThe update() method always receives an argument called dt of type number (representing delta time), even when this argument isn’t explicitly declared.\n\nexport class mySystem implements ISystem {\n  update(dt: number) {\n    // Update scene\n  }\n}\n\n\ndelta time represents time that it took for the last frame to be processed, in seconds.\n\nDecentraland scenes are updated by default at 30 frames per second. This means that the dt argument passed to all update() methods is generally equal to 30/1000.\n\nIf the processing of a frame takes less time than this interval, then the engine will wait the remaining time to keep updates regularly paced and dt will remain equal to 30/1000.\n\n\n\nIf the processing of a frame takes longer than 30/1000 seconds, the drawing of that frame is delayed. The engine then tries to finish that frame and show it as soon as possible. It then proceeds to the next frame and tries to show it 30/1000 seconds after the last frame. It doesn’t compensate for the previous delay.\n\n\n\nIdeally, you should try to avoid having your scene reach this situation, as it causes a drop in framerate.\n\nThe dt variable becomes useful when frame processing exceeds the default time. Assuming that the current frame will take as much time as the previous, this information may be used to calculate how much to adjust change so that it remains steady and in proportion to the lag between frames.\n\nSee entity positioning for examples of how to use dt to make movement smoother.\n\nLoop at a timed interval\n\nIf you want a system to execute something at a regular time interval, you can do this by combining the dt argument with a timer.\n\nlet timer: number = 10\n\nexport class LoopSystem {\n  update(dt: number) {\n    if (timer &gt; 0) {\n      timer -= dt\n    } else {\n      timer = 10\n      // DO SOMETHING\n    }\n  }\n}\n\n\nFor more complex use cases, where there may be multiple loops being created dynamically, it’s worth creating a component to store the timer.\n\n// define custom component\n@Component(\"timer\")\nexport class Timer {\n  totalTime: number\n  timeLeft: number\n  constructor(time: number) {\n    this.totalTime = time\n    this.timeLeft = time\n  }\n}\n\n// component group to list all entities with a Timer component\nexport const timers = engine.getComponentGroup(Timer)\n\n// system to update all timers\nexport class LoopSystem {\n  update(dt: number) {\n    for (let timerEntity of timers.entities) {\n      let timer = ent.getComponent(Timer)\n      if (timer.timeLeft &gt; 0) {\n        timer.timeLeft -= dt\n      } else {\n        timer.timeLeft = timer.totalTime\n        // DO SOMETHING\n      }\n    }\n  }\n}\n\n\nSystem execution order\n\nIn some cases, when you have multiple systems running update() functions, you might care about what system is executed first by your scene.\n\nFor example, you might have a physics system that updates the position of entities in the scene, and another boundaries system that ensures that none of the entities are positioned outside the scene boundaries. In this case, you want to make sure that the boundaries system is executed last. Otherwise, the physics system could move entities outside the bounds of the scene but the boundaries system won’t find out till it’s executed again in the next frame.\n\nWhen adding a system to the engine, set an optional priority field to determine when the system is executed in relation to other systems.\n\nengine.addSystem(new PhysicsSystem(), 1)\nengine.addSystem(new BoundariesSystem(), 5)\n\n\nSystems with a lower priority number are executed first, so a system with a priority of 1 is executed before one of priority 5.\n\nSystems that aren’t given an explicit priority have a default priority of 0, so these are executed first.\n\nIf two systems have the same priority number, there’s no way to know for certain which of them will be executed first.\n\nRemove a system\n\nAn instance of a system can be added or removed from the engine to turn it on or off.\n\nIf a system isn’t added to the engine, its functions aren’t called by the engine.\n\nTo remove a system, you must first create a pointer to it when instancing it, so that you can refer to the system later.\n\n// add system\nlet mySystemInstance = new mySystem()\nengine.addSystemmySystemInstance\n\n// remove system\nengine.removeSystem(mySystemInstance)"
        }
        
      
    
  
    
      
        ,
        
        "development-guide-entities-components": {
          "id": "development-guide-entities-components",
          "title": "Entities and components",
          "categories": "development-guide",
          "url": " /development-guide/entities-components/",
          "content": "Decentraland scenes are built around entities, components and systems. This is a common pattern used in the architecture of several game engines, that allows for easy composability and scalability.\n\n\n\nOverview\n\nEntities are the basic unit for building everything in Decentraland scenes. All visible and invisible 3D objects and audio players in your scene will each be an entity. An entity is nothing more than a container that holds components. The entity itself has no properties or methods of its own, it simply groups several components together.\n\nComponents define the traits of an entity. For example, a transform component stores the entity’s coordinates, rotation and scale. A BoxShape component gives the entity a box shape when rendered in the scene, a Material component gives the entity a color or texture. You could also create a custom health component to store an entity’s remaining health value, and add it to entities that represent non-player enemies in a game.\n\nIf you’re familiar with web development, think of entities as the equivalent of Elements in a DOM tree, and of components as attributes of those elements.\n\n\n  Note: In previous versions of the SDK, the scene state was stored in an object that was separate from the entities themselves. As of version 5.0, the scene state is directly embodied by the components that are used by the entities in the scene.\n\n\n\n\nComponents like Transform, Material or any of the shape components are closely tied in with the rendering of the scene. If the values in these components change, that alone is enough to change how the scene is rendered in the next frame.\n\nComponents are meant to store data about their parent entity. They only store this data, they shouldn’t modify it themselves. All changes to the values in the components are carried out by Systems. Systems are completely decoupled from the components and entities themselves. Entities and components are agnostic to what systems are acting upon them.\n\nSee Component Reference for a reference of all the available constructors for predefined components.\n\nSyntax for entities and components\n\nEntities and components are declared as TypeScript objects. The example below shows some basic operations of declaring, configuring and assigning these.\n\n// Create an entity\nconst box = new Entity()\n\n// Create and add a `Transform` component to that entity\nbox.addComponent(new Transform())\n\n// Set the fields in the component\nbox.getComponent(Transform).position.set(3, 1, 3)\n\n// Create and apply a `BoxShape` component to give the entity a visible form\nbox.addComponent(new BoxShape())\n\n// Add the entity to the engine\nengine.addEntity(box)\n\n\nAdd entities to the engine\n\nWhen you create a new entity, you’re instancing an object and storing it in memory. A newly created entity isn’t rendered and it won’t be possible for a player to interact with it until it’s added to the engine.\n\nThe engine is the part of the scene that sits in the middle and manages all of the other parts. It determines what entities are rendered and how players interact with them. It also coordinates what functions from systems are executed and when.\n\n// Create an entity\nconst box = new Entity()\n\n// Give the entity a shape\nbox.addComponent(new BoxShape())\n\n// Add the entity to the engine\nengine.addEntity(box)\n\n\nIn the example above, the newly created entity isn’t viewable by players on your scene until it’s added to the engine.\n\n\n  Note: Entities aren’t added to Component groups either until they are added to the engine.\n\n\nIt’s sometimes useful to preemptively create entities and not add them to the engine until they are needed. This is especially true for entities that have elaborate geometries that might otherwise take long to load.\n\nWhen an entity is added to the engine, its alive property is implicitly set to true. You can check if an entity is currently added to the engine via this property.\n\nif (myEntity.alive) {\n  log(\"the entity is added to the engine\")\n}\n\n\n\n  Note: It’s always recommended to add a Transform component to an entity before adding it to the engine. Entities that don’t have a Transform component are rendered in the (0, 0, 0) position of the scene, so if the entity is added before it has a Transform, it will be momentarily rendered in that position, and with its original size and rotation.\n\n\nRemove entities from the engine\n\nEntities that have been added to the engine can also be removed from it. When an entity is removed, it stops being rendered by the scene and players can no longer interact with it.\n\n// Remove an entity from the engine\nengine.removeEntity(box)\n\n\nNote: Removed entities are also removed from all Component groups.\n\nIf your scene has a pointer referencing a removed entity, it will remain in memory, allowing you to still access and change its component’s values and add it back.\n\nIf a removed entity has child entities, all children of that entity are removed too.\n\nNested entities\n\nAn entity can have other entities as children. Thanks to this, we can arrange entities into trees, just like the HTML of a webpage.\n\n\n\nTo set an entity as the parent of another, simply use .setParent():\n\n// Create entities\nconst parentEntity = new Entity()\nengine.addEntity(parentEntity)\n\nconst childEntity = new Entity()\n\n// Set parent\nchildEntity.setParent(parentEntity)\n\n\n\n  Note: Child entities should not be explicitly added to the engine, as they are already added via their parent entity.\n\n\nOnce a parent is assigned, it can be read off the child entity with .getParent().\n\n// Get parent from an entity\nconst parent = childEntity.getParent()\n\n\n\n\nIf a parent entity has a transform component that affects its position, scale or rotation, its children entities are also affected.\n\n\n  For position, the parent’s center is 0, 0, 0\n  For rotation the parent’s rotation is the quaternion 0, 0, 0, 1 (equivalent to the Euler angles 0, 0, 0)\n  For scale, the parent is considered to have a size of 1. Any resizing of the parent affects scale and position in proportion.\n\n\nEntities with no shape component are invisible in the scene. These can be used as wrappers to handle and position multiple entities as a group.\n\nTo remove an entity’s parent, you can assign the entity’s parent to null.\n\nchildEntity.setParent(null)\n\n\nIf you set a new parent to an entity that already had a parent, the new parent will overwrite the old one.\n\nGet an entity by ID\n\nEvery entity in your scene has a unique autogenrated id property. You can retrieve a specific entity from the engine based on this ID, by referring to the engine.entities[] array.\n\nengine.entities[entityId]\n\n\nFor example, if a player’s click or a raycast hits an entity, this will return the id of the hit entity, and you can use the command above to fetch the entity that matches that id.\n\nAdd a component to an entity\n\nWhen a component is added to an entity, the component’s values affect the entity.\n\nOne way of doing this is to first create the component instance, and then add it to an entity in a separate expression:\n\n// Create entity\nconst box = new Entity()\nengine.addEntity(box)\n\n// Create component\nconst myMaterial = new Material()\n\n// Configure component\nmyMaterial.albedoColor = Color3.Red()\n\n// Add component\nbox.addComponent(myMaterial)\n\n\nYou can otherwise use a single expression to both create a new instance of a component and add it to an entity:\n\n// Create entity\nconst box = new Entity()\nengine.addEntity(box)\n\n// Create and add component\nbox.addComponent(new Material())\n\n// Configure component\nbox.getComponent(Material).albedoColor = Color3.Red()\n\n\n\n  Note: In the example above, as you never define a pointer to the entity’s material component, you need to refer to it through its parent entity using .getComponent().\n\n\nAdd or replace a component\n\nBy using .addComponentOrReplace() instead of .addComponent() you overwrite any existing components of the same kind on a specific entity.\n\nRemove a component from an entity\n\nTo remove a component from an entity, simply use the entity’s removeComponent() method.\n\nmyEntity.removeComponent(Material)\n\n\nIf you attempt to remove a component that doesn’t exist in the entity, this action won’t raise any errors.\n\nA removed component might still remain in memory even after removed. If your scene adds new components and removes them regularly, these removed components will add up and cause memory problems. It’s advisable to instead use an object pool when possible to handle these components.\n\nAccess a component from an entity\n\nYou can reach components through their parent entity by using the entity’s .getComponent() function.\n\n// Create entity and component\nconst box = new Entity()\n\n// Create and add component\nbox.addComponent(new Transform())\n\n// Using get\nlet transform = box.getComponent(Transform)\n\n// Edit values in the component\ntransform.position = new Vector3(5, 0, 5)\n\n\nThe getComponent() function fetches a reference to the component object. If you change the values of what’s returned by this function, you’re changing the component itself. For example, in the example above, we’re setting the position stored in the component to (5, 0, 5).\n\nbox.getComponent(Transform).scale.x = Math.random() * 10\n\n\nThe example above directly modifies the value of the x scale on the Transform component.\n\nIf you’re not entirely sure if the entity does have the component you’re trying to retrieve, use getComponentOrNull() or getComponentOrCreate()\n\n//  getComponentOrNull\nlet scale = box.getComponentOrNull(Transform)\n\n// getComponentOrCreate\nlet scale = box.getComponentOrCreate(Transform)\n\n\nIf the component you’re trying to retrieve doesn’t exist in the entity:\n\n\n  getComponent() returns an error.\n  getComponentOrNull() returns Null.\n  getComponentOrCreate() instances a new component in its place and retrieves it.\n\n\nWhen you’re dealing with Interchangeable component, you can also get a component by space name instead of by type. For example, both BoxShape and SphereShape occupy the shape space of an entity. If you don’t know which of these an entity has, you can fetch the shape of the entity, and it will return whichever component is occupying the shape space.\n\nlet entityShape = myEntity.getComponent(shape)\n\n\nPooling entities and components\n\nIf you plan to spawn and despawn similar entities from your scene, it’s often a good practice to keep a fixed set of entities in memory. Instead of creating new entities and deleting them, you could add and remove existing entities from the engine. This is an efficient way to deal with the player’s memory.\n\nEntities that are not added to the engine aren’t rendered as part of the scene, but they are kept in memory, making them quick to load if needed. Their geometry doesn’t add up to the maximum triangle count four your scene while they aren’t being rendered.\n\n// Define spawner singleton object\nconst spawner = {\n  MAX_POOL_SIZE: 20,\n  pool: [] as Entity[],\n\n  spawnEntity() {\n    // Get an entity from the pool\n    const ent = spawner.getEntityFromPool()\n\n    if (!ent) return\n\n    // Add a transform component to the entity\n    let t = ent.getComponentOrCreate(Transform)\n    t.scale.setAll(0.5)\n    t.position.set(5, 0, 5)\n\n    //add entity to engine\n    engine.addEntity(ent)\n  },\n\n  getEntityFromPool(): Entity | null {\n    // Check if an existing entity can be used\n    for (let i = 0; i &lt; spawner.pool.length; i++) {\n      if (!spawner.pool[i].alive) {\n        return spawner.pool[i]\n      }\n    }\n    // If none of the existing are available, create a new one, unless the maximum pool size is reached\n    if (spawner.pool.length &lt; spawner.MAX_POOL_SIZE) {\n      const instance = new Entity()\n      spawner.pool.push(instance)\n      return instance\n    }\n    return null\n  },\n}\n\nspawner.spawnEntity()\n\n\nWhen adding an entity to the engine, its alive field is implicitly set to true, when removing it, this field is set to false.\n\nUsing an object pool has the following benefits:\n\n\n  If your entity uses a complex 3D model or texture, it might take the scene some time to load it from the content server. If the entity is already in memory when it’s needed, then that delay won’t happen.\n  This is a solution to avoid a common problem, where each entity that’s removed could remain lingering in memory after being removed, and these unused entities could add up till they become too many to handle. By recycling the same entities, you ensure this won’t happen."
        }
        
      
    
  
    
      
        ,
        
        "development-guide-custom-components": {
          "id": "development-guide-custom-components",
          "title": "Custom components",
          "categories": "development-guide",
          "url": " /development-guide/custom-components/",
          "content": "Custom components\n\nIf you need to store information about an entity that isn’t handled by the default components of the SDK (see component reference ), then you can create a custom type of component on your scene.\n\nTip: Custom components can be defined in your scene’s .ts file, but for larger projects we recommend defining them in a separate ts file and importing them.\n\nA component can store as many fields as you want.\n\n@Component(\"wheelSpin\")\nexport class WheelSpin {\n  spinning: boolean\n  speed: number\n}\n\n\nNote that we’re defining two names for the component: wheelSpin and WheelSpin in this case. The class name, the one in upper case, is the one you use to add the component to entities. The space name, the one starting with a lower case letter, can mostly be ignored, except if you want to use it as an Interchangeable component.\n\nOnce defined, you can use the component in the entities of your scene:\n\n// Create entities\nconst wheel = new Entity()\nconst wheel2 = new Entity()\n\n// Create instances of the component\nwheel.addComponent(new WheelSpin())\nwheel2.addComponent(new WheelSpin())\n\n// Set values on component\nwheel.getComponent(WheelSpin).spinning = true\nwheel.getComponent(WheelSpin).speed = 10\nwheel2.getComponent(WheelSpin).spinning = false\n\n\nEach entity that has the component added to it is instancing a new copy of it, holding specific data for that entity.\n\nConstructors\n\nAdding a constructor to a component allows you to configure its values in the same expression as you create an instance of it.\n\n@Component(\"wheelSpin\")\nexport class WheelSpin {\n  spinning: boolean\n  speed: number\n  constructor(spinning: boolean, speed: number) {\n    this.spinning = spinning\n    this.speed = speed\n  }\n}\n\n\nIf the component includes a constructor, you can use the following syntax:\n\n// Create entity\nconst wheel = new Entity()\n\n// Create instance of component and set its values\nwheel.addComponent(new WheelSpin(true, 10))\n\n\n\n  Tip: If you use a source code editor, when instancing a component that has a constructor, you can see what the parameters are by mousing over the expression.\n\n\n\n\nYou can make the parameters optional by setting default values on each. If there are default values and you don’t declare the parameters when instancing a component, it will use the default.\n\n@Component(\"wheelSpin\")\nexport class WheelSpin {\n  spinning: boolean\n  speed: number\n  constructor(spinning?: boolean = false, speed?: number = 3) {\n    this.spinning = spinning\n    this.speed = speed\n  }\n}\n\n\n// Create entity\nconst wheel = new Entity()\n\n// Create instance of component with default values\nwheel.addComponent(new WheelSpin())\n\n\nInheritance from other components\n\nYou can create a component that’s based on an existing one and leverage all of its existing methods and fields.\n\nThe following example defines a Velocity component, which inherits its fields and methods from the already existing Vector3 component.\n\n@Component(\"velocity\")\nexport class Velocity extends Vector3 {\n  // x, y and z fields are inherited from Vector\n  constructor(x: number, y: number, z: number) {\n    super(x, y, z)\n  }\n}\n\n\nInterchangeable components\n\nCertain components intentionally can’t coexist in a single entity. For example, an entity can’t have both BoxShape and PlaneShape. If you assign one using .addComponentOrReplace(), you overwrite the other if present.\n\nYou can create custom components that follow this same behavior against each other, where it only makes sense for each entity to have only one of them assigned.\n\nTo define components that are interchangeable and that occupy a same space in an entity, set the same name for both on the component’s internal name:\n\n@Component(\"animal\")\nexport class Dog {\n (...)\n}\n\n@Component(\"animal\")\nexport class Cat {\n (...)\n}\n\n\nIn the example above, note that both components occupy the animal space. Each entity in the scene can only have one animal component assigned.\n\nIf you use .addComponentOrReplace() to assign a Dog component to an entity that has a Cat component, then the Dog component will overwrite the Cat component.\n\nComponents as flags\n\nYou may want to add a component that simply flags an entity to differentiate it from others, without using it to store any data.\n\nThis is especially useful when using Component groups. Since component groups list entities based on components they own, a simple flag component can tell entities apart from others.\n\n@Component(\"myFlag\")\nexport class MyFlag {}"
        }
        
      
    
  
    
      
        ,
        
        "3d-modeling-animations": {
          "id": "3d-modeling-animations",
          "title": "Animations",
          "categories": "3d-modeling",
          "url": " /3d-modeling/animations/",
          "content": "3D models can be animated in a Decentraland scene using animations. All animations of a 3D model must be embedded inside its glTF file, you can’t reference animations in separate files.\n\nMost 3D model animations are skeletal animations. These animations simplify the complex geometry of the model into a “stick figure”, linking every vertex in the mesh to the closest bone in the skeleton. Modelers adjust the skeleton into different poses, and the mesh stretches and bends to follow these movements.\n\nAs an alternative, vertex animations animate a model without the need of a skeleton. These animations specify the position of each vertex in the model directly. These animations aren’t currently supported by Decentraland’s engine.\n\nThere’s no specific rule about the names animations must have. You can verify the names of the animations in an exported model by opening the contents of a .gltf file with a text editor. You can also inspect the model in Babylon sandbox to see the available animations.\n\nYou can include any number of animations in a glTF model. All animations in a glTF model are disabled by default when loading the model into a Decentraland scene.\n\nIn a Decentraland scene, you can use weight to blend several animations or to make an animation more subtle.\n\n\n  Tip: Instead of creating your own animations, you can also download generic animations and apply them to your model. For example, for 3D characters with human-like characteristics, you can download free or paid animations from Mixamo.\n\n\nThis document covers how to add animations into a 3D model. See handle animations for instructions on how to activate and handle animations in a scene.\n\nHow to create an animation\n\nYou can use a tool like Blender to create animations for a 3D model.\n\n\n  \n    Create an armature, following the shape of your model and the parts you wish to move. You do this by adding an initial bone and then extruding all other bones from the vertices of that one. Bones in the armature define the points that can be articulated. The armature must be positioned overlapping the mesh.\n\n    \n  \n  \n    Make both the armature and the mesh child assets of the same object.\n  \n  \n    Check that the mesh moves naturally when rotating its bones in the ways you plan to move it. If parts of the mesh get stretched in undesired ways, use weight paint to change what parts of the model are affected by each bone in the armature.\n\n    \n\n    \n  \n\n\n\n  Note: There’s a reported bug with Babylon.js that prevents some faces of a mesh from being rendered when they’re not related to any bone in the armature. So if you paint some faces with weight 0 and then animate the model, you might see these faces dissappear. To solve this, we recommend making sure that each face is related to at least one bone of the armature and painted with a weight of at least 0.01.\n\n\n\n  \n    Move the armature to a desired pose, all bones can be rotated or scaled. Then lock the rotation and scale of the bones you wish to control with this animation.\n\n    \n  \n  \n    Switch to a different frame in the animation, position the armature into a new pose and lock it again. Repeat this process for all the key frames you want to set to describe the animation.\n\n    \n  \n  \n    By default all frames in between the ones you defined will transition linearly from one pose to the next. You can also configure these transitions to behave exponentially, ease-in, bounce, etc.\n  \n\n\nVertex animations\n\nVertex animations, also known as morph-targets, aren’t currently supported by Decentraland’s engine.\n\nHow to handle multiple animations with Blender\n\nTo export a model with several embedded animations in Blender, you must create multiple actions from the Dope-Sheet.\n\n\n\nYou can also edit the animation from the Dope-Sheet view, for example you can adjust the distance between two key frames.\n\nTo preview the different actions, open the Action Editor (only accessible once you’re in the Dope Sheet).\n\n\n\nIn order to export multiple animations, you need to stash all the actions using the NLA Editor. We recommend opening the NLA editor on a separate editor tab while keeping the Dope sheet also open.\n\n\n\nIn the NLA Editor, select each action that you want to embed in the glTF model and click Stash.\n\n\n\nWhen adding the model to your Decentraland scene, you must activate animations by configuring the gltf-model entity. See 3D model animations for instructions.\n\nBest practices for animations\n\n\n  Keep the armature simple, only create bones for the parts of the model that you intend to animate.\n  If the animation will be looped in your scene, make sure the final pose is identical to the starting pose to avoid jumps.\n  Sometimes in an animation you might want to only control the movements of parts of the armature, and leave other bones undefined. This can make it easier to combine animations together.\n  Animated characters in your scene shouldn’t ever stay completely still, even when they aren’t doing anything. It’s best to create an “idle” animation to use for when the character is still. The idle animation can include subtle movements like breathing and perhaps occasional glances.\n  Make sure your model only has one armature when you export it. Sometimes, when importing another animation to the program where you’re editing your model, it will bring in a copy of the armature. You want all animations of the model to be performed by the same base armature.\n  When exporting the glTF model, make sure you’re exporting all the objects and animations. Some exporters will only export the currently selected by default.\n  After exporting the model, inspect it in Babylon sandbox to make sure all animations work and are named as expected."
        }
        
      
    
  
    
      
        ,
        
        "3d-modeling-colliders": {
          "id": "3d-modeling-colliders",
          "title": "Colliders",
          "categories": "3d-modeling",
          "url": " /3d-modeling/colliders/",
          "content": "To enable collisions between a 3D model and users of your scene, you must create a new object to serve as a collider. Without a collider, players are able to walk through models as if they weren’t there. For performance reasons, colliders usually have a much simpler geometry than the model itself.\n\nColliders currently don’t affect how models and entities interact with each other, they can always overlap. Colliders only affect how the model interacts with the player’s avatar.\n\nFor an object to be recognized by a Decentraland scene as a collider, all it needs is to be named in a certain way. The object’s name must include the the suffix “_collider” at the end.\n\nFor example, to create a collider for a tree, you can create a simple box object surrounding its trunk. Players in the scene won’t see this box, but it will block their path.\n\n\n\nIn this case, we can name the box “BoxTree_collider” and export both the tree and the box as a single _gltf model. The _collider tag alerts the Decentraland world engine that the box object belongs to the collection of colliders, making the _collider mesh invisible.\n\n\n\nWhenever a player views the tree model in your scene, they will see the complex model for your tree. However, when they walk into your tree, they will collide with the box, not the tree.\n\nPlayer spatial constraints\n\nWhen you design models that are meant for players to walk around in, you need to keep in mind the following reference measurements:\n\n\n  Players can walk up a step of up to 30 centimeters in height without jumping\n  Players can walk up slopes of an angle of up to 45 degrees without jumping\n  Players can jump up to 1,8 meters in height\n  Avatars measure around 1.9 meters in height, but consider that they might have hats or other wearables on their head.\n\n\nAdd a collider to a staircase\n\nStairs are a very common use-case for collider objects. In order for players to climb stairs, there must be a corresponding _collider object that the players are able to step on.\n\nWe recommend using a ramp object for your stair colliders, this provides a much better experience when walking up or down. When they climb up your stairs, it will appear as a smooth ascent or descent, instead of requiring them to “jump” up each individual step.\n\nUsing a ramp object also avoids creating unnecessary geometry, saving room for other more complicated models. Keep in mind that collider geometry is also taken into account when calculating the scene limitations\n\n\n  \n    Create a new object in the shape of a ramp that resembles the size and proportions of the original stairs.\n\n    \n  \n  \n    Name the ramp object something similar to stairs_collider. It must end in _collider.\n  \n  \n    Overlay the ramp object to the stairs so that they occupy the same space.\n\n    \n  \n  \n    Export both objects together as a single glTF model.\n\n    \n  \n\n\nNow when players view the stairs in your scene, they’ll see the more elaborate model of the stairs, but when they climb them, they’ll collide with the ramp.\n\nBest practices with colliders\n\n\n  Always use the smallest number of triangles possible when creating colliders. Avoid making a copy of a complex object to use as a collider. Simple colliders guarantee a good user-experience in and keep your scene within the triangle limitations.\n  Collider objects shouldn’t have any material, as players of your scene will never see it. Colliders are invisible to players.\n    \n      Note: Remember that each scene is limited to log2(n+1) x 10000 triangles, where n is the number of parcels in your scene.\n    \n  \n  All collider objects names must end with _collider. For example, tree_collider.\n  \n    If you use a plane as a collider, it will only block in one direction. If you want colliders to block from both sides, for example for a wall, you need to create two planes with their normals facing in opposite directions.\n  \n  \n    When duplicating collider objects, pay attention to their names. Some programs append a _1 to the end of the filename to avoid duplicates, for example tree_collider_1. Objects that are named like this will be interpreted by the Decentraland World Engine as normal objects, not colliders.\n  \n  \n    You can avoid adding a collider mesh if you add an invisible primitive shape that overlaps to your 3D model in your scene. Primitive shapes have collisions on by default. For example, an entity with a BoxShape() component, and its visible property set to false can do the trick.\n  \n  If you’re creating a 3D model with many mesh shapes that each need their collider, there are some handy add-ons that can help. For Blender you can use Simple Renaming Panel to automatically add a _collider suffix to all mesh names in a group."
        }
        
      
    
  
    
      
        ,
        
        "3d-modeling-meshes": {
          "id": "3d-modeling-meshes",
          "title": "Meshes",
          "categories": "3d-modeling",
          "url": " /3d-modeling/meshes/",
          "content": "3D models have a mesh composed of triangular faces. These faces meet each other on edges (the lines along which they touch) and vertices (the points where their corners join).\n\nScene limits\n\nAll 3D models in your scene must fit within the limits of its parcels. If they extend beyond these limits when running a preview, the meshes will be marked in red and bounding boxes will be highlighted in white.\n\nFor performance reasons, Decentraland checks the positions of the bounding boxes around meshes (not the vertices in the meshes themselves) to verify that they are within the scene’s limits.\n\nIf you have a model that has all of its vertices neatly inside the scene area, but that has large bounding boxes that are mostly empty and extend beyond the scene limits, the entire model will be marked as outside the scene limits.\n\nTo avoid this problem, you can clean up your 3D models to reset positions and rotations of meshes so that bounding boxes don’t extend beyond the meshes they wrap.\n\nSmooth geometries\n\nYou can configure a mesh to be smooth. This tells the engine to render its shape as if there was an infinite number of intermediate faces rounding it off. This setting can greatly help you reduce the number of triangles needed to make a shape appear to be rounded.\n\nThe image below shows two identical models with the same materials. They differ in that the one on the right has most of its geometry set to smooth.\n\n\n\nNote how you can see distinct faces on all of the cylindrical shapes of the model on the left, but not on the model on the right.\n\nThis setting can be configured separately over individual faces, edges and vertices of a model. One same model could have some of its faces or edges set to smooth and others to sharp\n\nBounding boxes\n\nEvery mesh has a bounding box, that surrounds the limits of the shape. Keep in mind that the bounding boxes of all 3D models in a Decentraland scene must fit inside the scene limits, see position entities for more details.\n\n\n\nTo make a 3D model more usable inside decentraland, make sure that its bounding boxes don’t extend beyond the model more than necessary.\n\nFor example, be cautious when rotating a sub-mesh near the border of your model. Since bounding boxes are cubes, even if the mesh is round, the corners of its bounding box might end up sticking out after rotating it 45°.\n\nWe recommend that you bake the rotation and scale of every mesh in the model, to make sure that there are no unwanted bounding boxes extending beyond the size they need to have.\n\nBest practices for geometries\n\n\n  Be mindful of how many faces you add to your 3D models, as more faces make its rendering more demanding. See scene limitations for the limits imposed by a scene.\n  Make sure there are no hidden faces that can’t be seen but that add to the triangle count.\n  For shapes that should have rounded sides, set them to be smooth rather than adding additional faces.\n  Make sure the normals of all faces are facing outwards instead of inwards. If there are faces in your model that seem not to be there when you render it, this is most likely the cause.\n  Bake the rotation and scale of your meshes, so that their bounding boxes don’t extend out unnecessarily."
        }
        
      
    
  
    
      
        ,
        
        "development-guide-remote-scene-considerations": {
          "id": "development-guide-remote-scene-considerations",
          "title": "About multiplayer scenes",
          "categories": "development-guide",
          "url": " /development-guide/remote-scene-considerations/",
          "content": "Decentraland runs scenes locally in a player’s browser. By default, players are able to see each other and interact directly, but each one interacts with the environment independently. Changes in the environment aren’t shared between players by default. You need to implement this manually.\n\nAllowing all players to see a scene as having the same content in the same state is extremely important to for players to interact in more meaningful ways. Without this, if a player opens a door and walks into a house, other players will see that door as still closed, and the first player will appear to walk directly through the closed door to other players.\n\nThere are two ways to keep the scene state that all players see in sync:\n\n\n  Send P2P messages between players to update changes\n  Use an authoritative server to keep track of the scene’s state\n\n\nThe first of these options is the easiest to implement. The downside is that you rely more on player’s connection speeds. Also, if there are incentives to exploit (eg: there are prizes for players with highest scores in a game, or there are in-game transactions) it’s always recommendable to use an authoritative server, as this allows you to have more control and exposes less vulnerabilities.\n\nP2P messaging\n\nInitiate a message bus\n\nCreate a message bus object to handle the methods that are needed to send and receive messages between players.\n\nconst sceneMessageBus = new MessageBus()\n\n\nSend messages\n\nUse the .emit command of the message bus to send a message to all other players in the scene.\n\nconst sceneMessageBus = new MessageBus()\n\nbox1.AddComponent(\n  new OnClick((e) =&gt; {\n    sceneMessageBus.emit(\"box1Clicked\", {})\n  })\n)\n\n\nEach message can contain a payload as a second argument. The payload is of type Object, and can contain any relevant data you wish to send.\n\nconst sceneMessageBus = new MessageBus()\n\nlet spawnPos = new Vector3(5, 0, 5)\n\nsceneMessageBus.emit(\"spawn\", { position: spawnPos })\n\n\n\n  Tip: If you need a single message to include data from more than one variable, create a custom type to hold all this data in a single object.\n\n\nReceive messages\n\nTo handle messages from all other players in that scene, use .on. When using this function, you provide a message string and define a function to execute. For each time that a message with a matching string arrives, the given function is executed once.\n\nconst sceneMessageBus = new MessageBus()\n\nsceneMessageBus.on(\"spawn\", (info: NewBoxPosition) =&gt; {\n  let newCube = new Entity()\n  let transform = new Transform()\n  transform.position.set(info.position.x, info.position.y, info.position.z)\n  newCube.addComponent(transform)\n  engine.addComponent(newCube)\n})\n\n\n\n  Note: Messages that are sent by a player are also picked up by that same player. The .on method can’t distinguish between a message that was emitted by that same player from a message emitted from other players.\n\n\nFull example\n\nThis example uses a message bus to send a new message every time the main cube is clicked, generating a new cube in a random position. The message includes the position of the new cube, so that all players see these new cubes in the same positions.\n\n/// --- Spawner function ---\n\nfunction spawnCube(x: number, y: number, z: number) {\n  // create the entity\n  const cube = new Entity()\n\n  // add a transform to the entity\n  cube.addComponent(new Transform({ position: new Vector3(x, y, z) }))\n\n  // add a shape to the entity\n  cube.addComponent(new BoxShape())\n\n  // add the entity to the engine\n  engine.addEntity(cube)\n\n  return cube\n}\n\n/// --- Create message bus ---\nconst sceneMessageBus = new MessageBus()\n\n/// --- Define a custom type to pass in messages ---\ntype NewBoxPosition = {\n  position: ReadOnlyVector3\n}\n\n/// --- Call spawner function ---\nconst cube = spawnCube(8, 1, 8)\n\n/// --- Emit messages ---\ncube.addComponent(\n  new OnClick(() =&gt; {\n    const action: NewBoxPosition = {\n      position: {\n        x: Math.random() * 8 + 1,\n        y: Math.random() * 8,\n        z: Math.random() * 8 + 1,\n      },\n    }\n\n    sceneMessageBus.emit(\"spawn\", action)\n  })\n)\n\n/// --- Receive messages ---\nsceneMessageBus.on(\"spawn\", (info: NewBoxPosition) =&gt; {\n  cube.getComponent(Transform).scale.z *= 1.1\n  cube.getComponent(Transform).scale.x *= 0.9\n\n  spawnCube(info.position.x, info.position.y, info.position.z)\n})\n\n\nMore examples\n\nFind some more examples in the Awesome Repository\n\nTest a P2P scene locally\n\nIf you launch a scene preview and open it in two (or more) different browser windows, each open window will be interpreted as a separate player, and a mock communications server will keep these players in sync.\n\nInteract with the scene on one window, then switch to the other to see that the effects of that interaction are also visible there.\n\n\n  Note: Open separate browser windows. If you open separate tabs in the same window, the interaction won’t work properly, as only one tab will be treated as active by the browser at a time.\n\n\nUse an authoritative server\n\nAn authoritative server may have different levels of involvement with the scene:\n\n\n  API + DB: This is useful for scenes where changes don’t happen constantly and where it’s acceptable to have minor delays in syncing. When a player changes something, it sends an HTTP request to a REST API that stores the new scene state in a data base. Changes remained stored for any new player that visits the scene at a later date. The main limitation is that new changes from other players aren’t notified to players who are already there, messages can’t be pushed from the server to players. Players must regularly send requests the server to get the latest state.\n\n\n\n  TIP: It’s also possible to opt for a hybrid approach where changes are notified between players via P2P Messagebus messages, but the final state is also stored via an API for future visitors.\n\n\n\n  Websockets: This alternative is more robust, as it establishes a two-way communications channel between player and server. Updates can be sent from the server, you could even have game logic run on or validated on the server. This enables real time interaction and makes more fast paced games possible. It’s also more secure, as each message between player and server is part of a session that is opened, no need to validate each message.\n\n\nExample scenes with authoritative server\n\n\n  \n    API + DB\n  \n  \n    Websockets\n  \n\n\nPreview scenes with authoritative servers\n\nTo preview a scene that uses an authoritative server, you must run both the scene and the server it relies on. The server can be run locally in the same machine as the preview, as an easier way to test it.\n\nTo start the server, go to the /server folder and run npm start.\n\nOnce the server is running, either remotely or locally, you can run dcl start on the scene as you normally do for local scenes.\n\nOnce the scene preview is running, you can open multiple browser tabs pointing at the same local address. Each tab will instantiate a separate player in the same scene, these players will share the same scene state as the scene changes.\n\nSee preview a scene for more details.\n\nSeparate realms\n\nPlayers in decentraland exist in many separate realms. Players in different realms cant see each other, interact or chat with each other, even if they’re standing on the same parcels. Dividing players like this allows Decentraland to handle an unlimited amount of players without running into any limitations. It also pairs players that are in close regions, to ensure that ping times between players that interact are acceptable.\n\nIf your scene sends data to a 3rd party server to sync changes between players in real time, then it’s important that changes are only synced between players that are on the same realm. You should handle all changes that belong to one realm as separate from those on a different realm. Otherwise, players will see things change in a spooky way, without anyone making the change.\n\nSee how to obtain the realm for each player in get player data\n\nMultiplayer persistance\n\nUnlike local scenes that are newly mounted each time a player walks into them, scenes that use authoritative servers have a life span that extends well beyond when the player enters and leaves the scene.\n\nYou must therefore design the experience taking into account that player won’t always find the scene in the same initial state.\nAny changes made to the scene will linger on for other players to find, you must make sure that these don’t interfere with future player’s experiences in an undesired way.\n\nReset the state\n\nWhen loading the scene, make sure its built based on the shared information stored in the server, and not in a default state.\n\nIn some cases, it makes sense to include some kind of reset button in the scene. Pressing the reset button would reset the scene gracefully.\n\nSometimes, this just implies setting the variables in the scene state back to default values. But resetting the scene might also involve unsubscribing listeners and stopping loops in the server side. If empty loops remain each time the scene is reset, these would keep piling up and will have an ill effect on the scene’s performance."
        }
        
      
    
  
    
      
        ,
        
        "3d-modeling-materials": {
          "id": "3d-modeling-materials",
          "title": "Materials",
          "categories": "3d-modeling",
          "url": " /3d-modeling/materials/",
          "content": "Materials are embedded into a .gltf or .glb file.\n\nThis document refers to materials that are imported in a 3D model. For materials defined via code to apply onto primitive shapes, see materials.\n\n\n  Note: You can’t currently dynamically change the materials of a 3D model from your scene’s code, unless this is a primitive shape.\n\n\nShader support\n\nNot all shaders can be used in models that are imported into Decentraland. Make sure you use one of the following:\n\n\n  \n    Standard materials: any shaders are supported, for example diffuse, specular, transparency, etc.\n\n    \n      Tip: When using Blender, these are the materials supported by Blender Render rendering.\n    \n  \n  \n    PBR (Physically Based Rendering) materials: This shader is extremely flexible, as it includes properties like diffuse, roughness, metalness and emission that allow you to configure how a material interacts with light.\n\n    \n      Tip: When using Blender, you can use PBR materials by setting Cycles rendering and adding the Principled BSDF shader. Note that none of the other shaders of the Cycles renderer are supported.\n    \n  \n\n\nThe image below shows two identical models, created with the same colors and textures. The model on the left uses all PBR materials, some of them include metalness, transparency, and emissiveness. The model on the right uses all standard materials, some including transparency and emissiveness.\n\n\n\nTransparent materials\n\nYou can set a material to be transparent. Transparent materials can be seen through to varying degrees, depending on their alpha. To do this, activate the transparency property of the material and then set its alpha to the desired amount. An alpha of 1 will make the material completely opaque, an alpha of 0 will make it invisible.\n\nThe image below shows two identical models created with standard materials. The one on the left uses only opaque materials, the one on the right uses both transparent and opaque materials in some of its parts.\n\n\n\nThere are two main different transparency modes: Aplha Clip and Aplha Blend.\n\nAlpha Clip sets that each part of a model is either 100% opaque or 100% transparent. Alpha Blend allows you to pick intermediate values per region.\n\n\n\nUnless you specifically want to be able to have an intermediate level of transparency, it’s always better to use Alpha Clip.\n\nEmissive materials\n\nYou can also make a material emissive. Emissive materials cast their own light. Note that when rendered, they don’t actually illuminate nearby objects in the scene, they just seem to have a blurred glow around them.\n\nThe image below shows two identical models created with standard materials. The one on the right has glowing emissive materials on some of its surfaces.\n\n\n\nTo make a material emissive in Blender, simply add an emission shader to the material.\n\n\n\nTo make a material both emissive and have a texture, you can use two shaders in parallel, one of the emission and another principled BDSF for the texture. You can then use a mix shader node to join them.\n\n\n\n\n  Tip: By using a color atlas as a texture, you can get away with having various possible colors counted as a single texture. This is useful for making sure you don’t exceed the scene limitations.\n\n\n\n\nSoften an emissive\n\nThe emission shader has a strength property that can lower the glow of an emissive material. However, due to a known issue with the .glTF specification, an exported .glTF or .glb file doesn’t retain this property. When importing the model into a Decentraland scene it will always have the emissive strength at 100%.\n\nTo make a material glow less, the best workaround is to set the color property on the emission shader to something less bright, or to reference a color from a texture that is less bright.\n\nFor example, if using the below color map, you can achieve a less bright emissive material by picking a color from the bottom half of the image. Anything on the top half will be fully emissive, but as you go lower the material will have less glow.\n\n\n\nVertex painting\n\nVertex painting of 3D models isn’t currently supported by Decentraland’s engine. We recommend using texture mapping with a pallette of plain colors for a similar effect.\n\nTextures\n\nTextures can be embedded into the exported glTF file or referenced from an external file. Both ways are supported.\n\n\n\nDefault textures\n\nAll of the assets from the default Decentraland asset libraries (available in the Builder or as wearables) share a set of optimized plane textures. These textures are pre-loaded by players when they open the explorer, which makes these assets a lot faster to load.\n\nIf you build your own custom 3D models and use these same Decentraland default textures, your assets will also load faster when players walk to your parcels.\n\nThese textures are composed of a palette of plain colors, that you can map to different parts of a 3D model.\n\n\n\nYou can find the full collection of Decentrlanad default textures in this repo\n\nLighting conditions\n\nIt’s currently not possible to have custom light sources in a Decentraland scene. You may want to consider baking lighting into a texture, for example to simulate a lighting focal point on a wall.\n\nNote that objects cast shadows over others. The default lighting conditions have a light source that is positioned at 45 degrees on all three axis.\n\nEmissive materials aren’t affected by shadows from other objects, but they do cast their own shadow.\n\nTexture size constraints\n\nTexture sizes must use width and height numbers (in pixels) that match the following numbers:\n\n1, 2, 4, 8, 16, 32, 64, 128, 256, 512\n\n\n\n  This sequence is made up of powers of two: f(x) = 2 ^ x . 512 is the maximum number we allow for a texture size. This is a fairly common requirement among other rendering engines, it’s there due internal optimizations of the graphics processors.\n\n\nThe width and height don’t need to have the same number, but they both need to belong to this sequence.\n\nThe recommended size for textures is 512x512, we have found this to be the optimal size to be transported through domestic networks and to provide reasonable loading/quality experiences.\n\nExamples of other valid sizes:\n\n32x32\n64x32\n512x256\n512x512\n\n\n\n  Although textures of arbitrary sizes work in the alpha release, the engine displays an alert in the console. We will enforce this restriction in coming releases and invalid texture sizes will cease to work.\n\n\nNormal maps\n\nYou can add an additional normal map to a texture to control how reflections bounce off different regions of a same model. This can be used to achieve very interesting and realistic effects. It also allows you to keep the textures themselves lighter, as some detail can be provided on the normal map layer instead.\n\nThe colors on the normal map are not to be taken literally, but instead map to what direction light bounces off to. Darker parts of the texture will reflect less light.\n\n\n\nFor example in this brick wall can be overlayed on a texture that matches the same brick positions. The different color mapping implies that the blue bricks will bounce light forward. The green margins on the top bounce light upwards. The cracks between the bricks reflect a lot less light. This is a great way to get the lighting on the wall behave more realistically, without having to spend geometry on each individual brick.\n\n\n  NOTE: Never use the same texture file for both the texture of an object and its normal map. Create a separate file and name it differently. Models in deployed scenes are compressed by the content servers, and normal maps are compressed differently to other textures. The compressed model might end up looking very different if the server compresses a texture as a normal map or viceversa.\n\n\nHow to swap a material\n\nSuppose you’ve imported a 3D model that uses a material that’s not supported by Decentraland. You can easily change this material while still keeping the same texture and its mapping.\n\n\n\nTo swap the material:\n\n\n  Check the current material’s settings to see what texture files are being used and how they are configured.\n  \n    Delete the current material from the mesh.\n\n    \n  \n  \n    Create a new material.\n\n    \n\n    \n      Tip: If you’re using Blender and are on the Blender Render tab, it creates a basic material by default, which is supported by Decentraland.\n    \n  \n  \n    Open the Textures settings and create a new texture, importing the same image file that the original material used.\n\n    \n  \n  \n    The texture should be mapped to the new material just as it was mapped to the old material.\n\n    \n  \n\n\nBest practices for materials\n\n\n  \n    If your scene includes multiple models that use the same texture, reference the texture as an external file instead of having it embedded in the 3D model. Embedded textures get duplicated for each model and add to the scene’s size. .glb files have their textures embedded by default, but you can use glTF pipeline to extract it outside.\n\n    \n      Note: After referencing a file for a texture that won’t be embedded, make sure that file won’t be moved or renamed, as otherwise the reference to the file will be lost. The file must also be inside the scene folder so that it’s uploaded together with the scene.\n    \n  \n  Use the Decentraland default textures, which are pre-loaded by players, making your assets render a lot faster.\n  Read this article for a detailed overview of a full art pipeline that uses PBR textures in glTF models.\n  You can find a detailed reference about how to create glTF compatible materials with Blender in Blender’s documentation.\n  Find free, high quality PBR textures in cgbookcase.\n  When setting transparency of a material, try to always use Alpha clip rather than Alpha blend, unless you specifically need to have a material that’s partially transparent (like glass). This will avoid problems where the engine renders the wrong model in front of the other."
        }
        
      
    
  
    
      
        ,
        
        "3d-modeling-3d-models": {
          "id": "3d-modeling-3d-models",
          "title": "3D model essentials",
          "categories": "3d-modeling",
          "url": " /3d-modeling/3d-models/",
          "content": "3D models are imported into decentraland in glTF format. There are a number of supported features that these models can include. This section goes over ways to make them compatible with Decentraland and best practices.\n\nSee Set entity position for information on how you can configure a 3D model in a Decentraland scene to set its position, scale, etc.\n\nKeep in mind that all models, their shaders and their textures must be within the parameters of the scene limitations.\n\nSupported 3D model formats\n\nAll 3D models in Decentraland must be in glTF format. glTF (GL Transmission Format) is an open project by Khronos providing a common, extensible format for 3D assets that is both efficient and highly interoperable with modern web technologies.\n\nglTF models can have either a .gltf or a .glb extension. glTF files are human-readable, you can open one in a text editor and read it like a JSON file. This is useful, for example, to verify that animations are properly attached and to check for their names. glb files are binary, so they’re not readable but they are considerably smaller in size, which is good for the scene’s performance.\n\nWe recommend using .gltf while you’re working on a scene, but then switching to .glb when uploading it.\n\nThe following aspects of a 3D model can either be embedded in a glTF file or referenced externally:\n\n\n  Textures can either be embedded or referenced from an external image file.\n  Binary data about geometry, animations, and other buffer-related aspects of the model can either be embedded or referenced from an external .bin file.\n\n\n\n  Note: Animations must be embedded inside the glTF file to use in Decentraland.\n\n\nExport to glTF from Blender\n\nWhen exporting 3D models that include multiple animations, make sure that all animations are embedded in the model. To do this, open the NLA editor and click Stash to add each animation to the model.\n\nWe recommend using the following export settings when exporting models with animations:\n\n\n\nExport to glTF from 3D Studio Max\n\n3D Studio Max doesn’t support exporting to glTF by default, but you can install a plugin to enable it.\n\n\n  Download the plugin from this link.\n  Install the plugin by following these instructions.\n  Export glTF files using the plugin by following these instructions.\n\n\nExport to glTF from Maya\n\nMaya doesn’t support exporting to glTF by default, but you can install a plugin to enable it.\n\n\n  Install the plugin by following these instructions.\n  Export glTF files using the plugin by following these instructions.\n\n\n\n  Note: As an alternative, you can try this other plugin too.\n\n\nExport to glTF from Unity\n\nUnity doesn’t support exporting to glTF by default, but you can install a plugin to enable it.\n\nDownload the plugin from this link.\n\n\n  Note: As an alternative, you can try this other plugin too.\n\n\nExport to glTF from SketchUp\n\nSketchUp doesn’t support exporting to glTF by default, but you can install a plugin to enable it.\n\nDownload the plugin from this link.\n\nPreview a glTF model\n\nA quick and easy way to preview the contents of a glTF model before importing it into a scene is to use the Babylon.js Sandbox. Just drag and drop the glTF file (and its .bin file if applicable) into the canvas to view the model.\n\nIn the sandbox you can also view the animations that are embedded in the model, select which to display by picking it out of a dropdown menu.\n\n\n\nWhy we use glTF\n\nCompared to the older OBJ format, which supports only vertices, normals, texture coordinates, and basic materials,\nglTF provides a more powerful set of features that includes:\n\n\n  Hierarchical objects\n  Skeletal structure and animation\n  More robust materials and shaders\n  Scene information (light sources, cameras)\n\n\nCompared to COLLADA, the supported features are very similar. However, because glTF focuses on providing a\n“transmission format” rather than an editor format, it is more interoperable with web technologies.\n\nConsider this analogy: the .PSD (Adobe Photoshop) format is helpful for editing 2D images, but images must then be converted to .JPG for use\non the web. In the same way, COLLADA may be used to edit a 3D asset, but glTF is a simpler way of transmitting it while rendering the same result.\n\nConvert fbx into glTF\n\n.fbx is a very popular standard for 3D models. It’s not supported by our engine, but you can easily export an .fbx model to .gltf format.\n\nWe recommend using these tools:\n\n\n  \n    Facebook’s CLI tool: this is the most robust alternative, but requires using the command line.\n  \n  \n    Blackthread: This the most complete web based tool. Less robust than the CLI, but a lot easier to use.\n  \n  \n    Modelconverter: Another easy-to-use web based tool.\n  \n\n\nOptimize a glTF\n\nThe following tool offers some optimizations that will make 3D models lighter and faster to download for players in your scene.\n\nglTF pipeline\n\nAmong other things, it converts .gltf format into .glb, which is binary and so occupies a lot less. It also places texture files outside the 3D model, which allows you to use the same texture on multiple models.\n\n\n  Note: .glb format by default always has textures embedded in the file. The engine can’t recognize two embedded textures as the same, they need to be external files that share a same hash.\n\n\nSee also\n\nThe following pages also cover topics related to 3D models for Decentraland:\n\n\n  Materials\n  Meshes\n  Colliders\n  Animations"
        }
        
      
    
  
    
      
        ,
        
        "design-experience-design-games": {
          "id": "design-experience-design-games",
          "title": "Design constraints for games",
          "categories": "design-experience",
          "url": " /design-experience/design-games/",
          "content": "This document covers some key points to consider when designing a game for Decentraland. Considerations such as the adjacency of other scenes and the distributed ownership of the LAND make Decentraland a unique place that requires you to reconsider assumptions you may have from previous games.\n\nFor instance, you must understand that, unlike in other game platforms, Decentraland games don’t exist in a vacuum. You don’t have control over what’s in adjacent scenes, and you don’t have control over certain details like the player’s avatars or items they could bring in from other games. This opens the door to exciting possibilities, and requires you to think about game mechanics differently.\n\nThe closest thing in mainstream games right now is Roblox, where content that’s generated by users in the community can then be a meeting place for others to explore, play, and interact. Unlike Roblox, you navigate scenes not by browsing a menu of unrelated experiences but by physically exploring a terrain where all scenes are adjacent to each other. Decentraland also makes use of the blockchain as a way to manage ownership of land, avatars, assets, etc.\n\nWe’re continually improving the SDK, so some of the following limitations will be removed with future updates before Decentraland is opened to end users.\n\nScene boundaries\n\nYour game must fit entirely in the LAND that your scene is built upon. For small scenes, think of games like soccer where the rules of the game keep the relevant interaction within a confined space, even though players are able to step outside of the playing field. Players can walk outside of a scene’s boundaries, but any asset or entities that belong to the scene must stay within the scene.\n\nPlayers that step outside your scene keep rendering it as long as it’s at a visible range. If they walk away too far, they will stop rendering it entirely.\n\nYou could also build a game that spreads out throughout several disconnected plots of land that are unknown to players, and where the exploration of the rest of the world becomes part of the gameplay. A game like that would be made up of multiple separate scenes, that could share data with each other via a server.\n\nUser inventory\n\nThere currently isn’t an inventory where players can store game items as they walk between scenes. The following alternatives are available today:\n\n\n  You can store inventory information in the scene itself and link it to each player’s Ethereum address (this can be used as a persistent id). This information would only be readable from your scene.\n  You can use an external custom storage and sync all of your scenes to it. This is a more robust solution that can deal with larger volumes of players. It can also extend the access to this inventory to multiple separate scenes that you or others own.\n  Use tokens in the blockchain to handle the ownership of items.\n\n\nWhen earning a game item, it could be stored as a special token in a player’s Ethereum wallet. When a player that possesses the token walks into your scene, your scene could grant the player certain characteristics within the game.\n\nOther scenes could potentially also respond to the same token in different ways, which can make for interesting interplay between games.\n\nThe downside of using the blockchain to store inventory items is that all transactions have a cost for the player and aren’t immediate. Read more about the blockchain in a specialized section further below.\n\nIn future releases, players will have an inventory they carry everywhere which will include both on-chain and off-chain assets.\n\nPortable experiences\n\nPortable experiences are parts of the gameplay that players take with them as they move through the metaverse. For example, a player could take a snowball from your scene, walk away to another scene, and throw the snowball to another player who’s also playing the same game.\n\nSmart wearables are portable experiences that are turned on when the player puts on the item of clothing. Smart wearables can grant players new abilities, like a jetpack that lets them fly, or add a new layer of content on top of the rest of the world, like randomly placing coins to be collected throughout the whole of genesis city.\n\nKeep in mind that players might be using someone else’s portable experience while on your scene. See User Data to learn how to check what portable experiences a player currently has activated.\n\nGame Persistence\n\nDecentraland is a persistent world, your scene can be visited by players at any time. Your scene has no startup phase and no ending, so you should design the game mechanics in a way that allows players that walk in or out at any time to also participate.\n\nYour scene could have a reset mechanism that sets it to an initial state, but you should be careful not to disrupt the game for players who are already playing.\n\nSync scene state\n\nCurrently, scene states aren’t shared between players unless manually implemented. This is the simplest way to build a scene, but it’s not ideal for social experiences.\n\nScenes can share state information between players in a peer to peer manner. Peer to peer has the advantage of needing no servers, but it can lead to significant latency, as players could have poor internet connections or be geographically far away. If no players are currently near the scene and loading it, the scene will reset to a default state the next time it’s loaded.\n\nYou can host your own server to store information about your scene and keep all players in sync with it. This ensures good connection speeds and keeps the scene running continuously even when no players are near. If you do this, your latency limitations would be no different to any other massively played online games.\n\nHosting your own server is also a recommended safety measure for games that involve transactions with valuable game items, as peer to peer connections place trust in the player that assumes the role of server.\n\n\n  Note: In future releases, we will provide out-of-the-box solutions and code examples for how to implement your own server.\n\n\nGame timing\n\nGames that use peer to peer connections should take into account that there could be lag between players and shouldn’t rely on fast reactions between the actions of different players. We recommend games that are turn based, or that are mostly based on player versus environment interactions.\n\nFor games where the timing of actions between players is critical, like a first person shooter, you should implement your own server as a real-time authoritative source of truth between all players in your scene.\n\nPlayers in the scene\n\nPlayers are identified in Decentraland using their Ethereum wallet address. This wallet is used as a persistent ID that’s already associated with all of the tokens that the player owns.\n\nThere currently is no way to limit how many players can be present in Decentraland at the same time. Unlike a lot of other games where there may be different game sessions hosted in separate servers, there’s only one instance of Decentraland shared between all players, at least for now.\n\nYou need to keep in mind that there may be several players walking around your scene at any given time. Some of them might be walking through and not participating in the game. Make sure that the game mechanics can’t be easily disrupted by this.\n\nThe game loop of your scene can’t affect players directly, the scene has a reactive approach to the player’s actions. If a player is standing on an entity and the entity moves or rotates, the player will move with this entity. This is especially useful for elevators, floating platforms, and the like.\n\nAs the owner of a scene, you can’t forcefully push or teleport an offending player out of your scene. However, you will be able to blacklist players in the signaling server. You can also implement a blacklist in your scene’s code and deny certain services to blacklisted players.\n\nScene content limitations\n\nPlease build your scene being extra careful with the efficiency of your code. Decentraland needs to run on web browsers and mobile devices, and players will be rendering multiple scenes at the same time as they walk through the metaverse.\n\nYou should also try to keep the scene lightweight. Unlike other online games where the same textures and assets are conveniently repeated throughout a large open world, in Decentraland every scene could have its own completely different set of assets. As players walk through multiple scenes, they should be able to download the entirety of the scene content, including textures, sound files, etc at a reasonable speed.\n\nBecause of this, we’ve imposed some limits to prevent excessive use of computational resources. See scene limitations for details on what these limits are.\n\nAccess to scenes\n\nThe map of Decentraland is designed so that there are roads and public plazas, these guarantee easy access to various parts of the map, regardless of what other people build. Plots of land that are not adjacent to any road or plaza run the risk of being walled out by neighbouring scenes, although we expect most scenes to be walkable and not block others out.\n\nNew players will start their experience in Genesis Plaza, in the center of the map, where they will be encouraged to follow some tutorial activities and then to explore the world.\n\nPlayers can also manually type a URL for a specific coordinate in the Decentraland map to spawn to that location. You can also share links to URLs that have hard-coded initial coordinates.\n\nKeep in mind that if a player starts at a location that is walled out or below the level of the terrain, it won’t be a pleasant experience. To avoid this, there’s a way you can define a set of specific locations in your scene that is safe to spawn into. See scene metadata for details.\n\nIn future releases, players will also be able to navigate the world rapidly using maps with spawn points, lists of popular locations, and friend locations. The SDK will also make it possible to add teleports in your scene that can transport to other parts of the world.\n\nUser UI\n\nThe default overlaid UI that players see when entering Decentraland has only the essentials. You can add extra elements to that UI while a player is on your scene. Keep in mind that the Decentraland default UI is displayed above anything from your scene, so design your UI so that it doesn’t overlap with this.\n\nWhen a player steps outside the scene, all UI elements are removed to not intervene with other scenes. Players also have a button available in their screen to toggle all UI elements in the scene off, this is mainly useful to prevent abusive behavior by scenes that may want to cover all of the player’s field of view.\n\nPhysics\n\nKeep in mind that the SDK doesn’t provide its own physics engine. If you want to use physics in your scene, you can import a library or code the behavior yourself.\n\nController Inputs\n\nYour game controls should be limited to basic movements, jumping, point and click, as well as a primary and secondary button. We will support mobile and Virtual Reality controllers, so we can’t assume that everyone has a keyboard.\n\nWe have support for global button up and button down events for all three buttons. All three buttons also have hit events that let you identify if an entity was in the player’s aim.\n\nAvatars\n\nPlayers can build their avatars based on a set of default wearable items. We will expand the list of available wearables and options, and in the future we’ll also make it possible for third parties to create and sell wearables.\n\nCommunication between players\n\nUsers are able to chat with each other. Avatars currently have no way to convey body language beyond the use of basic movement controls.\n\nIn future releases they will also be able to do voice chat and to perform gestures like dancing or frowning with their avatars. They will also be able to display a temporary emoji above their avatar to express themselves. Players will also be able to display tokens they own so that other players can see them.\n\nGame notifications\n\nThere currently is no cross-scene notification system. Any game requiring notifications displayed outside of the current scene is going to have to implement them using an external service.\n\nUsing the blockchain\n\nIn Decentraland, the blockchain is used to store information about ownership. Today this mostly refers to LAND ownership, but it can also be used ownership of game items, wearables, special avatars, emotes, and tokens that can ensure certain game privileges or access to games.\n\nThe blockchain isn’t used to store the game state, player position or anything that needs to change in real time.\n\nLAND and MANA\n\nPlayers don’t need to own any parcels of land to participate in the metaverse. In fact, the vast majority of players won’t. Player avatars and the LAND tokens that they own aren’t connected in any direct way.\n\nPlayers don’t need to previously own an Ethereum wallet or MANA tokens to enter Decentraland. If your gameplay relies heavily on owning tokens, you would be excluding most players. A freemium game model could be an ideal way to tailor to both user bases.\n\nOther NFTs\n\nYou can use special non-fungible tokens (NFTs) to represent game items, custom avatars or wearables. If a player owns one of these tokens, your scene could respond to it in different ways.\n\nRead about what NFTs are in this blogpost.\n\nIn-game transactions\n\nYour scene can support blockchain transactions for players to buy or earn tokens.\n\nBlockchain transactions aren’t immediate, they require verification times and have a cost in Ether, both the time and cost vary depending on the current usage of the network.\n\nDecentraland is working on creating a side-chain that will be able to handle transactions faster and cheaper than the Ethereum network. This side-chain will be ideal for in-game transactions, as changes can occur closer to real time and at a very low cost. The main Ethereum chain will still be recommended for transactions that require higher security and that can afford to be more expensive and take longer.\n\nThe player must always approve these transactions explicitly on their Ethereum client. For example when using Metamask, Metamask prompts the player to accept each transaction before it’s processed.\n\nPlayers could also sign a contract that automatically approves all transactions requested by a specific address or within certain constraints, so as to avoid interruptions to approve transactions.\n\nYou can also use smart contracts to condition transactions based on custom conditions. For example, players could stake a bet on the outcome of a game, and the corresponding payments would occur automatically as soon as the outcome is known.\n\nAs a safety measure, we don’t recommend carrying out in-game transactions in scenes that are hosted peer to peer. Peer to peer connections place trust in the player that assumes the role of server.\n\nTo implement blockchain interactions in your scene’s code, you must use external libraries that interface with the Ethereum network. Future releases of the SDK will provide a custom API to expose these functionalities in a simpler way."
        }
        
      
    
  
    
      
        ,
        
        "development-guide-scene-blockchain-operations": {
          "id": "development-guide-scene-blockchain-operations",
          "title": "Scene blockchain operations",
          "categories": "development-guide",
          "url": " /development-guide/scene-blockchain-operations/",
          "content": "A Decentraland scene can interface with the Ethereum blockchain. This can serve to obtain data about the user’s wallet and the tokens in it, or to trigger transactions that could involve any Ethereum token, fungible or non-fungible. This can be used in many ways, for example to sell tokens, to reward tokens as part of a game-mechanic, to change how a player interacts with a scene if they own certain tokens, etc.\n\nThe following tools currently exist, all of them provided by Decentraland:\n\n\n\n\n  The Ethereum controller: A basic library that offers some limited but simple functionality.\n  The eth-connect library: A lower level library to interface with Ethereum contracts and call their functions, for example to trigger transactions or check balances.\n\n\nNote that all transactions triggered by a scene will require a player to approve and pay a gas fee.\n\nAll blockchain operations also need to be carried out as asynchronous functions, since the timing depends on external events.\n\nWhen running a preview of a scene that uses one of the ethereum libraries, you must have Metamask open in your browser and you must run the preview with:\n\ndcl start --web3\n\n\n\n\nEthereum controller library\n\nThe simplest way to perform operations on the Ethereum blockchain is through the ethereum controller library. This controller is packaged with the SDK, so you don’t need to run any manual installations.\n\nTo import the Ethereum controller into your scene file:\n\nimport * as EthereumController from \"@decentraland/EthereumController\"\n\n\nBelow we explain some of the things you can do with this controller.\n\nGet a player’s ethereum account\n\nUse the getUserAccount() function from the EthereumController to find a player’s Ethereum public key.\n\nimport { getUserAccount } from \"@decentraland/EthereumController\"\n\nexecuteTask(async () =&gt; {\n  try {\n    const address = await getUserAccount()\n    log(address)\n  } catch (error) {\n    log(error.toString())\n  }\n})\n\n\nAs shown in the example above, you should wrap the function in an async() function, learn more about this in async functions\n\nThe following example keeps track of provided addresses.\n\nimport { getUserAccount } from \"@decentraland/EthereumController\"\n\nlet registeredAddresses: String[] = []\n\nexecuteTask(async () =&gt; {\n  try {\n    const address = await getUserAccount()\n    let lowerCaseAddress = address.toLowerCase()\n    for (let i = 0; i &lt; registeredAddresses.length; i++) {\n      if (lowerCaseAddress == registeredAddresses[i]) {\n        log(\"already registered\")\n      } else {\n        registeredAddresses.push(lowerCaseAddress)\n      }\n    }\n  } catch (error) {\n    log(error.toString())\n  }\n})\n\n\n\n  Note: Even though the eth address may contain upper case characters, some browsers convert the returned string to lower case automatically. If you wish compare address values and have it work on all browsers, use the .toLowerCase() method to convert the value into lower case.\n\n\nSign messages\n\nA player can sign a message using their Ethereum public key. This signature is a secure way to give consent or to register an accomplishment or action that is registered with the block chain.\n\nThe signing of a message isn’t a transaction, so it doesn’t imply paying any gas fees on the Ethereum network, it does however open a pop-up to ask the player for consent.\n\nMessages that can be signed need to follow a specific format to match safety requirements. They must include the “Decentraland signed header” at the top, this prevents the possibility of any mismanagement of the player’s wallet.\n\nSignable messages should follow this format:\n\n# DCL Signed message\n&lt;key 1&gt;: &lt;value 1&gt;\n&lt;key 2&gt;: &lt;value 2&gt;\n&lt;key n&gt;: &lt;value n&gt;\nTimestamp: &lt;time stamp&gt;\n\n\nFor example, a signable message for a game might look like this:\n\n# DCL Signed message\nAttacker: 10\nDefender: 123\nTimestamp: 1512345678\n\n\nBefore a player can sign a message, you must first convert it from a string into an object using the convertMessageToObject() function, then it can be signed with the signMessage() function.\n\nimport * as EthereumController from \"@decentraland/EthereumController\"\n\nconst messageToSign = `# DCL Signed message\nAttacker: 10\nDefender: 123\nTimestamp: 1512345678`\n\nlet eth = EthereumController\n\nexecuteTask(async () =&gt; {\n  const convertedMessage = await eth.convertMessageToObject(messageToSign)\n  const { message, signature } = await eth.signMessage(convertedMessage)\n  log({ message, signature })\n})\n\n\nCheck if a message is correct\n\nTo verify that the message that the player signed is in fact the one that you want to send, you can use the toHex() function from eth-connect library, to convert it and easily compare it. See further below for instructions on how to import the eth-connect library.\n\nimport { toHex } from \"eth-connect\"\nimport * as EthereumController from \"@decentraland/EthereumController\"\n\nconst messageToSign = `# DCL Signed message\nAttacker: 10\nDefender: 123\nTimestamp: 1512345678`\n\nlet eth = EthereumController\n\nfunction signMessage(msg: string) {\n  executeTask(async () =&gt; {\n    const convertedMessage = await eth.convertMessageToObject(msg)\n    const { message, signature } = await eth.signMessage(convertedMessage)\n    log({ message, signature })\n\n    const originalMessageHex = await toHex(msg)\n    const sentMessageHex = await toHex(message)\n    const isEqual = sentMessageHex === originalMessageHex\n    log(\"Is the message correct?\", isEqual)\n  })\n}\n\nsignMessage(messageToSign)\n\n\nRequire a payment\n\nThe requirePayment() function prompts the player to accept paying a sum to an Ethereum wallet of your choice.\n\nPlayers must always accept payments manually, a payment can never be implied directly from the player’s actions in the scene.\n\neth.requirePayment(receivingAddress, amount, currency)\n\n\nThe function requires that you specify an Ethereum wallet address to receive the payment, an amount for the transaction and a specific currency to use (for now only ETH is supported).\n\nIf accepted by the player, the function returns the hash number of the transaction.\n\n\n  Warning: This function informs you that a transaction was requested, but not that it was confirmed. If the gas price is too low, or it doesn’t get mined for any reason, the transaction won’t be completed.\n\n\nconst myWallet = ‘0x0123456789...’\nconst enterPrice = 0.05\n\nfunction payment(){\n  executeTask(async () =&gt; {\n    try {\n      await eth.requirePayment(myWallet, enterPrice, 'ETH')\n      openDoor()\n    } catch {\n      log(\"failed process payment\")\n    }\n  })\n}\n\nconst button = new Entity()\nbutton.addComponent(new BoxShape())\nbutton.addComponent(new OnClick( e =&gt; {\n    payment()\n  }))\nengine.addEntity(button)\n\n\nThe example above listens for clicks on a button entity. When clicked, the player is prompted to make a payment in ETH to a specific wallet for a given amount. Once the player accepts this payment, the rest of the function can be executed. If the player doesn’t accept the payment, the rest of the function won’t be executed.\n\n\n\n\n  Tip: We recommend defining the wallet address and the amount to pay as global constants at the start of the .ts file. These are values you might need to change in the future, setting them as constants makes it easier to update the code.\n\n\n\n\nAsync sending\n\nUse the function sendAsync() to send messages over RPC protocol.\n\nimport * as EthereumController from \"@decentraland/EthereumController\"\n\n// send a message\nawait eth!.sendAsync(myMessage)\n\n\nLower level operations\n\nThe eth-connect library is made and maintained by Decentraland. It’s based on the popular Web3.js library, but it’s fully written in TypeScript and features a few security improvements.\n\nThis controller operates at a lower level than the Ethereum controller (in fact the Ethereum controller is built upon it) so it’s tougher to use but more flexible.\n\nIt’s main use is to call functions in a contract, it also offers a number of helper functions for various tasks. Check it out on GitHub.\n\n\n  Note: The eth-connect library is currently lacking more in-depth documentation. Since this library is mostly based on the Web3.js library and most of the function names are intentionally kept identical to those in Web3.js, it can often help to refer to Web3’s documentation.\n\n\nDownload and import the eth-connect library\n\nTo use eth-connect library, you must manually install the package via npm in your scene’s folder. To do so, run the following command in the scene folder:\n\nnpm install eth-connect -B\n\n\n\n  Note: Decentraland scenes don’t support older versions than 4.0 of the eth-connect library.\n\n\n\n  Note: Currently, we don’t allow installing other dependencies via npm that are not created by Decentraland. This is to keep scenes well sandboxed and prevent malicious code.\n\n\nOnce installed, you can import whatever you need from eth-connect to the scene’s code:\n\nimport { toHex } from \"eth-connect\"\n\n\nImport a contract ABI\n\nAn ABI (Application Binary Interface) describes how to interact with an Ethereum contract, determining what functions are available, what inputs they take and what they output. Each Ethereum contract has its own ABI, you should import the ABIs of all the contracts you wish to use in your project.\n\nFor example, here’s an example of one function in the MANA ABI:\n\n{\n  anonymous: false,\n  inputs: [\n    {\n      indexed: true,\n      name: 'burner',\n      type: 'address'\n    },\n    {\n      indexed: false,\n      name: 'value',\n      type: 'uint256'\n    }\n  ],\n  name: 'Burn',\n  type: 'event'\n}\n\n\nABI definitions can be quite lengthy, as they often include a lot of functions, so we recommend pasting the JSON contents of an ABI file into a separate .ts file and importing it into other scene files from there. We also recommend holding all ABI files in a separate folder of your scene, named /contracts.\n\nimport { abi } from \"../contracts/mana\"\n\n\nHere are links to different Decentraland contracts. Obtain the ABI for each contract by clicking Export ABI and choosing JSON Format.\n\n\n  MANA Token ABI\n  Decentraland Marketplace\n  LAND ABI\n  Estate ABI\n  AvatarNameRegistry ABI\n  Catalyst ABI\n\n\nThese are the contracts for the various wearable collections: (each collection was emitted as a separate contract)\n\n\n  ExclusiveMasksCollection ABI\n  Halloween2019Collection ABI\n  Halloween2019CollectionFactory ABI\n  Xmas2019Collection ABI\n  MCHCollection ABI\n  CommunityContestCollection ABI\n  DCLLaunchCollection ABI\n  DCGCollection ABI\n\n\n\n  TIP: To clearly see the functions exposed by a contract, open it in abitopic.io. Just paste the contract address there and open the functions tab to see the full list of supported functions and their arguments. You can even test calling the functions with different parameters via the webpage.\n\n\nConfiguring TypeScript to be able to import from a JSON file has its difficulties. The recommended easier workaround is to change the ABI.JSON file’s extension to .ts and modifying it slightly so that it its content starts with export default.\n\nFor example, if the ABI file’s contents starts with [{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\" ...etc, modify it so that it starts with export default [{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\" ...etc.\n\nInstance a contract\n\nAfter importing the eth-connect library and a contract’s abi, you must instance several objects that will allow you to use the functions in the contract and connect to Metamask in the player’s browser.\n\nYou must also import the web3 provider. This is because Metamask in the player’s browser uses web3, so we need a way to interact with that.\n\nimport { RequestManager, ContractFactory } from \"eth-connect\"\nimport { abi } from \"../contracts/mana\"\nimport { getProvider } from \"@decentraland/web3-provider\"\n\nexecuteTask(async () =&gt; {\n  // create an instance of the web3 provider to interface with Metamask\n  const provider = await getProvider()\n  // Create the object that will handle the sending and receiving of RPC messages\n  const requestManager = new RequestManager(provider)\n  // Create a factory object based on the abi\n  const factory = new ContractFactory(requestManager, abi)\n  // Use the factory object to instance a `contract` object, referencing a specific contract\n  const contract = (await factory.at(\n    \"0x2a8fd99c19271f4f04b1b7b9c4f7cf264b626edb\"\n  )) as any\n})\n\n\nNote that several of these functions must be called using await, since they rely on fetching external data and can take some time to be completed.\n\n\n  Tip: For contracts that follow a same standard, such as ERC20 or ERC721, you can import a single generic ABI for all. You then generate a single ContractFactory object with that ABI and use that same factory to instance interfaces for each contract.\n\n\nCall the methods in a contract\n\nOnce you’ve created a contract object, you can easily call the functions that are defined in its ABI, passing it the specified input parameters.\n\nimport { getProvider } from \"@decentraland/web3-provider\"\nimport { getUserAccount } from \"@decentraland/EthereumController\"\nimport { RequestManager, ContractFactory } from \"eth-connect\"\nimport { abi } from \"../contracts/mana\"\n\nexecuteTask(async () =&gt; {\n  try {\n    // Setup steps explained in the section above\n    const provider = await getProvider()\n    const requestManager = new RequestManager(provider)\n    const factory = new ContractFactory(requestManager, abi)\n    const contract = (await factory.at(\n      \"0x2a8fd99c19271f4f04b1b7b9c4f7cf264b626edb\"\n    )) as any\n    const address = await getUserAccount()\n    log(address)\n\n    // Perform a function from the contract\n    const res = await contract.setBalance(\n      \"0xaFA48Fad27C7cAB28dC6E970E4BFda7F7c8D60Fb\",\n      100,\n      {\n        from: address,\n      }\n    )\n    // Log response\n    log(res)\n  } catch (error) {\n    log(error.toString())\n  }\n})\n\n\nThe example above uses the abi for the Ropsten MANA contract and transfers 100 fake MANA to your account in the Ropsten test network.\n\nOther functions\n\nThe eth-connect library includes a number of other helpers you can use. For example to:\n\n\n  Get an estimated gas price\n  Get the balance of a given address\n  Get a transaction receipt\n  Get the number of transactions sent from an address\n  Convert between various formats including hexadecimal, binary, utf8, etc.\n\n\n\n\n\n\n\n\nUsing the Ethereum test network\n\nWhile testing your scene, to avoid transferring real MANA currency, you can use the Ethereum Ropsten test network and transfer fake MANA instead.\n\nTo use the test network you must set your Metamask Chrome extension to use the Ropsten test network instead of Main network.\n\nYou must also own MANA in the Ropsten blockchain. To obtain free Ropsten mana in the test network, go to our MANA faucet.\n\n\n  Tip: To run the transaction of transferring Ropsten MANA to your wallet, you will need to pay a gas fee in Ropsten Ether. If you don’t have Ropsten Ether, you can obtain it for free from various external faucets like this one.\n\n\nTo preview your scene using the test network, add the DEBUG property to the URL you’re using to access the scene preview on your browser. For example, if you’re accessing the scene via http://127.0.0.1:8000/?position=0%2C-1, you should set the URL to http://127.0.0.1:8000/?DEBUG&amp;position=0%2C-1.\n\nAny transactions that you accept while viewing the scene in this mode will only occur in the test network and not affect the MANA balance in your real wallet."
        }
        
      
    
  
    
      
        ,
        
        "examples-builder-video-tutorials": {
          "id": "examples-builder-video-tutorials",
          "title": "Builder Video Tutorials",
          "categories": "examples",
          "url": " /examples/builder-video-tutorials/",
          "content": "Builder 101\n\nThis video shows you the basics of how to use the Builder.\n\n\n\t\n\n\nImporting 3D models\n\nImport your own 3D models to use in your Builder scenes.\n\n\n\t\n\n\nUsing smart items\n\nUse smart items to make your scenes interactive."
        }
        
      
    
  
    
      
        ,
        
        "examples-sample-scenes": {
          "id": "examples-sample-scenes",
          "title": "SDK Scene examples",
          "categories": "examples",
          "url": " /examples/sample-scenes/",
          "content": "To get you up and running, and to illustrate what kind of experiences you can build using the SDK, we’ve put together some code and scene examples.\n\nSome of these scenes feature a link to a version of the scene that’s deployed on a remote server. There you can interact with it just as if you were running dcl start locally.\n\nClone an example scene\n\nInstead of creating a new scene from scratch, you can clone one of the existing example scenes and use that as a starting point.\n\nTo do so:\n\n\n  Find an example you like from the ones listed below.\n  Open the Code link to visit its GitHub repo.\n  From there you can either:\n    \n      Fork the repo to work on your own version of it, that will exist in a cloned GitHub repo that belongs to you.\n      Click Clone or Download and select to download it as a .zip file, to work on the files locally, without GitHub being involved.\n    \n  \n\n\nEssentials\n\nShark animation\n\nThis simple scene shows how to add animations to a GLTFComponent and handle click events.\n\n\n  glTF models\n  animations\n  click events\n\n\n\n\nCode\n\nExplore the scene\n\nPuffer fish\n\nThis simple scene shows how to use the utils library to scale an entity gradually.\n\n\n  glTF models\n  scaling an entity\n  delaying a function\n  adding a sound clip\n\n\n\n\nCode\n\nExplore the scene\n\nHypno wheels\n\nThis simple scene features a couple of wheels that you can spin by clicking them.\n\n\n  rotate an entity\n  glTF models\n  click events\n  textures\n  custom components\n  component groups\n\n\n\n\nCode\n\nExplore the scene\n\nRead a tutorial blog post about this scene.\n\nOpen the door\n\nA simple interactive scene with a door that can be opened and closed.\n\n\n  Slerp() function for rotation\n  click events\n  materials\n  parent entities\n  custom components\n  component groups\n\n\n\n\nCode\n\nExplore the scene\n\nSliding door\n\nA simple interactive scene with a two-sided door that can be opened by clicking.\n\n\n  Lerp() function for moving\n  click events\n  materials\n  parent entities\n  custom components\n  component groups\n\n\n\n\nCode\n\nExplore the scene\n\nJukebox\n\nA scene where you can play different songs by pressing buttons on a jukebox.\n\n\n  audio\n  glTF models\n  Lerp() function for moving\n  click events\n  materials\n  parent entities\n  custom components\n  component groups\n\n\n\n\nCode\n\nExplore the scene\n\nBasic interactions\n\nA scene with a simple example of each way in which players can interact. Each shape’s color is activated by interacting with it.\n\n\n  Click events\n  PointerUp and PointerDown events\n  Player position\n  Global pointer events\n  Animations\n\n\n\n\nCode\n\n\n\nDance floor\n\nA scene with animations, sound, and tiles on the floor that randomly change color to the beat.\n\n\n  audio\n  glTF models\n  animations\n  materials\n  custom components\n  component groups\n\n\n\n\nCode\n\nExplore the scene\n\nSmoke\n\nThis scene shows how to handle a particle system to create smoke. Each smoke puff is an entity that moves in a specific direction. These entities are reused from an object pool instead of creating a new entity for each. When an entity floats away from the fire, it’s removed from the scene and waits in the object pool to be reused.\n\n\n\nCode\n\nExplore the scene\n\nMemory game\n\nA Simon Says game, with click interactions and sequenced actions. The game generates a random sequence of colors and you must click buttons to match those.\n\n\n  glTF models\n  materials\n  click events\n  custom components\n  component groups\n\n\n\n\nCode\n\nExplore the scene\n\nMovement\n\nHummingbirds\n\nA scene where hummingbirds spawn when you click a tree. Each bird moves on its own to random positions.\n\n\n\nCode\n\nExplore the scene\n\nGnark patrolling\n\nA scene that shows a character walking along a fixed path, using lerp over each segment of the path. If you approach it, it will switch to yelling at you.\n\n\n\nCode\n\nExplore the scene\n\nRead a tutorial blog post about this scene:\n\n\n  Part 1\n  Part 2\n\n\nSwimming shark\n\nThis scene shows a shark moving around in circles along a curved circular path, using lerp over each segment of the path. It also rotates smoothly with a spherical lerp function.\n\nThe speed of the shark and the intensity with which it swims depends on the steepness of the segment.\n\n\n\nCode\n\nExplore the scene\n\nNetwork connections\n\nWeather simulation\n\nA scene that checks a weather API for the weather in a location and displays that weather condition, showing rain, thunder or snowflakes\nUse real weather data from different locations by changing the coordinates, or change the value of the “fakeWeather” variable to see different weather conditions manifest.\n\n\n  Call external REST API\n\n\n\n\nCode\n\nExplore the scene\n\nRemote door\n\nA scene that uses a server and a REST API to sync a scene state amongst multiple players. It’s built around the basic “open the door” example.\n\n\n  Create a REST server\n  Call REST API\n\n\n\n\nCode\n\n\n\nRemote mural\n\nA scene that uses a server and a REST API to sync a scene state amongst multiple players. You can paint pixels in a mural that other players can see. The colors of each pixel are stored in a remote server.\n\n\n  Create a REST server\n  Call REST API\n\n\n\n\nCode\n\n\n\nPicture frame\n\nA scene that displays a crypto collectible NFT in a picture frame. See display a certified NFT for more details.\n\n\n\nCode\n\nCustom UI\n\nMining rocks\n\nA simple scene that shows how to build a custom UI that can be interacted with by the player and that is upated as the player interacts with the world\n\nCode\n\nExplore the scene\n\nBlockchain transactions\n\nMANA Transfer\n\nA simple scene that uses the MANA smart contract and the EthConnect library to send the player MANA on the Ropsten test network.\n\nCode\n\nExplore the scene\n\nMANA Burning Altar\n\nFees collected by the Marketplace are stored in a wallet. This scene interacts with the MANA contract to burn this MANA that was collected.\n\nThe flame is created as a particle system, handling various entities that spiral around as they change colors.\n\n\n\nCode\n\nExplore the scene\n\nAdvanced\n\nBlock Dog\n\nA scene with a simple AI character. It randomly chooses what action to take: follow you, sit or remain idle. You can also tell it to sit or stand up by clicking it, or tell it to drink water by clicking its bowl.\n\n\n\nCode\n\nExplore the scene\n\nEscape room\n\nA full escape room game, where each room is a puzzle to be interacted with in different ways.\n\nThis scene is showcased by a video tutorial series that walks you through all the mechanics, starting from the basic concepts.\n\n\n\nCode\n\nTower defense game (WIP)\n\nA fully-fledged game where a random 2d path is generated along which enemies walk, and where traps are randomly placed. You need to activate the traps as the enemies advance along the path to kill them. It’s all about timing.\n\n\n\nCode\n\n\n\nCastaway 2048 (WIP)\n\nA fully fledged game, based on the popular game 2048, where the values are represented by a series of gems of increasing values. Click and drag to displace the gems on the board and merge them into greater values till you reach 2048.\n\n\n\nCode"
        }
        
      
    
  
    
      
        ,
        
        "development-guide-publishing": {
          "id": "development-guide-publishing",
          "title": "Publishing a scene",
          "categories": "development-guide",
          "url": " /development-guide/publishing/",
          "content": "Before you begin\n\nMake sure of the following:\n\n\n  \n    Your scene complies with all of the scene limitations. Most of these are validated each time you run a preview of your scene.\n  \n  \n    You have a Metamask account, with your LAND parcels assigned to it.\n  \n  \n    You own the necessary amount of adjacent LAND parcels. Otherwise you can purchase LAND in the Market.\n  \n\n\n\n  Note: Multi-parcel scenes can only be deployed to adjacent parcels.\n\n\nCheck scene data\n\nWhen deploying, the CLI reads information from the scene.json to know where to deploy your scene to.\n\nOpen your scene’s scene.json file and complete the following data:\n\n\n  \n    title: The title is displayed on the UI under the mini-map, whenever players enter your scene. It also shows on the teleport popup.\n  \n  \n    description: A description of what players will find in your scene. This is displayed on the teleport popup.\n  \n  \n    navmapThumbnail: An image that represents your scene. This is displayed on the teleport popup. The image should be a .png or .jpg image of a recommended size of 228x160 pixels.\n  \n  \n    Parcels: The coordinates of the parcels that will be occupied by your scene\n  \n  \n    Base: The coordinates of the parcel that will be considered the [0,0] coordinate of the scene. If your scene has multiple parcels, it should be the bottom-left (South-West) parcel.\n  \n  \n    spawnPoints: A set of coordinates inside the scene (relative to the scene’s base parcel) where players spawn into. By default players spawn onto the 0,0,0 location of the scene (bottom-left corner). Use this to start out in a specific location, set a region to prevent players from overlapping with each other when they first appear.\n  \n\n\n\n  Note: See scene metadata for more details on how to set these parameters.\n\n\nTo publish the scene\n\n\n  Log into your Metamask account with the same public address associated with your parcels in Decentraland.\n  Run dcl deploy from the scene’s folder.\n    \n      Tip: If there are files in your project folder that you don’t want to deploy, list them in the .dclignore file before deploying.\n    \n  \n  A browser tab will open, showing what parcels you’re deploying to. Click Sign and Deploy.\n  Metamask opens, notifying you that your signature is requested. Click Sign to confirm this action.\n\n\n\n  Tip: If you’re implementing a continuous integration flow, where changes to your scene are deployed automatically, then you can set the export DCL_PRIVATE_KEY environment variable to the private key of an account that has deploy permissions.\n\n\n\n  Tip: dcl deploy runs a dcl build, which checks the scene for type errors more strictly than running dcl start. If these errors can’t be avoided (eg: they happen in an external library) and they don’t impact the scene, you can use dcl deploy  --skip-build  to skip the dcl build step and deploy the scene as it is.\n\n\nPublish from a physical Ledger device\n\nInstead of storing your LAND tokens in a Metamask account, you may find it more secure to store them in a Ledger device that’s physically plugged in to your computer.\n\nIf you’re using one of these, the process of uploading content to your LAND is slightly different.\n\n\n  Plug your Ledger device in. Your parcels in Decentraland should be associated with that same wallet.\n  \n    Run dcl deploy --https from the scene’s folder.\n\n    \n      Tip: If there are files in your project folder that you don’t want to deploy, list them in the .dclignore file.\n    \n  \n  \n    A browser tab will open, showing what parcels you’re deploying to. Click Sign and Deploy.\n\n    \n      Note: Currently, the certificate is self-signed, so your browser might give you a warning before launching the page. The warning is displayed only because the certificate is self-signed by your machine, please ignore it and carry on.\n    \n  \n  The Ledger device will then ask you for a confirmation, which you must give by pushing the device’s buttons.\n\n\nScene overwriting\n\nWhen a new scene is deployed, it overwrites older content that existed on the parcels it occupies.\n\nIf a scene that takes up multiple parcels is only partially overwritten by another, all of its parcels are either overwritten or erased.\n\nSuppose you deployed your scene A over two parcels [100, 100] and [100, 101]. Then you sell parcel [100, 101] to a user who owns adjacent land and that deploys a large scene (B) to several parcels, including [100, 101].\n\nYour scene A can’t be partially rendered in just one parcel, so [100, 100] won’t display any content. You must build a new version of scene A that only takes up one parcel and deploy it to only parcel [100, 100].\n\nWhat are the content servers\n\nThe content servers are a network of community-owned servers with a filesystem that’s content-addressed, meaning that each file is identified by its contents, not by an arbitrary file name.\n\nWe use the content servers to host and distribute all scene content in a similar way to BitTorrent, keeping the Decentraland network distributed.\n\n\n  The content servers store and distribute all of the assets required to render your scenes.\n  The dcl deploy command links these assets to the LAND parcel specified in your scene.json file. Whenever you redeploy your scene, the CLI will update your LAND smart contract, if needed, to point to the most recent content available on the content servers.\n\n\nThe information on each copy of the server is verifiable, as each scene is signed by the LAND owner’s hash. This means that someone hosting a copy of the server won’t be able to tamper with the content to display something illegitimate. The community can also vote to approve or remove any of these servers using the DAO.\n\nThe test server\n\nYou can deploy content to the test catalyst server to run full tests with multiple users, the sourrounding scenes, and an environment that is identical to production. The test server is identical to all other catalyst servers, the difference is that the content that is deployed to this server isn’t propagated to the others. Content deployed to other servers on the other hand does get propagated to this server, so surrounding scenes should look as they will in production.\n\nTo deploy to the test server, run:\n\ndcl deploy --target peer-testing.decentraland.org\n\n\n  Note: The same permissions apply as in production. You must be owner or have permissions on the parcels that you’re deployng to.\n\n\nPlayers are never directed to this server, the only way to access it is to explicitly provide a URL parameter to connect to it.\n\nTo enter the content server, add &amp;CATALYST=peer-testing.decentraland.org to the Decentraland URL\n\nplay.decentraland.org/&amp;CATALYST=peer-testing.decentraland.org\n\nIf you’re working in a confidential project that you don’t want to unveil until launch, note that the test server is relatively hidden from players, but anyone explicitly using the test server’s URL could potentially run into it."
        }
        
      
    
  
    
      
        ,
        
        "development-guide-scene-limitations": {
          "id": "development-guide-scene-limitations",
          "title": "Scene limitations",
          "categories": "development-guide",
          "url": " /development-guide/scene-limitations/",
          "content": "In order to improve performance in the metaverse, we have established a set of limits that every scene must follow. If a\nscene exceeds these limitations, then the parcel won’t be loaded and the preview will display an error message.\n\nFor a straight-forward reference of what limitations you’ll have for a specific number of parcels, check the following table:\n\nReference table\n\nScene limitation rules\n\nBelow are the maximum number of elements allowed allowed in a scene:\n\n\n  n represents the number of parcels that a scene occupies.\n\n\n\n  Triangles: n x 10000 Total amount of triangles for all the models in the scene.\n  Entities: n x 200 Amount of entities in the scene.\n  Bodies: n x 300 Amount of meshes in the scene.\n  Materials: log2(n+1) x 20 Amount of materials in the scene. It includes materials imported as part of models.\n  Textures: log2(n+1) x 10 Amount of textures in the scene. It includes textures imported as part of models.\n  \n    Height: log2(n+1) x 20 Height in meters.\n\n    \n      Note: Only entities that are currently being rendered in the scene are counted for these limits. If your scene switches between 3D models, what matters is the rendered models at any point in time, not the total sum. Player avatars and any items brought by a player from outside the scene don’t count for calculating these limits either.\n    \n  \n  \n    File size: 15 MB per parcel Total size of the files uploaded to the content server. Includes 3D models and audio. Doesn’t include files that aren’t uploaded, such as node.js packages.\n  \n  File count: 200 files per parcel Total count of the files uploaded. Includes 3D models and audio. Doesn’t include files that aren’t uploaded, such as node.js packages.\n\n\n\n\nScene boundaries\n\nWhen running a preview, any content that is located outside the parcel boundaries is highlighted in red when rendered. If any content is outside these boundaries, you won’t be allowed to deploy this scene to Decentraland.\n\nIf the tip of a large object leaves the boundaries, this object is considered out of bounds too.\n\nA single parcel scene measures 16 meters x 16 meters. If the scene has multiple parcels, the dimensions vary depending on the arrangement of the parcels.\n\nIt’s possible to position entities underground, to either hide them or to have only a portion of them emerge. A scene can’t have tunnels that go below the default ground height, players can’t travel below the y = 0 height.\n\nShader limitations\n\n3D models used in decentraland must use supported shaders and materials. See 3D model materials for a list of supported shaders.\n\nLighting\n\nThe scene’s lighting conditions can’t be changed from the default setting.\n\nTexture size constraints\n\nTexture sizes must use width and height numbers (in pixels) that match the following numbers:\n\n1, 2, 4, 8, 16, 32, 64, 128, 256, 512\n\n\n\n  This sequence is made up of powers of two: f(x) = 2 ^ x . 512 is the maximum number we allow for a texture size. This is a fairly common requirement among other rendering engines, it’s there due internal optimizations of the graphics processors.\n\n\nThe width and height don’t need to have the same number, but they both need to belong to this sequence.\n\nThe recommended size for textures is 512x512, we have found this to be the optimal size to be transported through domestic networks and to provide reasonable loading/quality experiences.\n\nExamples of other valid sizes:\n\n32x32\n64x32\n512x256\n512x512\n\n\n\n  Note: Although textures of arbitrary sizes sometimes work, they are also often rendered with bugs and are more unstable. We strongly advise that all your textures match these sizes."
        }
        
      
    
  
    
      
        ,
        
        "design-experience-mvp-guidelines": {
          "id": "design-experience-mvp-guidelines",
          "title": "Scene MVP Guidelines",
          "categories": "design-experience",
          "url": " /design-experience/mvp-guidelines/",
          "content": "The purpose of this document is to help guide you through the process of building the first iterations of scenes in Decentraland. We’ll refer to these as a Minimum Viable Product (MVP).\n\nWhen creating the Minimum Viable Product (MVP) for your scene, you need to think about two areas of focus:\n\n\n  The basic user experience and functionality of your project.\n  The creation of a basic “pipeline”, or team workflow and content management system for building your experience and iteratively improving it.\n\n\nAn MVP should not try to demonstrate every possible outcome of every possible experience. Instead, an MVP should be the best first impression of your experience that you can make using Decentraland’s SDK.\n\nIt is important to consider your own limitations, how you plan to provide content to your users, and the expectations of your users. Approaching your MVP in this way requires three different perspectives:\n\n\n  As a developer or producer, how do I deliver an experience to my user/player?\n  As a user or player, what do I expect from this experience?\n  As a contributor or stakeholder, how do I contribute to the pipeline or experience?\n\n\nIt’s important to distinguish this approach from traditional agile development, because you may have to use non-optimum methods to meet your design goals.\n\nYou will have to examine your own goals in the context of your users’ expectations to decide if a certain release is focused more on the player, the pipeline and content contributors, or little of both.\n\nWhen planning each release, it is critical that you conscientiously and deliberately set your priorities according to each of these three perspectives.\n\nYou can expect your development backlog to follow two tracks:\n\n\n  The backlog of user experiences you want to create.\n  The development of the tools and interfaces needed to build your delivery pipeline. (Or to optimize your existing pipeline for contributors as well as your development team.)\n\n\nThese two tracks will also follow two different approaches to testing:\n\n\n  Testing your user experiences is more akin to traditional user interface testing, and does not require the same scripting resources.\n  Testing your tools and pipeline interfaces will require more technical resources.\n\n\nThe sooner you can get a value proposition in front of your user or player, the sooner you can get feedback to either confirm or reject that proposition. Confirming value quickly is critical. Many experienced developers will share stories of how they were certain beyond a shadow of a doubt of how amazing a new mechanic would be until they used it and it felt awkward and glitchy, the players didn’t respond to it at all, or it didn’t solve a consumer want/need. You want to fail quickly with as little effort as possible, so that you can learn from your failure and plan the next iteration.\n\nHow do you fail quickly? You do the minimum needed to get your player to touch your product.\n\n\n\nFactors for Minimum Viable Products\n\nHere is the list of factors to consider for your basic MVP. It is acceptable to state that you will use something as a placeholder and will then phase it out as you develop a more solid replacement.\n\n\n  \n    Art Creation\n\n    \n      First, begin with basic still images\n      Your first test should be for style: does the style you’ve chosen appeal to your users?\n      This could be the start of a style guide to provide to an outsourced artist\n    \n  \n  \n    Scene Creation\n\n    \n      Develop a basic sense of your space\n      Player should feel they are in a new, unique space\n      Delineate your space from neighboring spaces\n      Borders are evident and obvious – if only by a drawn line\n      Cover entire area with static content/art\n    \n  \n  \n    Art Rendered in Scene\n\n    \n      Using billboards is ok or other signage (this could simply be actual billboards or more sophisticated camera facing sprites)\n      Establish the tone and aesthetics of your space (i.e. style, bright, dark)\n      Note your process: how was art created and deployed into the scene?\n      How do you want to organize your art files for repeated deployment?\n    \n  \n  \n    Player experience\n\n    \n      Players are able to visit your space/scene\n      Players can distinguish your space from neighboring spaces\n    \n  \n  \n    Pipeline Goals\n\n    \n      Deploy sample static scene: no interaction with player\n      Deploy animated scene: elements like water fountains or waving flags loop their animations\n      Deploy interactive scene: including player engagement\n      Demonstrate deploy pipeline by re-deploying content: from art creation to in scene including scripting + QA]\n      Expose pipeline gaps: identify the unknowns in specific content deployment areas\n    \n  \n\n\nLevels of prototypes\n\nFailing quickly allows you to develop your experience by creating successive prototypes, with each iteration building upon the last.\n\nStart with a single player prototype. Then you can plan for scripting multiplayer interactions. Finally, you can tackle your persistent core loop that demonstrates transactional layers.\n\nWhat’s a persistent core loop?\n\nIn game design, a persistent core loop is the fundamental “game loop” that drives player actions and the game’s response to those actions. These persistent loops extend to any form of virtual experience (like those provided by Districts).\n\n\n  Note: The Decentraland client borrows some architectural ideas from React.js and only renders a scene when a change has taken place, not at a constant rate.\n\n\nWhat are transactional layers?\n\nThe transactional layers are the interfaces between systems like an update to the blockchain or another application that has been interfaced with your experience to maintain a persistent record of player actions. Creating and maintaining this persistent record is what builds a more personal experience.\n\nWe recommend creating your MVP as a single player experience.\n\nFor example, you could design a scene with the following successive experiences:\n\n\n  A single player can enter the world.\n  The player can interact with one or two simple entities within the scene.\n  Other players can join and interact with the world and the other player.\n  Finally, you can add the ability to remember that each player entered the scene, and to track the players’ events and activities.\n\n\nHow to share your MVP\n\nAlthough the Decentraland world is not yet open to all, you can upload a scene preview to a server and easily share a link to it with people who can give you feedback.\n\nEven once Decentraland is made available to all, we still recommend testing changes with test users in a separate preview server first, before uploading a new version of your scene to Decentraland.\n\nRead this blogpost for details on how to upload your scene preview to a free server.\n\nAdditional considerations\n\nOnce basic use cases are covered, you can start to get more sophisticated with your release management strategy by focusing on mechanics. Mechanics are a broad term covering all of the actions a player can take and the responses the system will provide based on those player actions.\n\n\n\nDevice interoperability is an important thing to be aware of. Users of your scene may be accessing your scene using a desktop, a mobile device or a VR headset. Users should be able to interact with your scene reasonably well using either. For those using a VR headset try to avoid dizzying movements that could cause motion sickness.\n\nAudio is another critical aspect of a scene’s atmosphere. Background sounds like wind, crickets, distant conversations, maybe even music can be a very powerful way to increase immersion and give context. You can also change how volume levels relate to distance from the sound source to put more or less emphasis on a sound’s location.\n\nRead design constraints for games for a detailed look at a number of other considerations.\n\nConsider the MVP as one of many prototypes that you can use to establish your cadence for releases once you have established your pipeline. The focus of each release may vary, or it may be a hybrid of each aspect of the experience. However, you should aim to deliver successively more complicated experiences, each iteration building upon the last.\n\n\n  MVP: Single player\n  Release 2: Add multiplayer and/or interaction support\n  Release 3: Introduce your first mechanic\n  Release 4: Add audio support\n  Release 5: Finalize your art pipeline\n\n\nFor example, let’s say we are building an MVP for a Frisbee golf game. The MVP will include some still images of the course. The player may even be able to throw a disc, in a very rudimentary, block-style fashion. This allows us to work out our basic throwing mechanics. The next release may include a prototype for multiplayer support so we can demo and test two users logged in and playing on our LAND at the same time.\n\nRemember, while the end goal is a truly immersive 3D world, that is not where your MVP will start. Getting a player into your world as quickly as possible should be your first goal. Taking weeks, not months, to test your releases is critical to learning and iterating without wasting effort.\n\nWe strongly recommend that you stay mindful of the first impression your experience presents. An empty experience will leave players disappointed. On the other hand, a scene with some initial content and basic experiences shows players the potential for what is to come and encourages them to engage with your community and return to the next few releases.\n\n\n\nPersistence factors to consider\n\nUltimately, you want reach a level of persistence where you can demonstrate that the transactional layers of your architecture are operational. Transactional is not limited to the players actions, but also the system’s reactions to players.\n\n\n  Account information: login name, time zone, location for your specific experience/game\n  Leaderboard stats: previous game play results, global/regional standings, competitions\n  Identity validation: Ethereum wallet address, or any other backend identity management\n  Blockchain updates: as required based on your experience/game to update the blockchain ledger for transactional transparency\n  Runtime persistence: temporary data for persistence across a potentially distributed platform (i.e. health for just the single game experience)"
        }
        
      
    
  
    
      
        ,
        
        "builder-scene-limitations": {
          "id": "builder-scene-limitations",
          "title": "Scene limitations",
          "categories": "builder",
          "url": " /builder/scene-limitations/",
          "content": "In order to improve performance in the metaverse, we have established a set of limits that every scene must follow. If a\nscene exceeds these limitations, then the parcel won’t be loaded and the preview will display an error message.\n\nFor a straight-forward reference of what limitations you’ll have for a specific number of parcels, check the following reference table.\n\nScene limitation rules\n\nBelow are the maximum number of elements allowed in a scene:\n\n\n  n represents the number of parcels that a scene occupies.\n\n\n\n  Triangles: n x 10000 Total amount of triangles for all the models in the scene.\n  Entities: n x 200 Amount of entities in the scene.\n  Bodies: n x 300 Amount of meshes in the scene.\n  Materials: log2(n+1) x 20 Amount of materials in the scene. It includes materials imported as part of models.\n  Textures: log2(n+1) x 10 Amount of textures in the scene. It includes textures imported as part of models.\n  \n    Height: log2(n+1) x 20 Height in meters.\n\n    \n      Note: Only entities that are currently being rendered in the scene are counted for these limits. If your scene switches between 3D models, what matters is the rendered models at any point in time, not the total sum. Player avatars and any items brought by a player from outside the scene don’t count for calculating these limits either.\n    \n  \n  \n    File size: 15 MB per parcel Total size of the files uploaded to the content server. Includes 3D models and audio. Doesn’t include files that aren’t uploaded, such as node.js packages.\n  \n  File count: 200 files per parcel Total count of the files uploaded. Includes 3D models and audio. Doesn’t include files that aren’t uploaded, such as node.js packages.\n\n\n\n\nScene boundaries\n\nWhen running a preview, any content that is located outside the parcel boundaries is highlighted in red when rendered. If any content is outside these boundaries, you won’t be allowed to deploy this scene to Decentraland.\n\nIf part of a large object leaves the scene boundaries, this object is considered out of bounds too.\n\nA single parcel scene measures 16 meters x 16 meters. If the scene has multiple parcels, the dimensions vary depending on the arrangement of the parcels.\n\nShader limitations\n\n3D models used in Decentraland must use supported shaders and materials. See 3D model materials for a list of supported shaders.\n\nLighting\n\nThe scene’s lighting conditions can’t be changed from the default setting.\n\nTexture size constraints\n\nTexture sizes must use width and height numbers (in pixels) that match the following numbers:\n\n1, 2, 4, 8, 16, 32, 64, 128, 256, 512\n\n\n\n  This sequence is made up of powers of two: f(x) = 2 ^ x . 512 is the maximum number we allow for a texture size. This is a fairly common requirement among other rendering engines, it’s there due internal optimizations of the graphics processors.\n\n\nThe width and height don’t need to have the same number, but they both need to belong to this sequence.\n\nThe recommended size for textures is 512x512, we have found this to be the optimal size to be transported through domestic networks and to provide reasonable loading/quality experiences.\n\nExamples of other valid sizes:\n\n32x32\n64x32\n512x256\n512x512\n\n\n\n  Note: Although textures of arbitrary sizes sometimes work, they are also often rendered with bugs and are more unstable. We strongly advise that all your textures match these sizes."
        }
        
      
    
  
    
      
        ,
        
        "market-info-from-land": {
          "id": "market-info-from-land",
          "title": "Get parcel info",
          "categories": "market",
          "url": " /market/info-from-land/",
          "content": "You can use the Decentraland CLI to query info directly from LAND tokens in the blockchain and from the scene files uploaded to the content server.\n\nTo run these commands, you must first Install the CLI.\n\nGet info about a scene\n\nThe dcl info command returns the contents of a scene’s scene.json file, including owner, contact info, and parcels in the scene.\n\n\n  dcl info from the scene’s folder returns info about that specific scene.\n  dcl info x,y, where x and y are parcel coordinates, returns info about the scene in that location.\n    \n      Note: Don’t add a space between both coordinates.\n    \n  \n  dcl info id, where id is an estate id, returns info about the scene with that estate id.\n\n\nThe dcl status command returns a list with the files deployed to a scene. This only includes file names and sizes. You can’t access the contents of the files via the CLI.\n\n\n  dcl status from the scene’s folder returns info about that specific scene.\n  dcl status x,y, where x and y are parcel coordinates (with no spaces between them), returns info about the scene in that location.\n    \n      Note: Don’t add a space between both coordinates.\n    \n  \n  dcl status id, where id is an estate id, returns info about the scene with that estate id.\n\n\n\n  Note: Everything that’s uploaded to our content server is public and reachable through that network. When you deploy a scene, by default you’re not uploading the original source code for the scene, instead you upload a version that’s compiled to minified JavaScript, which is a lot less readable.\n\n\nGet info from a wallet address\n\nThe dcl info command also lets you see info about an Ethereum wallet and the LAND tokens that it owns.\n\n\n  dcl info xxxx, where xxxx is the Ethereum address you’re interested in, returns a list of all the LAND parcels and estates owned by that address and their details."
        }
        
      
    
  
    
      
        ,
        
        "releases-sdk-4-1-0": {
          "id": "releases-sdk-4-1-0",
          "title": "SDK Release 4.1.0",
          "categories": "releases, sdk",
          "url": " /releases/sdk/4.1.0/",
          "content": "Note: This version of the SDK is now deprecated. You can find the full documentation for this version in the legacy documentation\n\n\n4.1.1\n\n\n  Fixed the method for signing using an ethereum address.\n  Performance improvements.\n  Ambient/sky improvements in preview.\n  Added joystick in mobile view.\n\n\n4.1.0\n\n\n  \n    A few packages have been rebranded:\n\n    \n      metaverse-api is now decentraland-api\n      metaverse-rpc is now decentraland-rpc\n      metaverse-compiler is now decentraland-compiler\n    \n  \n\n\nWhen migrating a scene to 4.1.0, keep in mind that the first lines of the file that import from metaverse-api must be changed to import from decentraland-api.\n\nimport * as DCL from \"decentraland-api\"\nimport { Vector3Component } from \"decentraland-api\"\n\n\n\n  The new onClick handler can be added to any entity to handle click events in the same way that React handles clicks. This can greatly simplify scene code, for example:\n\n\nOld way\n\nimport * as DCL from \"decentraland-api\"\n\nexport default class InteractiveCubeScene extends DCL.ScriptableScene {\n  state = {\n    size: 1,\n  }\n\n  sceneDidMount() {\n    this.eventSubscriber.on(\"interactiveBox_click\", async () =&gt; {\n      this.resizeBox()\n    })\n  }\n\n  resizeBox = () =&gt; {\n    this.setState({ size: Math.random() * 3 })\n  }\n\n  async render() {\n    return (\n      &lt;scene&gt;\n        &lt;box\n          id=\"interactiveBox\"\n          withCollisions\n          scale={this.state.size}\n          position={{ x: 5, y: 1, z: 5 }}\n        /&gt;\n      &lt;/scene&gt;\n    )\n  }\n}\n\n\nNew way\n\nimport * as DCL from \"decentraland-api\"\n\nexport default class InteractiveCubeScene extends DCL.ScriptableScene {\n  state = {\n    size: 1,\n  }\n\n  resizeBox = () =&gt; {\n    this.setState({ size: Math.random() * 3 })\n  }\n\n  async render() {\n    return (\n      &lt;scene&gt;\n        &lt;box\n          onClick={this.resizeBox}\n          withCollisions\n          scale={this.state.size}\n          position={{ x: 5, y: 1, z: 5 }}\n        /&gt;\n      &lt;/scene&gt;\n    )\n  }\n}\n\n\nNote that the new way saves you from having to create and subscribe to a click event, and attaching and ID to every element that needs to handle a click. Using this handler, the entity doesn’t require an ID to be clicked. All you need to do is pass a function through an onClick JSX attribute and enjoy!\n\n\n  The parcel limits are now inclusive.\n\n\nBefore, entities couldn’t reach the border of the scene’s parcels, you needed to limit positions to something like { x: 9.9, y:1, z: 9.9} in a 1 parcel scene. Now you can position things up to the very limit of the parcels, so on a 1 parcel scene entities can reach { x: 10, y:1, z: 10}\n\n\n  \n    Static scenes have better performance\n  \n  \n    A bug was fixed where an entity’s lookAt value couldn’t be the same as the value for position. This was problematic in scenarios where you need a character to move slowly towards a position (with a transition) and look in that direction as it does. Now this scenario is fully supported.\n  \n  \n    Preview scenes have a new lighting configuration. Previous lighting conditions were too bright and didn’t allow the geometry of certain shapes to be seen clearly.\n  \n\n\nMigrate a scene to 4.1.0\n\nTo migrate a scene built with an earlier version to 4.1.0, follow these steps:\n\n\n  Delete the file package-lock.json\n  Delete the folder node_modules\n  In scene.tsx, change all imports from metaverse-api to decentraland-api. For example:\n\n\nimport * as DCL from \"decentraland-api\"\n\n\n\n  Modify the package.json file to change the following:\n    \n      Change metaverse-compiler into decentraland-compiler.\n      Change metaverse-api into decentraland-api.\n      Add \"decentraland\": \"latest\" in devDependencies.\nThe file should look something like this:\n    \n  \n\n\n{\n  \"name\": \"dcl-project\",\n  \"version\": \"1.0.0\",\n  \"description\": \"My new Decentraland project\",\n  \"scripts\": {\n    \"start\": \"dcl start\",\n    \"build\": \"decentraland-compiler build.json\",\n    \"watch\": \"decentraland-compiler build.json --watch\"\n  },\n  \"author\": \"\",\n  \"license\": \"MIT\",\n  \"devDependencies\": {\n    \"decentraland-api\": \"latest\",\n    \"decentraland\": \"latest\"\n  }\n}\n\n\n\n  Run npm install or dcl start to build new versions of package-lock.json and node_modules based on the dependencies of the new version.\n  If your scene included any special dependencies, like Babylon or Axios, install them again with npm."
        }
        
      
    
  
    
      
        ,
        
        "releases-sdk-4-0-0": {
          "id": "releases-sdk-4-0-0",
          "title": "SDK Release 4.0.0",
          "categories": "releases, sdk",
          "url": " /releases/sdk/4.0.0/",
          "content": "4.0.4\n\n\n  \n    Adds Ethereum provider support. It uses the same provider as your browser. This is an experimental API, the behavior may change in the future.\n\n    For the moment, we are only allowing a whitelisted set of RPC calls:\n\n    \n      eth_sendTransaction\n      eth_getTransactionReceipt\n      eth_estimateGas\n      eth_call\n      eth_getBalance\n      eth_getStorageAt\n      eth_blockNumber\n      eth_gasPrice\n      eth_protocolVersion\n      net_version\n      eth_getTransactionCount\n      eth_getBlockByNumber\n    \n\n    In Future releases, we’ll be adding more limitations and verifications on top of this API\n\n    import { createElement, ScriptableScene } from \"decentraland-api-api\"\nimport Web3 = require(\"web3\")\n\nexport default class EthereumProvider extends ScriptableScene {\n  async sceneDidMount() {\n    const provider = await this.getEthereumProvider()\n    const web3 = new Web3(provider)\n\n    web3.eth.getBlock(48, function (error: Error, result: any) {\n      console.log(\"Eth block 48 (from scene)\", result)\n    })\n  }\n\n  async render() {\n    return &lt;scene /&gt;\n  }\n}\n    \n\n    \n      IMPORTANT: The SDK works with version 0.20.6 of the Web3 library. It doesn’t currently support newer versions.\n    \n  \n\n\n4.0.3\n\n\n  Fixes pointerEvents in preview scenes\n  Fixes transitions in scale component\n  Fixes the camera inertia, it was causing problems with Firefox\n  Adds it is now possible to toggle the colliders and bounding boxes in the preview using the key C and B\n  \n    Adds a MessageBus between parcels, you can now send messages between users in the same scene\n\n    import {\n  createElement,\n  ScriptableScene,\n  MessageBusClient,\n} from \"decentraland-api\"\n\nexport default class BoxFollower extends ScriptableScene {\n  state = { elements: [] }\n\n  async sceneDidMount() {\n    // get an instance of a MessageBus for this scene\n    const messageBus = await MessageBusClient.acquireEstateChannel(this)\n\n    this.subscribeTo(\"pointerDown\", (e) =&gt; {\n      // every time we receive a pointerDown, we send that message thru the MessageBus,\n      // in this case we are senging an event named `customPointerDown`\n      messageBus.emit(\"customPointerDown\", e)\n    })\n\n    messageBus.on(\"customPointerDown\", (e) =&gt; {\n      // everybody in the same parcel, even this MessageBus instance, receives the event\n      const position = {\n        x: e.from.x + e.direction.x,\n        y: e.from.y + e.direction.y,\n        z: e.from.z + e.direction.z,\n      }\n\n      const newBox = (\n        &lt;box\n          position={position}\n          scale={0.1}\n          id={this.state.elements.length}\n        /&gt;\n      )\n\n      this.setState({\n        elements: this.state.elements.concat(newBox),\n      })\n    })\n  }\n\n  async render() {\n    return &lt;scene&gt;{this.state.elements}&lt;/scene&gt;\n  }\n}\n    \n  \n  \n    Adds a shadeless material, it is not affected by the light. It is useful to create pixel art scenes or user interfaces.\n\n    &lt;base-material\n  id=\"test\"\n  texture=\"something.png\"\n  samplingMode={TextureSamplingMode.NEAREST}\n  alphaTest={0.5}\n/&gt;\n    \n  \n  \n    Adds lookAt component, allows you to handle the rotation of the entities without angles, instead, it is possible to specify a point in the space and the entity will be rotated to point in that direction.\n\n    &lt;box lookAt={{ x: 1, y: 10, z: 10 }} /&gt;\n    \n  \n\n\nBreaking changes\n\n\n  Removed ignoreCollisions component. It is now required to manually specify the entities that will have collisions with the new component withCollisions\n  Material entity no longer sets up alpha automatically. If you want to create a transparent material you need to add the hasAlpha component.\n    &lt;material albedoTexture=\"semiTransparentTexture.png\" hasAlpha /&gt;\n// or\n&lt;material albedoTexture=\"semiTransparentTexture.png\" alphaTexture=\"semiTransparentTexture.png\" /&gt;\n    \n  \n\n\n4.0.2\n\nThis release improves internals of the P2P communications and fix a critical rotation bug.\n\n\n  Fixes an important bug in rotations, now rotations behave exactly as they should, they mimic the behavior of Unity\n  Fixes transparency in albedo PNGs\n  Adds the axis in every &lt;scene&gt; in debug mode\n  Adds several properties to the &lt;material&gt; entity\n\n\n4.0.1\n\nThis release contains several bugfixes and removes the spherical gaze from the center of the screen, instead, it introduces a clean white circle.\n\n4.0.0\n\nThe version 4.0.0 introduces several major changes, those are breaking changes:\n\nMigrated from Three.js to Babylon.js\n\nThree.js was no powerful nor optimized enough to support the amount of elements and materials we wanted to handle. This\nmigration also proves the idea behind the decoupling of the SDK, we managed to change the entire rendering engine without\naffecting the user scenes.\n\nNew material entity\n\nPreviously when you wanted to create and modify a material, you needed to specify it as a component of a entity like this:\n\nimport { createElement, ScriptableScene } from \"decentraland-api\"\n\nexport default class BoxFollower extends ScriptableScene {\n  render() {\n    return (\n      &lt;scene id=\"old_scene\"&gt;\n        &lt;sphere material=\"map: some/url.png; alphaTest: 0.5\" /&gt;\n      &lt;/scene&gt;\n    )\n  }\n}\n\n\nThat leads to material duplications and special care with garbage collection in the engine; and to a super verbosic and\nnot well decoupled code in the scene’s code.\n\nWe converted the material into an entity itself, now, the materials are using a PBR pipeline by default.\n\nHere is how it looks now:\n\nimport { createElement, ScriptableScene } from \"decentraland-api\"\n\nexport default class BoxFollower extends ScriptableScene {\n  async render() {\n    return (\n      &lt;scene id=\"new_scene\"&gt;\n        &lt;material\n          id=\"reusable_material\"\n          albedoColor=\"some/url.png\"\n          roughness=\"0.5\"\n        /&gt;\n        &lt;sphere material=\"#reusable_material\" /&gt;\n      &lt;/scene&gt;\n    )\n  }\n}\n\n\nFixed the coordinate system\n\nPrevious to this release, we had a patch for the reference system. The Z axis was inverted inside the parcel in relation\nto the world-grid.\n\nIt means if an object was standing in the world position 55,55, it was in the parcel 5,-4. It is now in the parcel 5,5.\n\nYou need to be careful with this change since it inverts an entire axis, you might have to change the position of your entities.\n\nChanges in the way to receive the users position\n\nPrevious to this version, you needed to execute await getMyPositionInEstate() to obtain the position of the user in the\nscreen. Now you can subscribe to the positionChanged event.\n\nimport { createElement, ScriptableScene } from \"decentraland-api\"\n\nexport default class BoxFollower extends ScriptableScene {\n  state = { position: { x: 0, y: 0, z: 0 } }\n\n  async sceneDidMount() {\n    this.subscribeTo(\"positionChanged\", (e) =&gt; {\n      this.setState({ position: e.position })\n    })\n  }\n\n  async render() {\n    return (\n      &lt;scene&gt;\n        &lt;box position={this.state.position} ignoreCollisions /&gt;\n      &lt;/scene&gt;\n    )\n  }\n}\n\n\nIn addition, we added the following events to the SDK\n\nexport type PointerEvent = {\n  /** Origin of the ray */\n  from: Vector3Component\n  /** Direction vector of the ray (normalized) */\n  direction: Vector3Component\n  /** Length of the ray */\n  length: number\n  /** ID of the pointer that triggered the event */\n  pointerId: number\n}\n\nexport interface IEvents {\n  /**\n   * `positionChanged` is triggered when the position of the camera changes\n   * This event is throttled to 10 times per second.\n   */\n  positionChanged: {\n    /** Position relative to the base parcel of the scene */\n    position: Vector3Component\n\n    /** Camera position, this is a absolute world position */\n    cameraPosition: Vector3Component\n\n    /** Eye height, in meters. */\n    playerHeight: number\n  }\n\n  /**\n   * `rotationChanged` is triggered when the rotation of the camera changes.\n   * This event is throttled to 10 times per second.\n   */\n  rotationChanged: {\n    /** {X,Y,Z} Degree vector. Same as entities */\n    rotation: Vector3Component\n    /** Rotation quaternion, useful in some scenarios. */\n    quaternion: Quaternion\n  }\n\n  /**\n   * `setAttributes` is triggered after the system receives new properties.\n   */\n  setAttributes: {\n    [key: string]: any\n  }\n\n  /**\n   * `click` is triggered when a user points and the ray (from mouse or controller) hits the entity.\n   * Notice: Only entities with ID will be listening for click events.\n   */\n  click: {\n    /** ID of the entity of the event */\n    elementId: string\n\n    /** ID of the pointer that triggered the event */\n    pointerId: number\n  }\n\n  /**\n   * `pointerUp` is triggered when the user releases an input pointer.\n   * It could be a VR controller, a touch screen or the mouse.\n   */\n  pointerUp: PointerEvent\n\n  /**\n   * `pointerDown` is triggered when the user press an input pointer.\n   * It could be a VR controller, a touch screen or the mouse.\n   */\n  pointerDown: PointerEvent\n}"
        }
        
      
    
  
    
      
        ,
        
        "market-land-manager": {
          "id": "market-land-manager",
          "title": "LAND Manager",
          "categories": "market",
          "url": " /market/land-manager/",
          "content": "The Land Manager allows you to manage your LAND and Estate assets.\n\nAccess the Land manager at https://builder.decentraland.org/land.\n\nThe Land Manager allows you to:\n\n\n  Name your parcels and Estates and give them a public description.\n  Merge LAND parcels into an Estate.\n  Dissolve an Estate into separate LAND parcels.\n  Transfer your parcels and Estates to another user.\n  Grant permissions to other users to edit the parcels you own.\n\n\nManage Your LAND\n\nTo view your LAND tokens, click My LAND. Here you’ll find a list of all of your parcels and Estates, including any parcels that you have listed for sale.\n\nBy clicking on one of the parcels or Estates listed under My Land, you can edit its name, description, put it up for sale, or transfer it directly to another wallet address.\n\n\n\nCreate an Estate\n\nLAND Estates make it possible to associate two or more directly adjacent parcels of LAND to make it easier to manage your larger LAND holdings. Estates are especially useful when building larger scenes that span more than one parcel.\n\nParcels in an Estate must be directly adjacent, and cannot be separated by a road, plaza, or any other parcel.\n\nTo create your first Estate, you need to own two or more adjacent LAND parcels.\n\n\n  Open My LAND and select one of the parcels you’d like to add to the Estate.\n  In the parcel’s details page, click Create Estate.\n  \n    You will be shown a view of the Atlas centered on the parcel you selected, with the remaining adjacent parcels you own highlighted. Select the different parcels you want to include in your Estate.\n\n  \n  Click Continue.\n  \n    Enter a name and description for your Estate. These details will be publicly displayed in the Atlas, just like the name and description for any individual parcel.\n\n    \n  \n  Confirm this transaction on your Ethereum client and wait for the network to verify it.\n\n\nOnce you’ve created your first Estate, you will see a new tab titled Estates. From this page you can view and manage all of your Estates.\n\nWhen you create a new Estate, you are effectively transferring your parcels to a new token. These Estates are represented by ERC721 tokens (like any other NFT). You will no longer see the individual parcels under My LAND, and they will not appear in MetaMask, Mist, Trezor, or Ledger wallets, nor on Etherscan under your address.\n\nEdit parcels or Estates\n\nYou can edit the name and description of any parcel or Estate that you own. These details will be publicly displayed in the Atlas.\n\nTo edit a parcel or Estate:\n\n\n  \n    Navigate to the details page of the parcel or the Estate you’d like to edit and click Edit.\n\n    \n  \n  Click Submit.\n  Confirm this transaction on your Ethereum client and wait for the network to verify it.\n\n\nGive permissions\n\nYou can give another user permissions to edit the content in a parcel or Estate. This enables that user to deploy code to the scene, whilst not having the ability to sell the token.\n\nThe user given permission can also change the name or description in the Marketplace.\n\nTo grant permissions over your LAND:\n\n\n  \n    Navigate to the details page of the parcel or Estate and click Permissions.\n\n    \n  \n  Click Submit.\n  Confirm this transaction on your Ethereum client and wait for the network to verify it.\n\n\nSee your activity history\n\nOpen the notifications page by clicking the bell icon at the top of the screen.\n\n\n\nThe notifications page displays a list of all the recent transactions that you have carried out, together with their status.\n\nClick a transaction to see more details about it on Etherscan.\n\nTransfer LAND\n\nTo transfer a LAND parcel or Estate to another user:\n\n\n  \n    Navigate to the details page of the parcel or the Estate you’d like to transfer and click Transfer.\n\n    \n  \n  \n    Enter the public address of the Ethereum wallet of the recipient.\n  \n\n\n\n  Note: Please double check this address, since you cannot cancel the operation. While the recipient could always transfer the LAND back to you, the original owner cannot reverse the action.\n\n\n\n  Click Submit.\n  Confirm this transaction on your Ethereum client and wait for the network to verify it."
        }
        
      
    
  
    
      
        ,
        
        "market-mortgages": {
          "id": "market-mortgages",
          "title": "LAND Mortgages (Deprecated)",
          "categories": "market",
          "url": " /market/mortgages/",
          "content": "IMPORTANT: LAND mortgages from the Ripio Credit Network have been deprecated!\nYou can no longer request LAND mortgages through the Decentraland Marketplace.\n\n\nBefore you can request a LAND mortgage, you will have to approve the Ripio Credit Network’s smart contracts to conduct transactions on your behalf using your MANA and RCN tokens. Open your Account Settings in the upper right corner, and check the two LAND by Mortgage boxes. (You only need MANA to request a mortgage, RCN will convert the MANA you use to the RCN token for you.)\n\nNext, navigate to the parcel that you wish to request a mortgage for. Click Request Mortgage, directly next to the Buy button.\n\nNext, you will have to submit a brief application form including the following details and a deposit of at least 10% of the price of the parcel you wish to buy.\n\n\n  Amount requested: the amount of MANA that you need for your mortgage.\n  Duration: how long (in days) you have to pay off your mortgage at the standard interest rate. Once the duration is reached, you will have to pay the punitory interest rate until the mortgage is paid off or defaulted.\n  Payable at: this represents the minimum amount of interest you will pay, regardless of when you pay off your mortgage. For example, if you take out a mortgage lasting 30 days, with a Payable at of 10 days, then you will be charged for at least 10 days of interest (even if you pay off your mortgage within one day of your request).\n  Interest rate: the annual interest rate for your mortgage.\n  Punitory interest rate: the amount of additional interest you must pay if you do not pay off your mortgage before the duration of your mortgage.\n  Request expiration: how long the mortgage will be listed on RCN. If this date is reached and no one fulfills your mortgage request, you will have to request another mortgage.\n\n\nOnce you request your mortgage, it will be published to the RCN network. Remember, so long as your mortgage request is still open on RCN, anyone else may purchase the parcel. A mortgage request does not take a parcel off of the Marketplace until a lender fulfills the mortgage.\n\nAny lender on RCN can supply the funds and fulfill the loan (as long as the parcel in question is still for sale). Once a lender fulfils the loan, the parcel will be transferred to a separate smart contract for the mortgage and will no longer be available on the market for other buyers.\n\nAs a borrower, you can then repay the loan by making periodic payments through the Decentraland Marketplace.\n\nIf you fail to fully repay the loan, you have up to 7 days after the expiration date to repay your loan. After this period, your lender may request the mortgage back through the RCN dApp. If your lender requests the mortgage back, you will see a “Defaulted” notice on the parcel page. You will lose the MANA you’ve paid, along with your ability to claim that parcel.\n\nYou can see a list of your open mortgages by clicking My LAND in the Decentraland Marketplace, and selecting the Mortgages tab.\n\nTo make a payment, click Pay in the mortgage’s details page, enter the amount of MANA you want to include in your payment, and click Submit.\n\nOnce you have completely paid off your mortgage, you can claim your parcel. Simply navigate to the parcel’s page in the Marketplace, and click Claim Parcel. Now, the parcel is freed from the mortgage smart contract is transferred to your account."
        }
        
      
    
  
    
      
        ,
        
        "market-marketplace": {
          "id": "market-marketplace",
          "title": "Marketplace",
          "categories": "market",
          "url": " /market/marketplace/",
          "content": "The Marketplace is the go-to place to trade and manage all your Decentraland on-chain assets.\n\nAccess the Marketplace at market.decentraland.org.\n\nThe Marketplace allows you to:\n\n\n  Sell parcels and Estates of LAND, wearables, and unique names. Set your own price in MANA and an expiration date for the offer.\n  Buy parcels and Estates, wearables, and unique names that are for sale.\n  Transfer your Decentraland assets to another user.\n  Explore the world through a map to see who owns what, existing wearables or claimed avatar names.\n\n\n\n  Note: Use builder.decentraland.org/land to:\n\n\n\n  Name your parcels and Estates and give them a public description.\n  Grant permissions to other users, allowing them to deploy on your LAND.\n  Manage to create or dissolve estates.\n\n\nYour Wallet\n\nBefore using market.decentraland.org, connect and log into an Ethereum client account that can interact with the web browser. We recommend using MetaMask. We also support the use of a Ledger hardware wallet.\n\n\n  Note: If you would like to use your Ledger hardware wallet in the Marketplace, it will require you to connect it towards MetaMask. Please ensure you follow all the given steps and updates to allow a seamless Ledger usage.\n\n\nWhen navigating the Marketplace, your wallet address is treated as your account, you don’t need any additional log in.\n\nThe Marketplace currently hosts LAND and names solely on Ethereums network. Wearables differ between Ethereum and Polygons network. Ethereum based transactions require a GAS fee, paid in Ethereum. Wheras Polygon based transactions only require a small amount of MATIC, to perform actions in the Marketplace.\n\nThe Atlas View\n\nThe Atlas view gives you a bird’s-eye perspective of every color coded parcel, Estate, road, district, and plaza in Decentraland.\n\n\n\nYou can click and drag the map to move around, zoom in and out, or hover your cursor over a parcel to see its x,y location and owner.\n\nAny parcel that is currently for sale in the Marketplace will be highlighted.\n\nClick on a parcel to view it’s status, its coordinates, and its owner’s public address (if it has an owner). From this screen you can also buy or place a bid on the parcel.\n\nThe Marketplace View\n\nSelect the Browse tab to see all the items that are for sale.\n\n\n  Select the Category to view only a specific type of item .\n  Order them by different criteria like most recent, cheapest, etc.\n  Toggle On sale off to view items that aren’t for sale.\n  Filter items by name to find something specific.\n\n\n\n\nBuy MANA\n\nTo buy MANA in exchange for Ether:\n\n\n  Open your user Settings page.\n  Click Buy More next to your MANA balance.\n  This takes you to Kyber Swap, where you can easily exchange Ether to MANA.\n  Set an amount of MANA you’d like to receive or the amount of Ether you’d like to convert, then click Swap Now.\n  Confirm this transaction on your Ethereum client and wait for the network to verify it.\n\n\nBuy items\n\nTo buy LAND, Estates, wearables or unique names in Decentraland:\n\n\n  Browse offers to find something on same that you’d like to buy and click it to open its details.\n\n\n\n  Tip: For LAND and Estates, you can also browse using the Atlas view.\n\n\n\n  \n    On it’s details page, click Buy.\n  \n  \n    Confirm this transaction on your Ethereum client and wait for the network to verify it.\n  \n\n\n\n  Note: If this is your first time buying something on the Marketplace, you will also be asked to confirm a one-time transaction to allow the Marketplace to accept MANA.\n\n\nPlace a bid on an item\n\nIf an item isn’t listed on sale, you can still place a bid on it and offer to buy it at a specific price. The other steps of the process are just like those of buying an item.\n\n\n  Tip: View items that aren’t for sale by untoggling the On sale option. For LAND and Estates, you can also browse using the Atlas view and select any parcel.\n\n\n\n  Note: If this is your first time placing a bid on the Marketplace, you will also be asked to confirm a one-time transaction to allow the Marketplace to handle bids.\n\n\nTo view a list of your open and pending bids, select My Bids on the top navbar.\n\nFrom this screen you can also change the price of your bid by clicking Update. This screen also shows bids made by other users on items you own.\n\nSell a parcel or Estate\n\nTo sell one of your items:\n\n\n  Open My Assets and open its details page.\n  In the details page, click Sell.\n  Set a price and expiration date and click List for sale. Then retype the price you’re selling it at to confirm.\n  Confirm this transaction on your Ethereum client and wait for the network to verify it.\n\n\n\n  Note: If this is your first time selling an item of this asset type on the Marketplace, you will also be asked to confirm a one-time transaction to allow the Marketplace to accept MANA.\n\n\nYou can change the price of a sale that you already put on offer without having to cancel and re-create the sale. Just click Update price in the parcel or Estate’s details page.\n\nSee your activity history\n\nOpen the notifications page by clicking the bell icon at the top of the screen.\n\n\n\nThe notifications page displays a list of all the recent transactions that you have carried out, together with their status.\n\nClick a transaction to see more details about it on Etherscan.\n\n\n  Note: This screen only shows transactions that were initiated by you. It doesn’t show the sale of tokens, since that action is initiated by the buyer.\n\n\nTransfer LAND\n\nTo transfer a LAND parcel or Estate to another user:\n\n\n  \n    Open My Asssets and open the details page of the parcel or the Estate you’d like to transfer and click Transfer.\n  \n  \n    Enter the public address of the Ethereum wallet of the recipient.\n  \n\n\n\n  Note: Please double check this address, since you cannot cancel the operation. While the recipient could always transfer the LAND back to you, the original owner cannot reverse the action.\n\n\n\n  Click Submit.\n  Confirm this transaction on your Ethereum client and wait for the network to verify it.\n\n\n\n  Note: If the LAND parcel or Estate is currently on sale, you won’t be able to transfer it. First click Remove listing to cancel the sale.\n\n\nProviding Feedback\n\nWe’ve worked hard to ensure that the Marketplace is simple and easy to use but if you ever have questions or feedback please reach out to us using the in-app Intercom widget.\n\nAs with all of our other tools, the Marketplace is open-source software, and you can find the code here. Feel free to create an issue, or submit a pull-request!"
        }
        
      
    
  
    
      
        ,
        
        "market-api": {
          "id": "market-api",
          "title": "LAND API Reference",
          "categories": "market",
          "url": " /market/api/",
          "content": "Base URL: https://api.decentraland.org/\n\nSpecify version: https://api.decentraland.org/v1\n\nTable of Contents\n\n\n  Bids\n  Contributions\n  Districts\n  Estates\n  Mortgages\n  Map\n  Parcels\n  Publications\n  Translations\n\n\nBids\n\nGET /bids/:id\n\n\nDescription\n\nReturns a bid by its id.\n\nURI Params\n\n\n  \n    \n      name\n      type\n      description\n    \n  \n  \n    \n      id\n      string\n      The id of the bid\n    \n  \n\n\nRequest Example:\n\nGET /bids/0xaac47013b34b4c9a568503db4e8c5b3a41764919ba26214491fb3e665282eaea\n\n\nResponse Example\n\n{\n  \"ok\": true,\n  \"data\": {\n    \"id\": \"0xaac47013b34b4c9a568503db4e8c5b3a41764919ba26214491fb3e665282eaea\",\n    \"token_address\": \"0x124bf28a423b2ca80b3846c3aa0eb944fe7ebb95\",\n    \"token_id\": \"31\",\n    \"bidder\": \"0x87956abc4078a0cc3b89b419928b857b8af826ed\",\n    \"seller\": \"0xe4d3ba99ffdae47c003f1756c01d8e7ee8fef7c9\",\n    \"price\": 2,\n    \"expires_at\": \"1551495590000\",\n    \"fingerprint\": \"0x7bf0da414abc768d638b486dfc3330abd361aa7d7916d673072d4e3776ea9287\",\n    \"status\": \"sold\",\n    \"asset_id\": \"31\",\n    \"asset_type\": \"estate\",\n    \"block_number\": 4924562,\n    \"block_time_created_at\": \"1548876122000\",\n    \"block_time_updated_at\": \"1548876183000\",\n    \"created_at\": \"2019-01-31T13:42:40.697Z\",\n    \"updated_at\": \"2019-02-04T12:42:23.017Z\"\n  }\n}\n\n\nGET /addresses/:address/bids\n\n\nDescription\n\nReturns a list of bids where the seller or bidder is the given address.\n\nURI Params\n\n\n  \n    \n      name\n      type\n      description\n    \n  \n  \n    \n      address\n      string\n      An Ethereum address\n    \n  \n\n\nQuery Params\n\n\n  \n    \n      name\n      type\n      default\n      description\n    \n  \n  \n    \n      status\n      enum\n      all\n      Filter estates by publications status: open, cancelled or sold\n    \n  \n\n\nRequest Example:\n\nGET /addresses/0xe4d3ba99ffdae47c003f1756c01d8e7ee8fef7c9/bids\n\n\nResponse Example\n\n{\n  \"ok\": true,\n  \"data\": [\n    {\n      \"id\": \"0xfbeb6c5f702d3be5564872cd68bc96c683b0029d8116feb79058669c6fe40d1d\",\n      \"token_address\": \"0x7a73483784ab79257bb11b96fd62a2c3ae4fb75b\",\n      \"token_id\": \"1.1579208923731619542357098500868790784067953708956584089131272353293770581592e+77\",\n      \"bidder\": \"0xe4d3ba99ffdae47c003f1756c01d8e7ee8fef7c9\",\n      \"seller\": \"0x87956abc4078a0cc3b89b419928b857b8af826ed\",\n      \"price\": 1,\n      \"expires_at\": \"1551409156000\",\n      \"fingerprint\": \"0x\",\n      \"status\": \"sold\",\n      \"asset_id\": \"145,-79\",\n      \"asset_type\": \"parcel\",\n      \"block_number\": 4918744,\n      \"block_time_created_at\": \"1548787699000\",\n      \"block_time_updated_at\": \"1548787921000\",\n      \"created_at\": \"2019-01-31T13:42:40.437Z\",\n      \"updated_at\": \"2019-02-04T12:42:22.785Z\"\n    }\n  ]\n}\n\n\nGET /parcels/:x/:y/bids\n\n\nDescription\n\nReturns a list of bids placed on a given Parcel.\n\nURI Params\n\n\n  \n    \n      name\n      type\n      min\n      max\n      default\n      description\n    \n  \n  \n    \n      x\n      int\n      -150\n      150\n      0\n      The X coord of the parcel\n    \n    \n      y\n      int\n      -150\n      150\n      0\n      The Y coord of the parcel\n    \n  \n\n\nQuery Params\n\n\n  \n    \n      name\n      type\n      default\n      description\n    \n  \n  \n    \n      status\n      enum\n      all\n      Filter estates by publications status: open, cancelled or sold\n    \n    \n      bidder\n      string\n      N/A\n      The Ethereum address of the bidder\n    \n    \n      sanitize\n      boolean\n      true\n      If false, will retrieve all the bids property\n    \n  \n\n\nRequest Example:\n\nGET /parcels/145,-79/bids\n\n\nResponse Example\n\n{\n  \"ok\": true,\n  \"data\": [\n    {\n      \"id\": \"0xfbeb6c5f702d3be5564872cd68bc96c683b0029d8116feb79058669c6fe40d1d\",\n      \"token_address\": \"0x7a73483784ab79257bb11b96fd62a2c3ae4fb75b\",\n      \"token_id\": \"1.1579208923731619542357098500868790784067953708956584089131272353293770581592e+77\",\n      \"bidder\": \"0xe4d3ba99ffdae47c003f1756c01d8e7ee8fef7c9\",\n      \"seller\": \"0x87956abc4078a0cc3b89b419928b857b8af826ed\",\n      \"price\": 1,\n      \"expires_at\": \"1551409156000\",\n      \"fingerprint\": \"0x\",\n      \"status\": \"sold\",\n      \"asset_id\": \"145,-79\",\n      \"asset_type\": \"parcel\",\n      \"block_number\": 4918744,\n      \"block_time_created_at\": \"1548787699000\",\n      \"block_time_updated_at\": \"1548787921000\",\n      \"created_at\": \"2019-01-31T13:42:40.437Z\",\n      \"updated_at\": \"2019-02-04T12:42:22.785Z\"\n    }\n  ]\n}\n\n\nGET /estates/:id/bids\n\n\nDescription\n\nReturns a list of bids placed on a given Estate.\n\nURI Params\n\n\n  \n    \n      name\n      type\n      description\n    \n  \n  \n    \n      id\n      string\n      The id of the estate\n    \n  \n\n\nQuery Params\n\n\n  \n    \n      name\n      type\n      default\n      description\n    \n  \n  \n    \n      status\n      enum\n      all\n      Filter estates by publications status: open, cancelled or sold\n    \n    \n      bidder\n      string\n      N/A\n      The Ethereum address of the bidder\n    \n    \n      sanitize\n      boolean\n      true\n      If false, will retrieve all the bids property\n    \n  \n\n\nRequest Example:\n\nGET /estates/1/bids\n\n\nResponse Example\n\n{\n  \"ok\": true,\n  \"data\": [\n    {\n      \"id\": \"0xaac47013b34b4c9a568503db4e8c5b3a41764919ba26214491fb3e665282eaea\",\n      \"token_address\": \"0x124bf28a423b2ca80b3846c3aa0eb944fe7ebb95\",\n      \"token_id\": \"1\",\n      \"bidder\": \"0x87956abc4078a0cc3b89b419928b857b8af826ed\",\n      \"seller\": \"0xe4d3ba99ffdae47c003f1756c01d8e7ee8fef7c9\",\n      \"price\": 2,\n      \"expires_at\": \"1551495590000\",\n      \"fingerprint\": \"0x7bf0da414abc768d638b486dfc3330abd361aa7d7916d673072d4e3776ea9287\",\n      \"status\": \"sold\",\n      \"asset_id\": \"1\",\n      \"asset_type\": \"estate\",\n      \"block_number\": 4924562,\n      \"block_time_created_at\": \"1548876122000\",\n      \"block_time_updated_at\": \"1548876183000\",\n      \"created_at\": \"2019-01-31T13:42:40.697Z\",\n      \"updated_at\": \"2019-02-04T12:42:23.017Z\"\n    }\n  ]\n}\n\n\nGET /bids/:address/assets\n\n\nDescription\n\nReturns a list of bid assets where the seller or bidder is the given address.\n\nURI Params\n\n\n  \n    \n      name\n      type\n      description\n    \n  \n  \n    \n      address\n      string\n      An Ethereum address\n    \n  \n\n\nQuery Params\n\n\n  \n    \n      name\n      type\n      default\n      description\n    \n  \n  \n    \n      status\n      enum\n      all\n      Filter estates by publications status: open, cancelled or sold\n    \n  \n\n\nRequest Example:\n\nGET /bids/0xe4d3ba99ffdae47c003f1756c01d8e7ee8fef7c9/assets\n\n\nResponse Example\n\n{\n  \"ok\": true,\n  \"data\": [\n    {\n      \"id\": \"12345\",\n      \"owner\": \"0xe0653744f2d6a388f1fc7496e085156418a9f5ed\",\n      \"data\": {\n        \"ipns\": \"\",\n        \"name\": \"My Estate\",\n        \"parcels\": [\n          { \"x\": -30, \"y\": -121 },\n          { \"x\": -29, \"y\": -121 }\n        ],\n        \"version\": 0,\n        \"description\": \"My estate is awesome\"\n      },\n      \"last_transferred_at\": \"1548929430000\",\n      \"tx_hash\": \"0x6d1f7cad7419af31b6b1f65205c5336200a1662e35ed9083d5f4323f95cb9dd6\",\n      \"token_id\": \"12345\",\n      \"update_operator\": \"0x0000000000000000000000000000000000000000\"\n    },\n    {\n      \"id\": \"-74,-52\",\n      \"x\": -74,\n      \"y\": -52,\n      \"auction_price\": 2443,\n      \"district_id\": null,\n      \"owner\": \"0xdeadbeeffaceb00c\",\n      \"data\": {\n        \"version\": 0,\n        \"name\": \"My Parcel\",\n        \"description\": \"My parcel is awesome\",\n        \"ipns\": \"\"\n      },\n      \"auction_owner\": \"0xdeadbeeffaceb00c\",\n      \"tags\": {},\n      \"last_transferred_at\": null,\n      \"in_estate\": false\n    }\n  ]\n}\n\n\nContributions\n\nGET /addresses/:address/contributions\n\n\nDescription\n\nReturns all the contributions to districts for a given address\n\nURI Params\n\n\n  \n    \n      name\n      type\n      description\n    \n  \n  \n    \n      address\n      string\n      An Ethereum address\n    \n  \n\n\nResponse Example\n\n{\n  \"ok\": true,\n  \"data\": [\n    {\n      \"address\": \"0x374cc898638940452b6d7b34f6063170976026f0\",\n      \"district_id\": \"219ac351-e6ce-4e17-8b84-eb008afddf69\",\n      \"land_count\": \"5\"\n    },\n    {\n      \"address\": \"0x374cc898638940452b6d7b34f6063170976026f0\",\n      \"district_id\": \"d9bfa18a-c856-457d-8d85-e2dc3b7648a1\",\n      \"land_count\": \"15\"\n    },\n    {\n      \"address\": \"0x374cc898638940452b6d7b34f6063170976026f0\",\n      \"district_id\": \"f5d8e722-fdce-4d41-b38b-adfed2e0cf6c\",\n      \"land_count\": \"10\"\n    }\n  ]\n}\n\n\nDistricts\n\nGET /districts\n\n\nReturns all the districts in Genesis City\n\nResponse Example\n\n{\n  \"ok\": true,\n  \"data\": [\n    {\n      \"id\": \"106f1557-4a92-41a4-9f18-40fcb90b4031\",\n      \"name\": \"Dragon City\",\n      \"description\": \"A perfect combination of China’s ancient culture and Western modernization, a reflection of both the Eastern and Western civilizations.\",\n      \"link\": \"https://github.com/decentraland/districts/issues/30\",\n      \"public\": true,\n      \"parcel_count\": \"6485\",\n      \"center\": \"105,-89\"\n    },\n    {\n      \"id\": \"219ac351-e6ce-4e17-8b84-eb008afddf69\",\n      \"name\": \"AETHERIAN project\",\n      \"description\": \"Aetherian City will be one of the main attractions for visitors and dwellers of Decentraland, as it intends to be the largest cyberpunk-agglomeration of the metaverse.\",\n      \"link\": \"https://github.com/decentraland/districts/issues/33\",\n      \"public\": true,\n      \"parcel_count\": \"10005\",\n      \"center\": \"106,105\"\n    }\n  ]\n}\n\n\nEstates\n\nGET /estates\n\n\nDescription\n\nReturns a list of Estates, paginated, sorted, and filtered according to the query params used.\n\n\n  \n    \n      name\n      type\n      default\n      description\n    \n  \n  \n    \n      status\n      enum\n      open\n      Filter estates by publications status: open, cancelled or sold\n    \n    \n      sort_by\n      enum\n      created_at\n      Property to order by: price, created_at, block_time_updated_at or expires_at\n    \n    \n      sort_order\n      enum\n      depends on sort_by\n      The order to sort by: asc or desc\n    \n    \n      limit\n      int\n      20\n      The number of results to be returned\n    \n    \n      offset\n      int\n      0\n      The number of results to skip (used for pagination)\n    \n  \n\n\nResponse Example\n\n{\n  \"ok\": true,\n  \"data\": {\n    \"estates\": [\n      {\n        \"id\": \"12345\",\n        \"owner\": \"0xe0653744f2d6a388f1fc7496e085156418a9f5ed\",\n        \"data\": {\n          \"ipns\": \"\",\n          \"name\": \"My Estate\",\n          \"parcels\": [\n            { \"x\": -30, \"y\": -121 },\n            { \"x\": -29, \"y\": -121 },\n            { \"x\": -29, \"y\": -122 },\n            { \"x\": -30, \"y\": -122 }\n          ],\n          \"version\": 0,\n          \"description\": \"My estate is awesome\"\n        },\n        \"last_transferred_at\": \"1548929430000\",\n        \"tx_hash\": \"0x6d1f7cad7419af31b6b1f65205c5336200a1662e35ed9083d5f4323f95cb9dd6\",\n        \"token_id\": \"12345\",\n        \"update_operator\": \"0x0000000000000000000000000000000000000000\",\n        \"publication\": {\n          \"tx_hash\": \"0xbcad5e05351972174c05633e8965de0b05a5a0ce4c5415c1a392ffae20b1cab2\",\n          \"tx_status\": \"confirmed\",\n          \"owner\": \"0xf631c1ba09ee33e7649cac62ccb6d0f410f5647a\",\n          \"price\": 39500,\n          \"expires_at\": 1554210000000,\n          \"status\": \"sold\",\n          \"buyer\": \"0xe0653744f2d6a388f1fc7496e085156418a9f5ed\",\n          \"contract_id\": \"0xfe8288241f94ebf31c132b85eb9ee6b834fb27b4c564eab6ba18b3813fafda38\",\n          \"block_number\": 7151964,\n          \"block_time_created_at\": 1548906378000,\n          \"block_time_updated_at\": 1548929430000,\n          \"asset_type\": \"estate\",\n          \"asset_id\": \"12345\",\n          \"marketplace_address\": \"0x8e5660b4ab70168b5a6feea0e0315cb49c8cd539\"\n        }\n      }\n    ],\n    \"total\": 80\n  }\n}\n\n\nGET /addresses/:address/estates\n\n\nDescription\n\nReturns all the Estates that belong to a given address\n\nURI Params\n\n\n  \n    \n      name\n      type\n      description\n    \n  \n  \n    \n      address\n      string\n      An Ethereum address\n    \n  \n\n\nMap\n\nGET /map\n\n\nDescription\n\nReturns all the parcels and estates in a given area\n\nQuery Params\n\n\n  \n    \n      name\n      type\n      min\n      max\n      description\n    \n  \n  \n    \n      nw\n      int\n      -150\n      150\n      The northwest coord of the area\n    \n    \n      se\n      int\n      -150\n      150\n      The southeast coord of the area\n    \n  \n\n\nRequest Example:\n\nGET /map?nw=-10,10&amp;se=10,-10\n\n\nResult:\n\n{\n  \"data\": {\n    \"assets\": {\n      \"parcels\": [\n        /* parcels */\n      ],\n      \"estates\": [\n        /* estates */\n      ]\n    },\n    \"total\": 441\n  }\n}\n\n\nGET /map.png\n\n\nDescription\n\nReturns a PNG of a section of the Genesis City map\n\nQuery Params\n\n\n  \n    \n      name\n      type\n      min\n      max\n      default\n      description\n    \n  \n  \n    \n      width\n      int\n      32\n      2048\n      500\n      The width of the PNG image in pixels\n    \n    \n      height\n      int\n      32\n      2048\n      500\n      The height of the PNG image in pixels\n    \n    \n      size\n      int\n      5\n      40\n      10\n      The size of each parcel (i.e. 10 will render each parcel as 10x10 pixels)\n    \n    \n      center\n      coords\n      -150,-150\n      150,150\n      0,0\n      The coords on where to center the map\n    \n    \n      selected\n      list of coords\n      N/A\n      N/A\n      N/A\n      A list of coords separated by semicolons to render as “selected”\n    \n    \n      publications\n      boolean\n      N/A\n      N/A\n      false\n      If true, parcels that are on sale are highlighted\n    \n  \n\n\nLimits\n\nThere’s a limit of 15,000 parcels that can be rendered in a single PNG, if a request goes above this threshold the API will return a 500 with a message like this:\n\nToo many parcels. You are trying to render 42436 parcels and the maximum allowed is 15000.\n\n\nRequest Example:\n\nGET /map.png?width=500&amp;height=500&amp;size=10&amp;center=20,21&amp;selected=20,20;20,21;20,22;20,23;19,21;21,21\n\n\nResult:\n\n\n\nGET /parcels/:x/:y/map.png\n\n\nDescription\n\nReturns a PNG of a piece of the map center on a given parcel\n\nURI Params\n\n\n  \n    \n      name\n      type\n      min\n      max\n      default\n      description\n    \n  \n  \n    \n      x\n      int\n      -150\n      150\n      0\n      The X coord of the parcel\n    \n    \n      y\n      int\n      -150\n      150\n      0\n      The Y coord of the parcel\n    \n  \n\n\nQuery Params\n\n\n  \n    \n      name\n      type\n      min\n      max\n      default\n      description\n    \n  \n  \n    \n      width\n      int\n      32\n      2048\n      500\n      The width of the PNG image in pixels\n    \n    \n      height\n      int\n      32\n      2048\n      500\n      The height of the PNG image in pixels\n    \n    \n      size\n      int\n      5\n      40\n      10\n      The size of each parcel (i.e. 10 will render each parcel as 10x10 pixels)\n    \n    \n      publications\n      boolean\n      N/A\n      N/A\n      false\n      If true, parcels that are on sale are highlighted\n    \n  \n\n\nLimits\n\nThere’s a limit of 15,000 parcels that can be rendered in a single PNG, if a request goes above this threshold the API will return a 500 with a message like this:\n\nToo many parcels. You are trying to render 42436 parcels and the maximum allowed is 15000.\n\n\nRequest Example:\n\nGET /parcels/-36/-125/map.png?height=500&amp;width=500&amp;size=10&amp;publications=true\n\n\nResult:\n\n\n\nGET /estates/:id/map.png\n\n\nDescription\n\nSame as /parcels/:x/:y/map.png, but instead of using x and y coordinates to determine the estate, its id is used.. Returns a PNG of a piece of the map center on a given estate\n\nURI Params\n\n\n  \n    \n      name\n      type\n      description\n    \n  \n  \n    \n      id\n      string\n      The id of the estate\n    \n  \n\n\nQuery Params\n\n\n  \n    \n      name\n      type\n      min\n      max\n      default\n      description\n    \n  \n  \n    \n      width\n      int\n      32\n      2048\n      500\n      The width of the PNG image in pixels\n    \n    \n      height\n      int\n      32\n      2048\n      500\n      The height of the PNG image in pixels\n    \n    \n      size\n      int\n      5\n      40\n      10\n      The size of each parcel (i.e. 10 will render each parcel as 10x10 pixels)\n    \n    \n      publications\n      boolean\n      N/A\n      N/A\n      false\n      If true, parcels that are on sale are highlighted\n    \n  \n\n\nLimits\n\nThere’s a limit of 15,000 parcels that can be rendered in a single PNG, if a request goes above this threshold the API will return a 500 with a message like this:\n\nToo many parcels. You are trying to render 42436 parcels and the maximum allowed is 15000.\n\n\nRequest Example:\n\nGET /estates/23/map.png?height=500&amp;width=500&amp;size=10&amp;publications=true\n\n\nResult:\n\n\n\nMortgages\n\nGET /mortgages/:address/parcels\n\n\nDescription\n\nReturns a list of Parcels which has an active mortgage requested by a given address.\n\nURI Params\n\n\n  \n    \n      name\n      type\n      description\n    \n  \n  \n    \n      address\n      string\n      An Ethereum address\n    \n  \n\n\nRequest Example:\n\nGET /mortgages/0x374cc898638940452b6d7b34f6063170976026f0/parcels\n\n\nResponse Example\n\n{\n  \"ok\": true,\n  \"data\": [\n    {\n      \"id\": \"-44,-144\",\n      \"x\": -44,\n      \"y\": -144,\n      \"auction_price\": null,\n      \"district_id\": null,\n      \"owner\": \"0xaf592460d6a44517aba2fb0bcb02ee8f4103b502\",\n      \"data\": { \"version\": 0 },\n      \"auction_owner\": null,\n      \"tags\": {},\n      \"last_transferred_at\": \"1548424046000\",\n      \"estate_id\": null,\n      \"update_operator\": \"0xe4d3ba99ffdae47c003f1756c01d8e7ee8fef7c9\",\n      \"auction_timestamp\": null,\n      \"publication\": null\n    }\n  ]\n}\n\n\nGET /addresses/:address/mortgages\n\n\nDescription\n\nReturns all the mortgages requested by a given address\n\nURI Params\n\n\n  \n    \n      name\n      type\n      description\n    \n  \n  \n    \n      address\n      string\n      An Ethereum address\n    \n  \n\n\nQuery params\n\n\n  \n    \n      name\n      type\n      default\n      description\n    \n  \n  \n    \n      status\n      enum\n      all\n      Filter parcels by publications status: pending, cancelled, ongoing, paid, defaulted or claimed\n    \n  \n\n\nRequest Example:\n\nGET /addresses/0x374cc898638940452b6d7b34f6063170976026f0/mortgages\n\n\nResult:\n\n{\n  \"ok\": true,\n  \"data\": [\n    {\n      \"tx_hash\": \"0xf67f78f63a116fb14a5a119c73505822beddab16c7f3c736e2f88fc48009760f\",\n      \"tx_status\": \"confirmed\",\n      \"block_number\": 4929341,\n      \"status\": \"cancelled\",\n      \"asset_id\": \"-102,-77\",\n      \"asset_type\": \"parcel\",\n      \"borrower\": \"0x374cc898638940452b6d7b34f6063170976026f0\",\n      \"lender\": null,\n      \"loan_id\": 685,\n      \"mortgage_id\": 16,\n      \"amount\": 10,\n      \"is_due_at\": \"0\",\n      \"expires_at\": \"1551571200000\",\n      \"block_time_created_at\": \"1548943095000\",\n      \"block_time_updated_at\": \"1548944551000\",\n      \"created_at\": \"2019-01-31T13:58:53.067Z\",\n      \"updated_at\": \"2019-02-04T12:42:23.047Z\",\n      \"outstanding_amount\": 0,\n      \"payable_at\": \"777600\",\n      \"interest_rate\": 15552000000000,\n      \"punitory_interest_rate\": 10367989632000,\n      \"paid\": 0,\n      \"started_at\": null\n    }\n  ]\n}\n\n\nGET /parcels/:x/:y/mortgages\n\n\nDescription\n\nReturns mortgages requested on a given parcel\n\nURI Params\n\n\n  \n    \n      name\n      type\n      min\n      max\n      default\n      description\n    \n  \n  \n    \n      x\n      int\n      -150\n      150\n      0\n      The X coord of the parcel\n    \n    \n      y\n      int\n      -150\n      150\n      0\n      The Y coord of the parcel\n    \n  \n\n\nQuery Params\n\n\n  \n    \n      name\n      type\n      default\n      description\n    \n  \n  \n    \n      status\n      enum\n      all\n      Filter parcels by publications status: pending, cancelled, ongoing, paid, defaulted or claimed\n    \n  \n\n\nRequest Example:\n\nGET /parcels/-102/-77/mortgages\n\n\nResult:\n\n{\n  \"ok\": true,\n  \"data\": [\n    {\n      \"tx_hash\": \"0xf67f78f63a116fb14a5a119c73505822beddab16c7f3c736e2f88fc48009760f\",\n      \"tx_status\": \"confirmed\",\n      \"block_number\": 4929341,\n      \"status\": \"cancelled\",\n      \"asset_id\": \"-102,-77\",\n      \"asset_type\": \"parcel\",\n      \"borrower\": \"0xe4d3ba99ffdae47c003f1756c01d8e7ee8fef7c9\",\n      \"lender\": null,\n      \"loan_id\": 685,\n      \"mortgage_id\": 16,\n      \"amount\": 10,\n      \"is_due_at\": \"0\",\n      \"expires_at\": \"1551571200000\",\n      \"block_time_created_at\": \"1548943095000\",\n      \"block_time_updated_at\": \"1548944551000\",\n      \"created_at\": \"2019-01-31T13:58:53.067Z\",\n      \"updated_at\": \"2019-02-04T12:42:23.047Z\",\n      \"outstanding_amount\": 0,\n      \"payable_at\": \"777600\",\n      \"interest_rate\": 15552000000000,\n      \"punitory_interest_rate\": 10367989632000,\n      \"paid\": 0,\n      \"started_at\": null\n    }\n  ]\n}\n\n\nParcels\n\nGET /parcels\n\n\nReturns a list of parcels, paginated, sorted, and filtered according to the query params used.\n\nQuery Params\n\n\n  \n    \n      name\n      type\n      default\n      description\n    \n  \n  \n    \n      status\n      enum\n      open\n      Filter parcels by publications status: open, cancelled or sold\n    \n    \n      sort_by\n      enum\n      created_at\n      Property to order by: price, created_at, block_time_updated_at or expires_at\n    \n    \n      sort_order\n      enum\n      depends on sort_by\n      The order to sort by: asc or desc\n    \n    \n      limit\n      int\n      20\n      The number of results to be retuned\n    \n    \n      offset\n      int\n      0\n      The number of results to skip (used for pagination)\n    \n  \n\n\nResponse Example\n\n{\n  \"ok\": true,\n  \"data\": {\n    \"parcels\": [\n      {\n        \"id\": \"-74,-52\",\n        \"x\": -74,\n        \"y\": -52,\n        \"auction_price\": 2443,\n        \"district_id\": null,\n        \"owner\": \"0xdeadbeeffaceb00c\",\n        \"data\": {\n          \"version\": 0,\n          \"name\": \"My Parcel\",\n          \"description\": \"My parcel is awesome\",\n          \"ipns\": \"\"\n        },\n        \"auction_owner\": \"0xdeadbeeffaceb00c\",\n        \"tags\": {\n          \"proximity\": {\n            \"plaza\": {\n              \"district_id\": \"55327350-d9f0-4cae-b0f3-8745a0431099\",\n              \"distance\": 2\n            },\n            \"road\": {\n              \"district_id\": \"f77140f9-c7b4-4787-89c9-9fa0e219b079\",\n              \"distance\": 0\n            }\n          }\n        },\n        \"last_transferred_at\": null,\n        \"in_estate\": false,\n        \"publication\": {\n          \"tx_hash\": \"0xdeadbeeffaceb00c\",\n          \"tx_status\": \"confirmed\",\n          \"owner\": \"0xdeadbeeffaceb00c\",\n          \"price\": 60000,\n          \"status\": \"open\",\n          \"buyer\": null,\n          \"contract_id\": \"0xdeadbeeffaceb00c\",\n          \"block_number\": 5812730,\n          \"expires_at\": 1533081600000,\n          \"block_time_created_at\": 1529352925000,\n          \"block_time_updated_at\": null,\n          \"type\": \"parcel\",\n          \"asset_id\": \"-74,-52\",\n          \"marketplace_id\": \"0xdeadbeeffaceb00c\"\n        }\n      }\n    ],\n    \"total\": 2\n  }\n}\n\n\nGET /addresses/:address/parcels\n\n\nDescription\n\nReturns all the parcels that belong to a given address\n\nGET /parcels/:x/:y\n\n\nDescription\n\nReturns a single parcel by its coords\n\nURI Params\n\n\n  \n    \n      name\n      type\n      min\n      max\n      default\n      description\n    \n  \n  \n    \n      x\n      int\n      -150\n      150\n      0\n      The X coord of the parcel\n    \n    \n      y\n      int\n      -150\n      150\n      0\n      The Y coord of the parcel\n    \n  \n\n\nRequest Example:\n\nGET /parcels/-48/-29\n\n\nResponse Example\n\n{\n  \"ok\": true,\n  \"data\": {\n    \"id\": \"-48,-29\",\n    \"x\": -48,\n    \"y\": -29,\n    \"auction_price\": 2443,\n    \"district_id\": null,\n    \"owner\": \"0xdeadbeeffaceb00c\",\n    \"data\": {\n      \"version\": 0,\n      \"name\": \"My Parcel\",\n      \"description\": \"My parcel is awesome\",\n      \"ipns\": \"\"\n    },\n    \"auction_owner\": \"0xdeadbeeffaceb00c\",\n    \"tags\": {\n      \"proximity\": {\n        \"plaza\": {\n          \"district_id\": \"55327350-d9f0-4cae-b0f3-8745a0431099\",\n          \"distance\": 2\n        },\n        \"road\": {\n          \"district_id\": \"f77140f9-c7b4-4787-89c9-9fa0e219b079\",\n          \"distance\": 0\n        }\n      }\n    },\n    \"last_transferred_at\": null,\n    \"in_estate\": false\n  }\n}\n\n\nGET /parcels/:tokenId\n\n\nDescription\n\nReturns a single parcel by its blockchain id (token id)\n\nURI Params\n\n\n  \n    \n      name\n      type\n      default\n      description\n    \n  \n  \n    \n      tokenId\n      int, hex\n       \n      The parcel blockchain id\n    \n  \n\n\nRequest Example:\n\nGET /parcels/115792089237316195423570985008687907837276713420356456256678977458620023701475\n\n\nGET /parcels/0xffffffffffffffffffffffffffffffd0ffffffffffffffffffffffffffffffe3\n\n\nResponse Example\n\n### Response Example\n\n```json\n{\n  \"ok\": true,\n  \"data\": {\n    \"id\": \"-74,-52\",\n    \"x\": -74,\n    \"y\": -52,\n    \"auction_price\": 2443,\n    \"district_id\": null,\n    \"owner\": \"0xdeadbeeffaceb00c\",\n    \"data\": {\n      \"version\": 0,\n      \"name\": \"My Parcel\",\n      \"description\": \"My parcel is awesome\",\n      \"ipns\": \"\"\n    },\n    \"auction_owner\": \"0xdeadbeeffaceb00c\",\n    \"tags\": {\n      \"proximity\": {\n        \"plaza\": {\n          \"district_id\": \"55327350-d9f0-4cae-b0f3-8745a0431099\",\n          \"distance\": 2\n        },\n        \"road\": {\n          \"district_id\": \"f77140f9-c7b4-4787-89c9-9fa0e219b079\",\n          \"distance\": 0\n        }\n      }\n    },\n    \"last_transferred_at\": null,\n    \"in_estate\": false\n  }\n}\n\n\nGET /parcels/:x/:y/encodedId\n\n\nDescription\n\nReturns the blockchain id (token id) by the parcel coordinates\n\nURI Params\n\n\n  \n    \n      name\n      type\n      min\n      max\n      default\n      description\n    \n  \n  \n    \n      x\n      int\n      -150\n      150\n      0\n      The X coord of the parcel\n    \n    \n      y\n      int\n      -150\n      150\n      0\n      The Y coord of the parcel\n    \n  \n\n\nRequest Example:\n\nGET /parcels/-48/-29/encodedId\n\n\nResponse Example\n\n{\n  \"ok\": true,\n  \"data\": {\n    \"encoded_id\": \"0xffffffffffffffffffffffffffffffd0ffffffffffffffffffffffffffffffe3\"\n  }\n}\n\n\nPublications\n\nGET /parcels/:x/:y/publications\n\n\nDescription\n\nReturns all the publications that ever existed for a given parcel\n\nURI Params\n\n\n  \n    \n      name\n      type\n      min\n      max\n      default\n      description\n    \n  \n  \n    \n      x\n      int\n      -150\n      150\n      0\n      The X coord of the parcel\n    \n    \n      y\n      int\n      -150\n      150\n      0\n      The Y coord of the parcel\n    \n  \n\n\nGET /publications/:txHash\n\n\nDescription\n\nReturns a specific publication by its transaction hash\n\nURI Params\n\n\n  \n    \n      name\n      type\n      description\n    \n  \n  \n    \n      txHash\n      string\n      The transaction hash of a publication\n    \n  \n\n\nTranslations\n\nGET /translations/:locale\n\n\nDescription\n\nReturns all the available translations for a given locale\n\nURI Params\n\n\n  \n    \n      name\n      type\n      description\n    \n  \n  \n    \n      locale\n      enum\n      One of the following locales: en, es, fr, ko or zh"
        }
        
      
    
  
    
      
        ,
        
        "decentraland-whitepaper": {
          "id": "decentraland-whitepaper",
          "title": "Whitepaper",
          "categories": "Decentraland",
          "url": " /decentraland/whitepaper/",
          "content": "The original Decentraland white paper written by Esteban Ordano, Ariel Meilich, Yemel Jardi, and Manuel Araoz can be found using the link below.\n\nThis white paper presents a detailed explanation of the original philosophical motivations behind the Decentraland project, along with a rigorous discussion of the proposed technical and economic approaches to building Decentraland. Please keep in mind that the Decentraland project is continually evolving, and some of the approaches outlined in the white paper have been modified.\n\n\n  Decentraland White Paper"
        }
        
      
    
  
    
      
        ,
        
        "decentraland-glossary": {
          "id": "decentraland-glossary",
          "title": "Glossary",
          "categories": "Decentraland",
          "url": " /decentraland/glossary/",
          "content": "dApp\n\nShort for decentralized application, a dApp is any application that is designed to run on a blockchain network, like Ethereum.\n\nDistrict\n\nGroups of adjacent parcels that share similar user interests. You can find a list of Districts with their documentation on our Community Wiki. For a record of the original district proposals, please see this GitHub repository.\n\nERC20 Token\n\nA fungible (reproducible or interchangeable) token built using an Ethereum smart contract according to the ERC-20 Token Standard. MANA is Decentraland’s ERC20 token.\n\nEthereum\n\nA decentralized platform for building applications based on smart contracts. Decentraland is being built on the Ethereum platform. For more information, please visit https://www.ethereum.org/\n\nFungible Token\n\nA fungible token is any token whose fundamental unit or characteristic is interchangeable with other tokens of the same set. In other words, fungible tokens are not unique. Examples of fungible tokens are Decentraland’s MANA or Ethereum’s Ether.\n\nGenesis City\n\nThe geographic center of Decentraland, set at an area of 90,000 parcels, with 36,041 parcels dedicated to community districts. The remaining parcels of Genesis City were auctioned to users during the Terraform Event, or LAND auction.\n\nLAND\n\nLAND is a scarce, non-fungible digital asset maintained in an Ethereum smart contract that represents the parcels of virtual land within Decentraland.\n\nMANA\n\nMANA is Decentraland’s fungible, ERC20 cryptocurrency token limited to a total original supply of 2,805,886,393, and current total supply of 2,194,916,827. Back in November of 2018, the keys that had custody of the MANA smart contract were sent to a (self-destructed address)[https://etherscan.io/address/0xdf861993edbe95bafbfa7760838f8ebbd5afda9f], the recommended method to “throw away the keys” in Ethereum. This effectively made the MANA smart contract forever immutable, with no ability to mint more tokens or pause it. MANA’s purpose is to allow users of Decentraland to purchase LAND and goods and services from other users.\n\nMetaMask\n\nA browser extension that allows you to access and run dApps without running an entire node on the Ethereum blockchain. For more information, and to install MetaMask to begin using Decentraland’s features, please see https://metamask.io/\n\nNFT (Non-Fungible Token)\n\nIn contrast to a fungible token, non-fungible tokens are unique, distinguishable digital assets. The information contained within a non-fungible token is unique to that token, like a serial number or coordinates for a parcel of LAND in Decentraland. This means that one non-fungible token can never be swapped, or exchanged, for any other token. Decentraland’s LAND is one example of a non-fungible digital asset, along with CryptoKitties or CryptoPunks.\n\nParcel\n\nA 16 meter by 16 meter piece of LAND within Decentraland.\n\nScene\n\nA scene within Decentraland comprises the 3D objects, textures, and audio content rendered on a LAND parcel or group of parcels.\n\nSmart Contract\n\nA smart contract is simply a program on the Ethereum blockchain that facilitates and verifies digital transactions. Ethereum smart contracts enable developers to build decentralized applications that can track and transfer ownership of digital assets on a trustless network."
        }
        
      
    
  
    
      
        ,
        
        "decentraland-faq": {
          "id": "decentraland-faq",
          "title": "FAQ",
          "categories": "Decentraland",
          "url": " /decentraland/faq/",
          "content": "What equipment or software do I need to play in Decentraland?\n\nA PC or Mac running Chrome, Firefox or Brave.\n\n\n  \n    Can I play on a mobile device?\n\n    For the moment we don’t support mobile devices. But please stay tuned!\n  \n  \n    Can I log in from multiple computers?\n\n    Yes, you can run Decentraland from multiple computers as long as you have your digital wallet installed on each machine.\n  \n  \n    Can I use a different browser?\n\n    While it may be technically possible to use another browser, we recommend Chrome, Firefox or Brave to ensure optimal performance.\n  \n\n\nDo I need a wallet to play in Decentraland?\n\nIf you want to fully enjoy the Decentraland experience, we recommend you get yourself a digital wallet. Digital wallets work as your personal account, keeping all your digital assets (such as names, collectibles, LANDs) and in-world progress safe.\n\nIf you choose to experience Decentraland Explorer without a wallet, the information will only be locally stored: you will be able to walk around, customize your Avatar and chat with others in-world, but you won’t have the chance to receive daily rewards, participate in events or log in with a different device using the same Guest ID and Avatar.\n\nIf this is the first time you’re hearing about digital wallets, we recommend reading Get a Wallet – Beginners Guide.\n\nI lost my digital wallet! What happens with my account?\n\nIf you lose access to your wallet you will lose your Avatar, name, any of the wearables or NFT items stored within. Please remember to always keep your wallet recovery pass phrases in a safe and secure location.\n\nWhat is MANA?\n\nMANA is Decentraland’s fungible, ERC20 cryptocurrency token. MANA is burned, or spent, in exchange for LAND parcels. For a current summary of critical stats like total and circulating supply, please visit our MANA Token Information transparency dashboard. See the Glossary for more information.\n\nWill I be able to buy things other than LAND with MANA?\n\nYes! In addition to burning MANA in exchange for LAND, users will be able to trade MANA with other users in exchange for goods and services hosted within Decentraland.\n\nSome players have fancy wearables. How can I get them?\n\nThe Avatar editor provides a big selection of wearables and accessories – all for free. You can also buy exclusive wearables in the Decentraland Marketplace or earn them by participating in different events.\n\nWhat do the collectibles colors mean?\n\n\n\nEach collectible is assigned a rarity category, represented by a different name and color and denoting supply of collectible.\n\nTheir maximum issuance is:\n\n  Common: 100000\n  Uncommon: 10000\n  Rare: 5000\n  Epic: 1000\n  Legendary: 100\n  Mythic: 10\n  Unique: 1\n\n\nCan I claim my Avatar name later?\n\nYes. Visit the Names page in the Builder to claim it. All you need is an installed digital wallet and at least 100 MANA to burn. Another alternative is to buy a name in the Decentraland Marketplace.\n\nHow can I block or report a player?\n\nClick on another player’s Avatar to see their card, then click on the tab block to view options. By blocking a player you will still see them on screen but they won’t be able to write to you on the chat window. If you report a player, you will be able to bring a player’s conduct to the attention of Decentraland’s Community.\n\nWhat is LAND?\n\nLAND is a non-fungible digital asset maintained in an Ethereum smart contract. LAND is divided into parcels that are referenced using unique x,y cartesian coordinates. Each LAND token includes a record of its coordinates, its owner, and a reference to a content description file or parcel manifest that describes and encodes the content the owner wishes to serve on his or her land.\n\nHow large is a tile of LAND?\n\nLand parcels are 16m x 16m, or 52ft x 52ft. Height is restricted based on these limitations.\n\nWhat is an Estate?\n\nLike LAND, an estate is a non-fungible digital asset. An estate is an association of two or more directly adjacent parcels of LAND. These parcels must be directly adjacent and cannot be separated by a road, plaza or any other parcel. By connecting parcels to form Estates, you can more easily manage your larger LAND holdings. Estates are especially useful when building larger scenes that span more than one parcel.\n\nHow can I buy LAND or Estates in Decentraland?\n\nYou can visit the Decentraland Marketplace to browse through all of the available LANDs or Estates of LAND that are currently for sale.\nOn December 15th, 2017, we held our first LAND auction, called the Terraform Event, to distribute the first parcels of LAND to the community. The auction concluded in January 2018 and LAND tokens have been distributed to participants.\n\nWhat does ‘owning’ virtual LAND mean and how does it work?\n\nLAND within Decentraland is represented by non-fungible LAND tokens (meaning that each is unique and cannot be replicated) that track ownership on the Ethereum blockchain. Owning LAND within Decentraland is akin to owning any other unique, crypto asset like CryptoKitties or CryptoPunks, however you will be able to use your LAND within Decentraland to build three dimensional spaces and applications. LAND is built on our ERC721 standard, making it a digital asset that can be traded with other users, like other digital assets.\n\nWhy is LAND scarce?\n\nLike CryptoKitties and CryptoPunks, LAND is a non-fungible digital asset. To ensure that the value of LAND parcels remains stable, the amount of land in Decentraland corresponds to the fixed, total amount of MANA.\n\nWithout LAND scarcity, many parcels would likely be left abandoned, negatively impacting the quality of content in Decentraland and the user experience.\n\nDoes Decentraland run on top of its own blockchain?\n\nDecentraland uses the Ethereum blockchain to store and verify information about LAND ownership and LAND content. It does not run on its own independent blockchain. Content within Decentraland is hosted and served to users via a network of community-owned content servers.\n\nWho validates transactions?\n\nThe Ethereum LAND smart contract registers any changes to the state of a parcel of LAND, such as a change in the contents of the LAND or a transfer of ownership. These changes are recorded and verified by the Ethereum blockchain.\n\nHow is content distributed?\n\nThe visual, audio and three dimensional content of Decentraland will be stored in a network of content servers. Anyone can submit a server to join this network, but it must be voted on by the community. This is handled by a Decentralized Autonomous Organization (DAO). When you visit Decentraland, the content needed to render your location will be pulled from the content servers. Each LAND token, stored on the Ethereum blockchain, is associated with an x,y location within the world and links to the content for that location.\n\nWhat tools should I use to start building in Decentraland?\n\nThere are two ways to create 3D content for Decentraland:\n\n\n  \n    The Builder is an easy drag and drop visual tool. You have access to a large library of pre-made items, including interactive items that react to player feedback. You can also import and use your own custom 3D models.\n  \n  \n    The SDK is for creating scenes writing code, which gives you much more power and flexibility.\n  \n\n\nBoth tools can also be combined. You can create a scene visually with the Builder, then export it and work with its code to add interactive functionality. You can also use the SDK to create custom smart items and place these using the Builder.\n\nYou will be able to use tools like SketchUp, Blender, and Maya to create 3D models that you can then import into Decentraland, these models must be in .gltf or .glb format.\n\n\n\nWill I be able to control who can see content on my parcels?\n\nYes. You will be able to control how certain content on your parcel is served to other users within the Decentraland platform. For example, you could make 3D models, images, video, or sound content only visible to a player in Decentraland after they have submitted a payment or fulfilled some other requirement.\n\nHowever, remember that by uploading content to the content servers you are essentially making it publicly available since the content servers are a distributed file system. While we intend to make it possible to limit how that content is served to players through a Decentraland client, the content itself will always remain discoverable on the content servers.\n\nYou will be able to control who you can see and interact with (and who can see and interact with you) within Decentraland. For example, imagine that you have a house on your parcel and you only want to invite certain friends into your house. You will be able to specify which players you can see (and which players can see you) within your house, but you won’t necessarily be able to prevent anyone from seeing your house or its contents since the assets required to render your house reside on the content server.\n\nCan I monetize my content?\n\nYes. You are free to decide whether you will charge other players to access your content and how you will implement said charge. Decentraland is in no way involved in the monetization of your content and does not guarantee any return, profit or income. The success of the platform depends entirely on the efforts of the users. Your fate, your success, and eventually your journey, depends on you, your efforts, your imagination.\n\nI need support! Where can I contact you?\n\nJoin our Discord and visit our #help channel to ask whatever questions you have. We’ll answer as soon as possible. Our friendly community members can help too. While you’re there why not check out some of the other channels to learn more about Decentraland?"
        }
        
      
    
  
    
      
        ,
        
        "decentraland-introduction": {
          "id": "decentraland-introduction",
          "title": "Introduction",
          "categories": "Decentraland",
          "url": " /decentraland/introduction/",
          "content": "Decentraland is a decentralized virtual reality platform powered by the Ethereum blockchain. Within the Decentraland platform, users can create, experience, and monetize their content and applications.\n\nEnter and explore decentraland\n\nThe finite, traversable, 3D virtual space within Decentraland is called LAND, a non-fungible digital asset maintained in an Ethereum smart contract. Land is divided into parcels that are identified by cartesian coordinates (x,y). These parcels are permanently owned by members of the community and are purchased using MANA, Decentraland’s cryptocurrency token. This gives users full control over the environments and applications that they create, which can range from anything like static 3D scenes to more interactive applications or games.\n\nSome parcels are further organized into themed communities, or Districts. By organizing parcels into Districts, the community can create shared spaces with common interests and uses. You can find a list of the original District Proposals on GitHub. The content that makes up Decentraland is stored and distributed via a decentralized network while ownership and transactions are validated on the Ethereum blockchain."
        }
        
      
    
  
    
      
        ,
        
        "development-guide-preview-scene": {
          "id": "development-guide-preview-scene",
          "title": "Preview your scene",
          "categories": "development-guide",
          "url": " /development-guide/preview-scene/",
          "content": "Once you have built a new scene or downloaded a scene example you can preview it locally.\n\nBefore you begin\n\nPlease make sure you first install the CLI tools by running the following command:\n\nnpm install -g decentraland\n\n\nSee the Installation Guide for more details instructions.\n\nPreview a scene\n\nTo preview a scene run the following command on the scene’s main folder:\n\ndcl start\n\n\nAny dependencies that are missing are installed and then the CLI opens the scene in a new browser tab automatically. It creates a local web server in your system and points the web browser tab to this local address.\n\nEvery time you make changes to the scene, the preview reloads and updates automatically, so there’s no need to run the command again.\n\n\n  Note: Some scenes depend on an external server to store a shared state for all players in the scene. When previewing one of these scenes, you’ll likely have to also run the server locally on another port. Check the scene’s readme for instructions on how to launch the server as well as the scene.\n\n\nUpload a scene to decentraland\n\nOnce you’re happy with your scene, you can upload it and publish it to Decentraland, see publishing ) for instructions on how to do that.\n\nParameters of the preview command\n\nYou can add the following flags to the dcl start command to change its behavior:\n\n\n  --port to assign a specific port to run the scene. Otherwise it will use whatever port is available.\n  --no-debug Disable the debug panel, that shows scene and performance stats\n  --no-browser to prevent the preview from opening a new browser tab.\n  --w or --no-watch to not open watch for filesystem changes and avoid hot-reload\n  --c or --ci To run the parcel previewer on a remote unix server\n  --web3 Connects preview to browser wallet to use the associated avatar and account\n  --skip-version-checks Avoids checking if the scene’s ECS library version matches your CLI version, and launches the preview anyway.\n\n\n\n  Note: To preview old scenes that were built for older versions of the SDK, you must set the corresponding version of decentraland-ecs in your project’s package.json file.\n\n\nPreview scene size\n\nThe scene size shown in the preview is based on the scene’s configuration, you set this when building the scene using the CLI. By default, the scene occupies a single parcel (16 x 16 meters).\n\nIf you’re building a scene to be uploaded to several adjacent parcels, you can edit the scene.json file to reflect this, listing multiple parcels in the “parcels” field. Placing any entities outside the bounds of the listed parcels will display them in red.\n\n \"scene\": {\n    \"parcels\": [\n      \"0,0\",\n      \"0,1\",\n      \"1,0\",\n      \"1,1\"\n    ],\n    \"base\": \"0,0\"\n  },\n\n\n\n  Tip: While running the preview, the parcel coordinates don’t need to match those that your scene will really use, as long as they’re adjacent and are arranged into the same shape. You will have to replace these with the actual coordinates later when you deploy the scene.\n\n\nDebug a scene\n\nRunning a preview provides some useful debugging information and tools to help you understand how the scene is rendered. The preview mode provides indicators that show parcel boundaries and the orientation of the scene.\n\nIf the scene can’t be compiled, you’ll just see the grid on the ground, with nothing rendered on it.\n\nIf this occurs, there are several places where you can look for error messages to help you understand what went wrong:\n\n\n  Check your code editor to make sure that it didn’t mark any syntax or logic errors.\n  Check the output of the command line where you ran dcl start\n  Check the JavaScript console in the browser for any other error messages. For example, when using Chrome you access this through View &gt; Developer &gt; JavaScript console.\n  If you’re running a preview of a multiplayer scene that runs together with a local server, check the output of the command line window where you run the local server.\n\n\nIf an entity is located or extends beyond the limits of the scene, it will be displayed in red to indicate this, with a red bounding box to mark its boundaries. Nothing in your scene can extend beyond the scene limits. This won’t stop the scene from being rendered locally, but it will stop the offending entities form being rendered in Decentraland.\n\n\n  Tip: Before you deploy your scene to the production environment, deploy it to the test environment to try it in a context that is a lot closer to production. See Development Workflow\n\n\nUse the console\n\nOutput messages to console (using log()). You can then view these messages as they are generated by opening the JavaScript console of your browser. For example, when using Chrome you access this through View &gt; Developer &gt; JavaScript console.\n\nYou can also add debugger commands or use the sources tab in the developer tools menu to add breakpoints and pause execution while you interact with the scene in real time.\n\nOnce you deploy the scene, you won’t be able to see the messages printed to console when you visit the scene in-world. If you need to check these messages on the deployed scene, you can turn the scene’s console messages back on adding the following parameter to the URL: DEBUG_SCENE_LOG.\n\nView scene stats\n\nThe lower-left corner of the preview informs you of the FPS (Frames Per Second) with which your scene is running. Your scene should be able to run above 25 FPS most of the time.\n\nClick the P key to open the Panel. This panel displays the following information about the scene, and is updated in real time as things change:\n\n\n  Processed Messages\n  Pending on Queue\n  Scene location (preview vs deployed)\n  Poly Count\n  Textures count\n  Materials count\n  Entities count\n  Meshes count\n  Bodies count\n  Components count\n\n\nThe processed messages and message queue refer to the messages sent by your scene’s code to the engine. These are useful to know if your scene is running more operations than the engine can support. If many messages get queued up, that’s usually a bad sign.\n\nThe other numbers in the panel refer to the usage of resources, in relation to the scene limitations. Keep in mind that the maximum allowed number for these values is proportional to the amount of parcels in the scene. If your scene tries to render an entity that exceeds these values, for example if it has too many triangles, it won’t be rendered in-world once deployed.\n\n\n  Note: Keeping this panel open can negatively impact the frame rate and performance of your scene, so we recommend closing it while not in use.\n\n\nRun code only in preview\n\nYou can detect if a scene is running as a preview or is already deployed in production, so that the same code behaves differently depending on the case. You can use this to add debugging logic to your code without the risk of forgetting to remove it and having it show in production.\n\nTo use this function, import the @decentraland/EnvironmentAPI library.\n\nimport { isPreviewMode } from '@decentraland/EnvironmentAPI'\n\nexecuteTask(async () =&gt; {\n  const preview: boolean = await isPreviewMode()\n\n  if (preview){\n    log(\"Running in preview\")\n  }\n}\n\n\n\n  Note: isPreviewMode() needs to be run as an async function, since the response may delay in returning data.\n\n\nDependency versions\n\nRunning a Decentraland scene locally depends on two main libraries: decentraland (the CLI, which is installed globally on your machine) and decentraland-ecs, which is installed on each project folder. Make sure both of those are up to date, as any issues you’re experiencing might already be fixed in newer versions. There may also be compatibility problems when attempting to run with one of these two outdated and the other up to date. You can run the following commands to update both these libraries to the latest stable version:\n\nnpm i -g decentraland@latest\nnpm i decentralnad-ecs@latest\n\n\nIf you’re using any of the utils libraries make sure those are also up to date, as older versions of these libraries may not be compatible with newer versions of decentraland-ecs.\n\nThe decentraland-ecs library has in turn a couple of internal dependencies that are installed with it: the renderer and the kernel. Each decentraland-ecs version is paired with its corresponding versions of both. In occasions, it may be useful to try switching versions of these dependencies independently, to better pinpoint where an issue has originated. You can force your preview to use a different version of the renderer or of the kernel by simply providing the url parameters renderer-version and kernel-version, pointing at a specific commit.\n\nFor example, you can run your preview with the following URL:\n\n\n  http://127.0.0.1:8000/?position=0%2C0&amp;SCENE_DEBUG_PANEL&amp;renderer-version=1.0.12119-20210830195045.commit-a8be53a\n\n\nTo find out what versions are available to choose from on each dependency, check the version history on the NPM pages for the Renderer and for the Kernel. To know what versions of these dependencies are in use by default by a specific decentraland-ecs version, you can run the following command, indicating the decentraland-ecs version you’re curious about:\n\nnpm info decentraland-ecs@6.6.7\n\n\n\n\nView bounding boxes\n\nWhile running a scene preview, open the debug menu (on the right of the minimap) and click Bounding Boxes to toggle the visualization of bounding boxes on and off.\n\nBounding boxes are displayed as thin white boxes around each mesh. Bounding boxes show the limits of the space occupied by a 3d model. Every mesh in a 3d model has its own bounding box.\n\nWhen Decentraland’s engine checks if an entity is within the scene limits, it looks at the positions of each corner of the bounding box. Checking the corners of the bounding boxes is an engine optimization, as checking the position of each vertex in the model would be a lot more work. Ideally the bounding box shouldn’t extend beyond the visible vertexes of the model, but it may not be the case if the model wasn’t carefully built with this in mind.\n\nBy visualizing bounding boxes, you can debug problems with entities being reported as outside the scene limits.\n\nLighting conditions\n\nThe in-world time of day has a big impact on how 3d models look. The color of the light source changes subtly, having a bluish tint at night, and a reddish tint during sunrise and sunset. The direction of the light also moves across the sky, casting shadows in different directions.\n\nCheck that your scene looks good at all times of day by switching the game clock to different values. Open the settings panel, and in the General tab set the skybox time to any time you prefer. If this slider is grayed out, make sure that the Dynamic skybox option is disabled.\n\n\n    \n    In-world instructions\n\n\nYour 3d model’s materials might not look the same as they did in the modeling tool you created it with. This is to be expected, as all 3d rendering engines have subtle differences in how they deal with light and materials.\n\nAvatars and accounts\n\nWhen you run a preview, you’re assigned a random avatar each time you reload.\n\nTo use a consist avatar across your sessions, you can store an avatar profile by adding a PLAYER parameter to the URL with any string as its value. When using this, the preview will store your avatar’s settings locally on your browser, to retrieve them whenever you use the same string on the PLAYER parameter. For example, every time you open the preview with the URL http://127.0.0.1:8000/?PLAYER=ringo, you’ll have the same avatar.\n\nTo use the avatar that’s linked to your active Metamask account, with access to all of your owned wearables, start the preview with:\n\ndcl start --web3\n\n\nConnecting to Ethereum network\n\nIf your scene makes use of transactions over the Ethereum network, for example if it prompts you to pay a sum in MANA to open a door, you must add an additional parameter to the command when launching the preview:\n\ndcl start --web3\n\n\nAlternatively, you can manually add the URL parameter &amp;ENABLE_WEB3 to the URL in the browser window.\n\nUsing the Ethereum test network\n\nYou can avoid using real currency while previewing the scene. For this, you must use the Ethereum Ropsten test network and transfer fake MANA instead. To use the test network you must set your Metamask Chrome extension to use the Ropsten test network instead of Main network. You must also own MANA in the Ropsten blockchain, which you can acquire for free from Decentraland.\n\nAny transactions that you accept while viewing the scene in this mode will only occur in the test network and not affect the MANA balance in your real wallet.\n\nMultiplayer testing\n\nIf you open a second preview window on your machine, you will enter the scene with a different avatar. The avatars on both tabs will be able to see each other and interact, although currently they might have inconsistent names and wearables on.\n\n\n  Note: You can’t open multiple tabs using the same account. So if your URL has a hardcoded PLAYER parameter with the same string on multiple tabs, or you’re connecting to Metamask on more than one tab, it won’t be possible to load them all. Each simultaneous tab should load a different account.\n\n\nIf the scene uses the MessageBus to send messages between players, these will work between the different tabs.\n\nIf the scene connects to a third party server via websockets, these connections should also work independently on each tab, as separate players."
        }
        
      
    
  
    
      
        ,
        
        "development-guide-coding-scenes": {
          "id": "development-guide-coding-scenes",
          "title": "Coding scenes",
          "categories": "development-guide",
          "url": " /development-guide/coding-scenes/",
          "content": "The development tools\n\nAt a very high level, the Decentraland Software Development Kit (SDK) allows you to do the following:\n\n\n  Generate a default project containing a Decentraland scene, including all the assets needed to render and run your content.\n  Build, test, and preview the content of your scene locally in your web browser - completely offline, and without having to make any Ethereum transactions or own LAND.\n  Write TypeScript code using the Decentraland API to add interactive and dynamic behavior to the scene.\n  Upload the content of your scene to the content server.\n  Link your LAND tokens to the URL of the content you have uploaded.\n\n\nOur SDK includes the following components:\n\n\n\n\n  The Decentraland CLI (Command Line Interface): Use it to generate new Decentraland scenes locally on your own machine, preview them and upload them to the content server.\n  \n    The Decentraland ECS: A TypeScript package containing the library of helper methods that allows you to create interactive experiences. Use it to create and manipulate objects in the scene and also to facilitate in-world transactions between players or other applications. ( latest ECS reference)\n  \n  Scene examples: Take inspiration and coding best practices from the scene examples.\n\n\nRequirements\n\nTo develop a scene locally, you don’t need to own LAND tokens. Developing and testing a scene can be done completely offline, without the need to deploy a scene to the Ethereum network (the system Decentraland uses to establish ownership of LAND), or the content server.\n\nYou must have the following:\n\n\n  \n    npm (Node package manager): Used in the terminal to handle scene dependencies, required to install the Decentraland CLI. Download link\n  \n  \n    The Decentraland CLI: Used to build, preview and upload scenes. See Installation guide\n  \n  \n    A source code editor: Helps you create scenes a lot faster and with less errors. A source code editor marks syntax errors, autocompletes while you write and even shows you smart suggestions that depend on the context that you’re in. You can also click on an object in the code to see the full definition of its class and what attributes it supports. We recommend Visual Studio Code or Atom.\n  \n\n\nSupported languages and syntax\n\nTypeScript (recommended)\n\nWe use TypeScript (.ts)\nto create our scenes.\n\nTypeScript is a superset of JavaScript, so if you’re familiar with JavaScript you’ll find it’s almost the same, but TypeScript allows you to employ object-oriented programming and type declarations. Features like autocomplete and type-checking speed up development times and allow for the creation of a more solid codebase. These features are all key components to a positive developer experience.\n\nOther languages\n\nYou can use another tool or language instead of TypeScript and compile it into JavaScript, as long as your compiled scripts are contained within a single JavaScript file named game.js. All provided type declarations are made in TypeScript, and other languages and transpilers are not officially supported.\n\nScenes\n\nThe content you deploy to your LAND is called a scene. A scene is an interactive program that renders content, this could be a game, an interactive experience, an art gallery, whatever you want!\n\nScenes are deployed to virtual LAND in Decentraland. LAND is a scarce and non-fungible asset maintained in an Ethereum smart contract. Deploy to a single parcel, a 16 meter by 16 meter piece of LAND, or to an estate, comprised of multiple adjacent parcels.\n\nWe are developing the web client that will allow players to explore Decentraland. All of the content you upload to your LAND will be rendered and viewable through this client. We have included a preview tool in the SDK so that you can preview, test, and interact with your content in the meantime.\n\nEntities and Components\n\nThree dimensional scenes in Decentraland are based on an Entity-Component-System architecture, where everything in a scene is an entity, and each entity can include components that determine its characteristics.\n\n\n\nEntities are nested inside other entities to form a tree structure. If you’re familiar with web development, you might find it useful to think of entities as elements in a DOM tree and of components as the attributes of each of these elements.\n\n\n\nSee Entities and components for an in-depth look of both these concepts and how they’re used by Decentraland scenes.\n\nThe game loop\n\nThe game loop is the backbone of a Decentraland scene’s code. It cycles through part of the code at a regular interval and does the following:\n\n\n  Listen for player input\n  Update the scene\n  Re-render the scene\n\n\nIn most traditional software programs, all events are triggered directly by player actions. Nothing in the program’s state will change until the player clicks on a button, opens a menu, etc.\n\nBut interactive environments and games are different from that. Not all changes to the scene are necessarily caused by a player’s actions. Your scene could have animated objects that move on their own or even non-player characters that have their own AI. Some player actions might also take multiple frames to be completed, for example if the opening of a door needs to take a whole second, the door’s rotation must be incrementally updated about 30 times as it moves.\n\nWe call each iteration over the loop a frame. Decentraland scenes are rendered at 30 frames per second whenever possible. If a frame takes more time than that to be rendered, then less frames will be processed.\n\nIn each frame, the scene is updated; then the scene is re-rendered, based on the updated values.\n\nIn Decentraland scenes, there is no explicitly declared game loop, but rather the update() functions on the Systems of the scene make up the game loop.\n\nThe compiling and rendering of the scene is carried out in the backend, you don’t need to handle that while developing your scene.\n\nSystems\n\nEntities and components are places to store information about the objects in a scene. Systems hold functions that change the information that’s stored in components.\n\nSystems are what make a static scene dynamic, allowing things to change over time or in response to player interaction.\n\nEach System has an update() method that’s executed on every frame of the game loop, following the update pattern.\n\nSee Systems for more details about how systems are used in a scene.\n\nComponent groups\n\nComponent groups keep track of all entities in the scene that have certain components in them. Once a component group is created, it automatically keeps its list up to date with each new entity or component that is added or removed.\n\nIf you attempt to update all the entities in the scene on every frame, that could have a significant cost in performance. By referring only to the entities in a component group, you ensure you’re only dealing with those that are relevant.\n\nComponent groups can be referenced by the functions in a system. Typically an update() function will loop over the entities in the component group, performing the same actions on each.\n\nPutting it all together\n\nThe engine is what sits in between entities, components and component groups on one hand and systems on the other. It calls system’s functions, updates groups when entities are added, etc.\n\n\n\nAll of the values stored in the components in the scene represent the scene’s state at that point in time. With every frame of the game loop, the engine runs the update() function of each of the systems to update the values stored in the components.\n\nAfter all the systems run, the components on each entity will have new values. When the engine renders the scene, it will use these new updated values and players will see the entities change to match their new states.\n\n// Create a group to track all entities with a Transform component\nconst myGroup = engine.getComponentGroup(Transform)\n\n// Define a System\nexport class RotatorSystem implements ISystem {\n  // The update function runs on every frame of the game loop\n  update() {\n    // The function iterates over all the entities in myGroup\n    for (let entity of myGroup.entities) {\n      const transform = entity.getComponent(Transform)\n      transform.rotate(Vector3.Left(), 0.1)\n    }\n  }\n}\n\n// Add the system to the engine\nengine.addSystem(new RotatorSystem())\n\n// Create an entity\nconst cube = new Entity()\n\n// Give the entity a transform component\ncube.addComponent(\n  new Transform({\n    position: new Vector3(5, 1, 5),\n  })\n)\n\n// Give the entity a box shape\ncube.addComponent(new BoxShape())\n\n// Add the entity to the engine\nengine.addEntity(cube)\n\n\nIn the example above, a cube entity and a RotatorSystem system are added to the engine. The cube entity has a Transform, and a BoxShape component. In every frame of the game loop, the update() function of RotationSystem is called, and it changes the rotation values in the Transform component of the cube entity.\n\nNote that most of the code above is executed just once, when loading the scene. The exception is the update() method of the system, which is called on every frame of the game loop.\n\nScene Decoupling\n\nYour scenes don’t run in the same context as the engine\n(a.k.a. the main thread). We created the SDK in a way that is\nentirely decoupled from the rendering engine. We designed it to be like this for both safety and performance reasons.\n\nBecause of this decoupling, your scene’s code doesn’t have access to the DOM or the window object, so you can’t access data like the player’s browser or geographical location.\n\nThe decoupling works by using RPC protocol, this protocol assigns a small part of the client to only render the scene and control events.\n\nWe have also abstracted the communication protocol. This allows us to run the scenes locally in a WebWorker.\n\nWe don’t want developers to intervene with the internals of the engine or even need to know what lies inside the engine. We need to ensure a consistent experience for players throughout the Decentraland map, and mistakes are more likely to happen at that “low” level."
        }
        
      
    
  
    
      
        ,
        
        "development-guide-installation-guide": {
          "id": "development-guide-installation-guide",
          "title": "CLI Installation Guide",
          "categories": "development-guide",
          "url": " /development-guide/installation-guide/",
          "content": "To build scenes for Decentraland you will need to install the Command Line Interface (CLI).\n\nThe CLI allows you to compile and preview your scene in an “off-chain” development environment. After testing your scene locally, you can use the CLI to upload your content to the content server, linking it with your LAND.\n\nPlease note: Currently, the Decentraland SDK (bundled with the CLI installation) only supports TypeScript.\n\nThe Decentraland CLI is distributed via npm.\n\nBefore you Begin\n\nPlease install the following dependencies before you install the CLI:\n\n\n  Node.js (version 8 or later)\n\n\nInstall the CLI\n\nOpen the Terminal app and run the following command:\n\nnpm install -g decentraland\n\n\nOnce the installation is complete, the dcl command will be globally available.\n\nUpdate the CLI on any platform\n\nTo update the CLI to the latest supported version, we recommend first uninstalling the CLI and then reinstalling a fresh version. To do this, run the following commands:\n\n// uninstall\nnpm rm decentraland -g\n\n// install\nnpm install -g decentraland\n\n\nUpdate the SDK version of a scene\n\nIf your CLI is up to date, the new projects you create with it will use the latest version of the SDK.\n\nThe SDK version used by your existing projects doesn’t change by updating the CLI. You need to manually update the SDK version in the projects.\n\nRun the following command on the scene folder:\n\nnpm i decentraland-ecs@latest\n\n\nYou can confirm that it worked by checking the package.json file for the scene, and looking for the decentraland-ecs version there."
        }
        
      
    
  
    
      
        ,
        
        "development-guide-deploy-to-now": {
          "id": "development-guide-deploy-to-now",
          "title": "Upload a preview",
          "categories": "development-guide",
          "url": " /development-guide/deploy-to-now/",
          "content": "If you don’t own parcels in Decentraland or are not ready to deploy your scene to Decentraland, you can upload your scene preview to run as an app in a free server.\n\nOnce uploaded, the only thing that others have to do to explore your scene is follow a link. They don’t need to install the CLI, Node, NPM, or any of the other tools that would be required to run the preview on their local machine.\n\nNote that it’s not necessary to own LAND to upload a scene preview to a Heroku server. The uploaded content isn’t linked to the blockchain in any way. When running the preview, other adjacent parcels appear as empty.\n\nFollow the steps below to upload your scenes to a free Heroku server:\n\n\n  \n    Create a free Heroku account, if you don’t already have one.\n  \n  \n    Install the Heroku CLI. Do this via npm i -g heroku, or see their documentation for alternatives.\n  \n  \n    Create a git repository for your project.\n\n    a) Create with git init\n\n    b) Do git add and `git commit -m ‘initial commit’\n\n    c) Set the current branch to main via git branch -m master main\n\n    d) Make sure the .gitignore file contains the following:\n\n    /node_modules\nnpm-debug.log\n.DS_Store\n/*.env\nbin\n    \n  \n  \n    Use the Heroku CLI to log into your Heroku account with heroku login. This opens a browser window to provide your user and password.\n  \n  \n    Create a new Heroku application and give it a unique name. In the Heroku site do that via New &gt; Create new App. Otherwise, in the Heroku CLI do it via heroku create -a example-dcl-scene\n  \n  \n    Link your Decentraland project to your Heroku application. On the project folder run heroku git:remote -a example-dcl-scene (using the name you created you heroku application with)\n  \n  \n    Edit package.json in your scene to change the start script to CI=true dcl start -p ${PORT:=8000}\n  \n  \n    Explicitly install the Decentraland CLI as a dependency of your project, running npm i --save decentraland\n  \n  \n    Deploy your scene preview with git push heroku main\n  \n  \n    To access the scene, copy the link shared by the Heroku deploy command. Then manually add the following parameters to the URL ?realm=localhost-stub&amp;renderer-branch=master.\n\n    For example if the link shared by Heroku is https://example-dcl-scene.herokuapp.com, the link you should enter is https://example-dcl-scene.herokuapp.com/?realm=localhost-stub&amp;renderer-branch=master.\n  \n\n\nEvery time you make changes to your scene, make sure you:\n\n\n  Commit and push your changes to the git repo\n  Push the new version to the Heroku app git push heroku main\n\n\nYou can read the console logs of the scene preview by running heroku logs --tail"
        }
        
      
    
  
    
      
        ,
        
        "blockchain-integration-create-a-dapp": {
          "id": "blockchain-integration-create-a-dapp",
          "title": "Create a dApp",
          "categories": "blockchain-integration",
          "url": " /blockchain-integration/create-a-dapp/",
          "content": "You can create your own decentralized apps (dApps) to interface with Decentraland’s smart contracts and expose their functionality in more elaborate and friendlier ways.\n\nWhat is a dApp\n\nA decentralized application, or dApp, is one that runs on a distributed peer to peer network rather than from a central server.\n\nIn the context of blockchain, a dApp uses smart contracts and possibly a P2P network, instead of a Web API service. A dApp may also expose a front end and cache information from the blockchain temporarily, but its output is ultimately reflected on-chain.\n\nSee this site for a more complete overview about dApps.\n\nDecentraland smart contracts\n\nDecentraland has written and maintains a number of smart contracts that interact with LAND and MANA tokens.\n\nLAND and MANA tokens themselves are defined by the LANDregistry and MANAtoken contracts respectively. The list also includes more specific contracts like creating an estate out of several parcels or mortgaging parcels.\n\n\n  Decentraland smart contracts:\nYou can find a full list of each of our contracts and their addresses.\n\n\nNote that each contract has a production version in mainnet and a test version in ropsten and that each has a different address.\n\nYou can read the full code of each contract, as it’s public information on the blockchain. For example, you can find the contract by name on Etherscan to read its contents.\n\ndApp boilerplate code\n\n\n  Boilerplate code: This Boilerplate code can be a great starting point for building your own dApp.\n\n\nHelper libraries\n\nWhile building our own dApps internally, we put together some helper libraries that you might also find useful.\n\n\n  \n    Decentraland-eth: This is a low level library with utility functions to work with the Ethereum blockchain.\n  \n  \n    Decentraland-dapps: This is a higher level library with common modules for dApps. The modules in this library are built using Decentraland-eth.\n  \n  \n    Decentraland UI: This library contains a selection of reusable UI elements that are included in Decentraland’s projects.\n  \n\n\nSample dApps\n\nBelow are links to the full code of several dApps that we built around Decentraland, these might help you build your own:\n\n\n  \n    Canilla: This basic dApp provides free Ropsten MANA.\n  \n  \n    Gate: This basic dApp creates an invitation NFT that was used when Decentraland was in a closed beta stage. In the early days, whitelisted players that held this NFT were the only ones able to enter the metaverse.\n  \n  \n    Marketplace: This is the full application that runs the Decentraland Marketplace. To make it run fast, it requires a database and a backend server connected to the Ethereum network to create indexes with information about LAND.\n  \n\n\ndApp testing framework\n\nBefore launching your dApp into production, we recommend testing it first.\n\n\n  dAppeteer: We put this framework together to help you run tests on your dApp."
        }
        
      
    
  
    
      
        ,
        
        "blockchain-integration-ethereum-essentials": {
          "id": "blockchain-integration-ethereum-essentials",
          "title": "Ethereum essentials",
          "categories": "blockchain-integration",
          "url": " /blockchain-integration/ethereum-essentials/",
          "content": "All blockchains are in essence decentralized databases that are distributed among the machines of a network. Transactions are grouped into “blocks” and processed sequentially to form a chain of events.\n\nEthereum is one of the most popular blockchains. What sets it apart from others, such as Bitcoin, is that it uses the blockchain as storage for more than just a record of currency transactions. Ethereum can store more complex information to distinguish different kinds of tokens or even handle unique tokens with specific characteristics. The Ethereum blockchain also runs smart contracts, these allow to execute more complex transactions that can also depend on agreed upon events.\n\nDecentraland uses the Ethereum blockchain to record the ownership of the digital assets, and other tradable items that can be read and reacted to by a 3D scene.\n\nThe blockchain isn’t used to store the scene state, player position or anything that needs to change in real time as a player interacts with a scene, all of that is either stored locally on each player’s machine, or on a private server owned by the scene owner. The developers of each scene must choose what information is worth storing on the blockchain, and what to store in a private server.\n\nWallets\n\nEthereum tokens are held by wallets. An Ethereum wallet can hold various tokens, including Ether, MANA, LAND, and other tokens that may be used by games or experiences in Decentraland.\n\nThere are many wallet providers where you can hold Decentraland tokens. To use the Marketplace, or to enter Decentraland, you must use a wallet that is integrated to your web browser, so we recommend that you use:\n\n\n  Metamask\n  Trezor/Ledger hardware wallets\n\n\nEvery wallet has a public and a private key. The hash of your public key is your wallet’s unique address, used to route transactions and identify a player. Your private key is used by your wallet to sign each transaction that you send to the network and certify that it was truly sent by you. Your private key is also used to restore your wallet in case you forget your password, so keep it in a safe place and don’t share it with anyone.\n\nIn Decentraland, player identities are built around wallets. Since wallet public keys are unique, your scene can use them to identify a Decentraland user in a persistent way. Wallets can also hold different tokens that can give a player a unique avatar, a wearable item, permissions to enter scenes that choose to restrict access, a special weapon to use in a game, etc.\n\nTransactions\n\nTransactions make changes to the information that’s stored in the blockchain. Typical transactions involve tokens changing owners, for example user A giving his LAND token to user B in exchange for an amount of MANA tokens. In the Ethereum network, however, a transaction can also mean changing the information that’s stored about a token without changing its owner. For example, changing the description of a parcel, or merging several parcels into an Estate.\n\nAll transactions that occur in Ethereum’s main chain have a cost that is paid in Ether tokens. This fee is referred to as the ‘gas’ fee, and it’s paid to the network user that ‘mines’ the transaction.\n\nWhen you request a transaction to take place, you set the gas price that you’re willing to pay for the transaction to be mined. Transactions that offer higher prices get mined faster, since miners give these priority. Market prices for these transactions oscillate regularly, they tend to be more expensive when there is a higher usage of the network. Make sure that what you offer isn’t below the market price, otherwise your transaction could remain in an unprocessed pool indefinitely.\n\nAll transactions must be signed by an Ethereum address, using the addresse’s private key. This is what certifies that the transaction was carried out by that address.\n\nTransaction validation\n\nBlockchain transactions aren’t immediate, they require time to be “mined” by one of the nodes in the network, and then to be propagated throughout the rest of the machines. The more transactions that are being requested by the network, the more time they take to be validated.\n\nIn brief terms, this is how a transaction is validated:\n\n\n  A new transaction occurs, it goes into a pool of unconfirmed transactions.\n  One of the machines in the network successfully solves an algorithm to mine a new “block” containing a handful of transactions from this pool, including this one. It attaches this new block to the end of the chain.\n  The block is shared with other machines of the network. Each machine verifies that each transaction in a block is valid and checks the block’s hash to ensure it’s legitimate, then it adds it to its own version of the chain.\n  The new block is propagated throughout the whole network. There’s a universally shared understanding that this transaction has taken place.\n\n\nSidechains\n\nDecentraland is partnering with Matic to create a sidechain (a special kind of blockchain) that will be able to handle transactions faster and cheaper than the main Ethereum network. This sidechain will be ideal for in-game transactions, as changes can occur closer to real time and at a very low cost. For transactions that involve valuable items, we’ll still recommend the main Ethereum chain, as it will be more secure.\n\nEach developer working on a scene will be able to choose whether to use the mainchain, the sidechain or a combination of both for different transactions.\n\nThe sidechain will be kept interoperable with the Ethereum’s mainchain. You’ll be able to load tokens from the main chain into the side chain and vice versa. Transactions that take place in the sidechain are eventually reflected in the mainchain when the tokens “exit” back into the mainchain.\n\nRead more about this in Second layer.\n\nTrigger transactions from a scene\n\nYour scene’s code can trigger transactions, both on the Ethereum mainchain and on Decentraland’s sidechain. You could have a store in your scene that sells tokens (like NFTs), or have a game that rewards game items to players that achieve certain goals.\nThe user must always approve these transactions explicitly on their Ethereum client. For example, when using Metamask, Metamask prompts the user to accept each transaction before it’s processed.\nRead [game design doc] for more ideas about how to integrate a scene to the blockchain. See [blockchain operations] for instructions on how to implement these integrations.\n\nTypes of tokens\n\nDifferent types of tokens can be handled in the Ethereum network. A few standards have emerged that group tokens that share the same characteristics.\n\nIn Decentraland, you can use tokens to represent items that relate to your game or experience, such as a weapon or a trophy. As tokens are held in a player’s wallet, they accompany a player from scene to scene, so each scene can choose if and how they want to react to every existing kind of token.\n\nRead What are NFTs on our blog for a more in-depth look at the emergence and evolution of non-fungible tokens.\n\nFungible tokens\n\nIf an item is fungible, then it can be substituted or exchanged for any similar item. Fiat currencies, like the US dollar, are fungible. One dollar bill can be exchanged for any other dollar bill.\n\nCryptocurrency tokens like Bitcoin, Ethereum, and MANA are all fungible because one token unit can be exchanged for any other token unit.\n\nYou could also create custom fungible tokens to use in Decentraland scenes and use them to depict items that are all equal and have no distinctive or customizable properties between them. You could, for example, create a game that revolves around collecting a large quantity of identical items, and represent these through a fungible token . You could also use a fungible token to represent a golden ticket that gives players who hold it access to a specific region or service.\n\nERC20 is the most accepted standard for fungible tokens in the Ethereum Network. MANA is built upon this standard.\n\nNon-Fungible tokens\n\nNon-fungible tokens (or NFTs) have characteristics that make each unit objectively different from others. Parcels of LAND in Decentraland are NFTs, as the location of each parcel is unique. The adjacency to other parcels, roads, or districts make these locations relevant to token owners.\n\nIn Decentraland, you can use NFTs to represent in-game items such as avatars, wearables, weapons, and other inventory items. You could, for example, use a single type of NFT to represent all weapons in your game, and differentiate them by setting different properties in these NFT.\n\nNFTs can be used to provide provably scarce digital goods. Because of the legitimate scarcity made possible by the blockchain, buyers can rest assured that the art they purchase is, in fact, rare. This gives digital art real value that we’ve never seen before.\n\nGame items will have a history that’s stored in the blockchain. This history could deem an item more valuable, for example if it was used to accomplish great achievements or used by someone who’s admired.\n\nDepending on the contract describing the token, each NFT could either be immutable, or you could allow players to customize and change certain characteristics about them if they choose to.\n\nERC721 is the most accepted standard for non-fungible tokens in the Ethereum Network. LAND tokens follow the ERC721 standard.\n\nSmart Contracts\n\nA contract consists of a both code (its methods) and data (its state) that resides at a specific address on the Ethereum blockchain.\n\nThe methods in a contract are always called via a transaction that has the to field set to the contract’s address. The code that’s executed by the contract’s method can include calls to other contracts, these trigger more transactions that have the from field set to the contract’s address.\n\nA contract can’t trigger any actions on its own or based on a time event. All actions performed by a smart contract always arise from a transaction that calls one of the contract’s functions.\nYou can use smart contracts to condition transactions based on custom conditions. For example, players could stake a bet on the outcome of a game, and the corresponding payments would occur as soon as the outcome of the game is informed to the contract.\nThe entire code for a smart contract is public to whoever wants to read it. This allows developers to create publicly verifiable rules.\nAll Tokens are defined by a smart contract that specifies its characteristics and what can be done with it. Decentraland has written and maintains a number of smart contracts. LAND and MANA tokens themselves are defined by the LANDregistry and MANAtoken contracts respectively.\n\nYou can find the address of every contract created by Decentraland in Decentraland smart contracts.\n\nYou can read the full code of each of those contracts, as it’s public information on the blockchain. You can find the contract by name on Etherscan and read its content there.\n\ndApps\n\ndApps (decentralized applications) are applications that are built upon smart contracts and the blockchain.\n\nA dApp can be as simple as something that validates that your wallet holds a certain token and lets you use a service. Or it can be a fully fledged application with its own UI, such as the Decentraland Marketplace.\n\nIf you want to build your own dApp around Decentrlanad, see Create a dApp.\n\nRopsten test network\n\nBefore you deploy a smart contract, create a new type of token, or a Decentraland scene that relies on transactions on the Ethereum network, you need to make sure that it has no bugs or gaps that malicious users could exploit.\n\nThe Ropsten test network is an alternative version of Ethereum that’s specifically made for running tests.\n\nTokens in the Ropsten network have no real value, so you can afford to make mistakes without running any real risk. You can replenish any lost tokens for free by using a faucet:\n\n\n  Ropsten Ether faucet (https://faucet.ropsten.be/)\n  Ropsten MANA faucet (https://faucet.decentraland.today/)\n\n\nIf you’re developing a scene that triggers transactions, testing these transactions in the Ropsten network is free, as the tokens you send don’t have a value. In mainnet you would otherwise have to pay at the very least a real gas fee in Ether for each test transaction you carry out.\n\nOnce you’re confident that your code works as expected and can’t be exploited, you can deploy to the Ethereum mainnet.\n\nBlockchain reorgs\n\nOccasionally, multiple machines will create alternative new blocks at roughly the same time. This is a problem, because this forks the chain into two diverging versions that could potentially contradict each other. When a fork occurs, Ethereum solves this by always giving priority to the longest chain and discarding any shorter chains. Even though it’s possible for two rivaling chains to exist at the same time, soon one of the two chains will add another block and outgrow the other. Due to the time it takes to solve the mining algorithms, it becomes increasingly difficult for rivaling chains to keep growing in perfect sync with each other. Sooner or later one will prevail over the other.\n\nWhen one chain outgrows the other and the dispute is resolved, machines that had adopted the shorter chain need to make adjustments. This is what’s known as a “reorg”. They need to roll back on all of the transactions included in the blocks from the branch they’re in until they reach the point at which the fork occurred. Then they need to add the new blocks from the longer branch that’s considered legitimate.\n\nRolled back transactions may return to the pool of pending transactions until they’re picked up again by a miner (or are discarded). Any gas fees paid for these transactions are also rolled back.\n\nBlocks that were just added to the end of a chain have a substantial chance of being rolled back because of the mechanisms explained above. As subsequent blocks are added to the end of the chain, it becomes less and less likely that the blocks that are further back in the blockchain could be rolled back, because that would require a larger reorg. Due to this, each new block that’s added to the end of the chain after a transaction is called a confirmation for that transaction.\n\nWhen creating applications (or scenes) that use information from off the blockchain, you should be aware of the occurrence of reorgs. You might want to only consider transactions as verified when a certain number of confirmations have occurred, and the transaction is no longer at the very end of the chain.\n\nUsing several confirmations will make the information very stable, but transactions will take a long time to be reflected.\nUsing few confirmations, changes will be reflected faster, but there will sometimes be hiccups that appear to undo transactions when reorgs occur. If these transactions have off-chain consequences in your scene, then you might need to somehow reverse these consequences as well."
        }
        
      
    
  
}
